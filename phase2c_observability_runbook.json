{
  "runbook/production_readiness_runbook.md": "# Production Readiness — One-Pager\n\n**Objective:** Decide Go / No-Go for enabling real capital on the autonomous trading agent.\n\n---\n## 0) Preconditions (must all be true)\n- **Paper vs Live:** Canary (paper shadow) running alongside live for ≥ 10 trading days.\n- **Secrets:** No secrets in logs or endpoints. Rotation playbook tested.\n- **Kill Switch:** Manual kill verified (halts new orders instantly).\n- **Compliance:** Immutable audit log enabled and verifying (hash chain OK).\n\n---\n## 1) Data SLOs (past 5 trading days)\n- **Quote freshness:** p95 provider freshness ≤ **1.5 s**; stale bars ≤ **0.5%** of session.\n- **Consensus failures:** ≤ **0.2%** of decision ticks; dynamic thresholds active.\n- **WS reliability:** Reconnect MTTR ≤ **5 s**; zero unrecovered gaps (backfill OK).\n\n**Fail means:** stay in canary, fix ProviderRouter or networking.\n\n---\n## 2) Decision/Execution Latency SLOs\n- **Decision latency (data→decision):** p95 ≤ **120 ms**; p99 ≤ **250 ms**.\n- **Order ack latency (send→ack):** p95 ≤ **300 ms** (broker); p99 ≤ **700 ms**.\n- **End-to-end (data→ack):** p95 ≤ **500 ms**.\n\n**Fail means:** profile hotspots; optimize I/O, batching, JSON parsing, logging, or move hot paths off main thread.\n\n---\n## 3) Execution Quality (sim overlay + live)\n- **Slippage vs mid:** median within **±5 bps** of simulator expectation per liquidity bucket.\n- **Adverse selection:** no more than **55%** of fills at worse-than-expected side for top-2 buckets.\n- **Auction/halts:** 0 orders attempted during auction windows or halts.\n\n**Fail means:** tighten bands, enable more slicing (POV/TWAP), revisit spread caps.\n\n---\n## 4) Risk & Drawdown Controls\n- **Daily max loss:** never breached in canary simulation; kill switch observed in chaos tests.\n- **DD de-risking:** risk multipliers triggered correctly at 2% / 4% DD.\n- **Exposure caps:** symbol ≤ 7%, sector ≤ 15%, total ≤ 70% enforced.\n\n**Fail means:** fix risk gate ordering before order routing; add pre-send assert.\n\n---\n## 5) Portfolio Exposures & Attribution\n- **Net beta:** |β| ≤ **0.25** target (or policy value) at close.\n- **Sector tilt:** no sector weight > **+10pp** relative to benchmark without explicit waiver.\n- **Attribution:** daily Brinson & factor report generated; no NaNs / missing sectors.\n\n**Fail means:** add balancing trades or reduce universe concentration.\n\n---\n## 6) Canary vs Paper Diff (past 5 days)\n- **Price divergence:** median |diff| ≤ **10 bps**; 95th ≤ **25 bps**.\n- **PnL divergence:** |Δ PnL| ≤ **0.8%** of notional per day.\n\n**Fail means:** investigate broker fees, route, slippage parameters, or data timing skew.\n\n---\n## 7) Alarms & On-Call\n- Pager on: provider outage, stale quotes, consensus failure spike, kill-switch trigger, audit hash mismatch.\n- Runbook links from each alarm to steps & owners.\n\n---\n## 8) Go / No-Go Gate\n- If **all SLOs green for 5 consecutive trading days**, promote to **Limited Live** (tiny notional).\n- Maintain canary shadow for at least **20 additional trading days**; escalate only after stability.\n\n---\n## 9) Rollback Plan\n- Single toggle to paper-only.\n- Disable entries; manage exits only.\n- Snapshot configs + state.\n",
  "tickets/19-observability-export.md": "# Ticket 19 — Prometheus & OTLP exporters\n\n## Goal\nExpose Prometheus metrics and optional OTLP (OpenTelemetry) traces/metrics for external observability.\n\n## Deliverables\n- `/metrics` Prometheus endpoint with counters/gauges for freshness, consensus failures, latency histograms.\n- OTLP shim that batches simple spans to an OTLP HTTP endpoint (config via env).\n- Docs to run alongside the existing `/metrics/dashboard`.\n\n## Acceptance\n- `curl :8787/metrics` returns valid Prometheus text format.\n- When `OTLP_ENDPOINT` set, traces are posted (200 OK) with retries off the hot path.\n",
  "src/obs/prometheus.ts": "import Fastify from 'fastify';\nimport { snapshot } from './e2e';\n\n// Minimal Prometheus text endpoint for core histograms\nexport function promText(){\n  const s = snapshot();\n  const lines:string[] = [];\n  lines.push('# HELP e2e_latency_ms End-to-end latency quantiles');\n  lines.push('# TYPE e2e_latency_ms summary');\n  lines.push(`e2e_latency_ms{quantile=\"0.5\"} ${s.e2e.p50}`);\n  lines.push(`e2e_latency_ms{quantile=\"0.95\"} ${s.e2e.p95}`);\n  lines.push(`e2e_latency_ms{quantile=\"0.99\"} ${s.e2e.p99}`);\n  lines.push(`e2e_latency_ms_count ${s.e2e.n}`);\n  lines.push('# HELP decision_latency_ms Decision latency quantiles');\n  lines.push('# TYPE decision_latency_ms summary');\n  lines.push(`decision_latency_ms{quantile=\"0.5\"} ${s.decision.p50}`);\n  lines.push(`decision_latency_ms{quantile=\"0.95\"} ${s.decision.p95}`);\n  lines.push(`decision_latency_ms{quantile=\"0.99\"} ${s.decision.p99}`);\n  lines.push(`decision_latency_ms_count ${s.decision.n}`);\n  lines.push('# HELP order_ack_latency_ms Order ack latency quantiles');\n  lines.push('# TYPE order_ack_latency_ms summary');\n  lines.push(`order_ack_latency_ms{quantile=\"0.5\"} ${s.ack.p50}`);\n  lines.push(`order_ack_latency_ms{quantile=\"0.95\"} ${s.ack.p95}`);\n  lines.push(`order_ack_latency_ms{quantile=\"0.99\"} ${s.ack.p99}`);\n  lines.push(`order_ack_latency_ms_count ${s.ack.n}`);\n  return lines.join('\\n') + '\\n';\n}\n\nexport async function startPromServer(port=8788){\n  const app = Fastify();\n  app.get('/metrics', async (_req, res)=> { res.header('Content-Type', 'text/plain; version=0.0.4'); res.send(promText()); });\n  await app.listen({ port, host:'0.0.0.0' });\n  // eslint-disable-next-line no-console\n  console.log(`[prometheus] listening on :${port}/metrics`);\n}\n",
  "src/obs/otlp.ts": "/* Minimal OTLP HTTP exporter (traces).\n   - Set OTLP_ENDPOINT=https://otel-collector:4318/v1/traces\n   - Optional: OTLP_HEADERS='Authorization=Bearer xxx,User-Agent=agent' */\nexport type OtlpSpan = { traceId:string; spanId:string; name:string; startTimeUnixNano:string; endTimeUnixNano:string; attributes?:{key:string; value:{stringValue?:string; intValue?:string; doubleValue?:number}}[] };\n\nfunction ns(ms:number){ return String(BigInt(Math.floor(ms)) * 1000000n); }\nfunction headersFromEnv(){ const h:Record<string,string>={ 'content-type':'application/json' }; const raw=process.env.OTLP_HEADERS||''; raw.split(',').map(x=>x.trim()).filter(Boolean).forEach(kv=>{ const [k,...rest]=kv.split('='); h[k.trim()]=rest.join('='); }); return h; }\n\nexport async function exportOtlp(spans:OtlpSpan[]){\n  const url = process.env.OTLP_ENDPOINT; if(!url || spans.length===0) return;\n  const body = { resourceSpans:[{ resource:{ attributes:[] }, scopeSpans:[{ scope:{ name:'agent' }, spans }] }] };\n  try{ const r = await fetch(url, { method:'POST', headers: headersFromEnv(), body: JSON.stringify(body) }); if(!r.ok){ /* swallow or log */ } } catch { /* network errors ignored */ }\n}\n\nexport function spanToOtlp(name:string, traceId:string, spanId:string, tsStart:number, tsEnd:number, attrs?:Record<string,any>): OtlpSpan{\n  const attributes = Object.entries(attrs||{}).map(([key,val])=>({ key, value: typeof val==='number'? { doubleValue: val }: { stringValue: String(val) } }));\n  return { name, traceId, spanId, startTimeUnixNano: ns(tsStart), endTimeUnixNano: ns(tsEnd), attributes };\n}\n",
  "src/api/metrics.ts": "import Fastify from 'fastify';\nimport { dashboard } from '../obs/dashboard';\nimport { promText } from '../obs/prometheus';\n\nexport const app = Fastify();\napp.get('/metrics/dashboard', async (_req, res)=> { res.send(dashboard()); });\napp.get('/metrics', async (_req, res)=> { res.header('Content-Type','text/plain; version=0.0.4'); res.send(promText()); });\n\nexport async function startMetricsApi(port=8787){ await app.listen({ port, host:'0.0.0.0' }); }\n",
  "tests/prom.spec.ts": "import { describe, it, expect } from 'vitest';\nimport { promText } from '../src/obs/prometheus';\n\ndescribe('prometheus text', ()=>{\n  it('renders valid text', ()=>{ const t = promText(); expect(t).toContain('e2e_latency_ms'); expect(t).toContain('decision_latency_ms'); });\n});\n"
}
