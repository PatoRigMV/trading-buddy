<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Cache buster: v2.0.1 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>[*] TRADING-TERMINAL v5.4 - AUTONOMOUS AGENT [*]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@400;700&family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- DOMPurify for XSS prevention -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <style>
        :root {
            /* Theme Variables - Using Design Tokens */
            --bg-primary: #000000;
            --bg-secondary: transparent;
            --text-primary: #ffffff;
            --text-secondary: var(--color-text-secondary);
            --border-color: var(--color-border);
            --positive: var(--color-success);
            --negative: var(--color-error);
            --accent: var(--color-success);
        }

        [data-theme="light"] {
            --bg-primary: #000000;
            --bg-secondary: transparent;
            --text-primary: #ffffff;
            --text-secondary: var(--color-text-secondary);
            --border-color: var(--color-border);
            --positive: var(--color-success);
            --negative: var(--color-error);
            --accent: var(--color-success);
        }

        /* ===== DESIGN SYSTEM ===== */
        /* Standardized Design Tokens for Consistency */

        :root {
            /* Typography System */
            --text-h1-size: 32px;
            --text-h1-weight: 700;
            --text-h1-height: 1.2;

            --text-h2-size: 24px;
            --text-h2-weight: 600;
            --text-h2-height: 1.3;

            --text-h3-size: 20px;
            --text-h3-weight: 600;
            --text-h3-height: 1.4;

            --text-body-size: 16px;
            --text-body-weight: 400;
            --text-body-height: 1.6;

            --text-body-bold-size: 16px;
            --text-body-bold-weight: 600;
            --text-body-bold-height: 1.6;

            --text-caption-size: 14px;
            --text-caption-weight: 400;
            --text-caption-height: 1.4;

            --text-label-size: 14px;
            --text-label-weight: 500;
            --text-label-height: 1.4;

            /* Color System - Black Primary */
            --color-primary: #000000;
            --color-secondary: #333333;
            --color-accent: var(--color-success);
            --color-error: #ff4444;
            --color-warning: #ffaa00;
            --color-success: #00ff88;
            --color-background: #ffffff;
            --color-surface: transparent;
            --color-border: #444444;
            --color-text-primary: var(--color-primary);
            --color-text-secondary: #cccccc;

            /* Spacing System */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;
            --space-3xl: 48px;

            /* Border Radius - Consistent 0px */
            --radius: 0px;
            --radius-sm: 0px;
            --radius-md: 0px;
            --radius-lg: 0px;

            /* Font Family System */
            --font-family-monospace: 'Geist Mono', ui-monospace, 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
        }

        /* ===== TYPOGRAPHY SYSTEM ===== */
        /* Standardized Typography Classes */

        .text-h1 {
            font-size: var(--text-h1-size);
            font-weight: var(--text-h1-weight);
            line-height: var(--text-h1-height);
            color: var(--color-primary);
        }

        .text-h2 {
            font-size: var(--text-h2-size);
            font-weight: var(--text-h2-weight);
            line-height: var(--text-h2-height);
            color: var(--color-primary);
        }

        .text-h3 {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            color: var(--color-primary);
        }

        .text-body {
            font-size: var(--text-body-size);
            font-weight: var(--text-body-weight);
            line-height: var(--text-body-height);
            color: var(--color-primary);
        }

        .text-body-bold {
            font-size: var(--text-body-bold-size);
            font-weight: var(--text-body-bold-weight);
            line-height: var(--text-body-bold-height);
            color: var(--color-primary);
        }

        .text-caption {
            font-size: var(--text-caption-size);
            font-weight: var(--text-caption-weight);
            line-height: var(--text-caption-height);
            color: var(--color-text-secondary);
        }

        .text-label {
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            line-height: var(--text-label-height);
            color: var(--color-primary);
        }

        /* ===== COMPONENT SYSTEM ===== */
        /* Standardized Component Base Styles */

        .component-base {
            border-radius: 0px;
            border: 1px solid var(--color-border);
        }

        /* ===== STANDARDIZED BUTTON SYSTEM ===== */
        /* Base button styles - all buttons inherit these */
        .btn-base {
            font-family: inherit;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            text-transform: uppercase;
            border-radius: 0px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid;
            padding: var(--space-sm) var(--space-md);
            margin: var(--space-xs);
        }

        /* Primary Buttons - Main actions */
        .btn-primary {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-primary);
            color: var(--color-background);
            border: 1px solid var(--color-primary);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-primary:hover {
            background-color: var(--color-background);
            color: var(--color-primary);
        }

        /* Secondary Buttons - Secondary actions */
        .btn-secondary {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-secondary:hover {
            background-color: var(--color-primary);
            color: var(--color-background);
        }

        /* Danger Buttons - Emergency/destructive actions */
        .btn-danger {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-error);
            border: 1px solid var(--color-error);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-danger:hover {
            background-color: var(--color-error);
            color: var(--color-background);
        }

        /* Filter Buttons - Navigation and filtering */
        .btn-filter {
            padding: var(--space-xs) var(--space-sm);
            background-color: var(--color-background);
            color: var(--color-primary);
            border: 1px solid var(--color-border);
            border-radius: 0px;
            font-size: var(--text-caption-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-filter:hover, .btn-filter.active {
            background-color: var(--color-primary);
            color: var(--color-background);
        }

        .btn-filter:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button size variants */
        .btn-small {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-caption-size);
            margin: var(--space-xs);
        }

        .btn-large {
            padding: var(--space-md) var(--space-lg);
            font-size: var(--text-body-size);
            margin: var(--space-xs);
        }

        /* ===== SPECIALIZED BUTTON PATTERNS ===== */
        /* Refresh button pattern - consistent across all refresh buttons */
        .btn-refresh {
            float: right;
            margin-left: var(--space-sm);
            font-size: var(--text-caption-size);
            padding: var(--space-xs) var(--space-sm);
        }

        /* Inline form button pattern - for buttons next to inputs */
        .btn-inline {
            margin-left: var(--space-sm);
            padding: var(--space-sm);
        }

        /* Strategy card button pattern */
        .btn-strategy {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-strategy:hover {
            background: var(--color-primary);
            color: var(--color-background);
        }

        .card-base {
            background-color: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 0px;
            padding: var(--space-md);
        }

        .input-base {
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: 0px;
            font-size: var(--text-body-size);
            color: var(--color-primary);
            background-color: var(--color-background);
        }

        /* ===== SPACING UTILITIES ===== */
        .m-xs { margin: var(--space-xs); }
        .m-sm { margin: var(--space-sm); }
        .m-md { margin: var(--space-md); }
        .m-lg { margin: var(--space-lg); }
        .m-xl { margin: var(--space-xl); }

        .p-xs { padding: var(--space-xs); }
        .p-sm { padding: var(--space-sm); }
        .p-md { padding: var(--space-md); }
        .p-lg { padding: var(--space-lg); }
        .p-xl { padding: var(--space-xl); }

        /* ===== STANDARDIZED GRID SYSTEM ===== */
        /* Consistent grid patterns for different content types */
        .grid-standard {
            display: grid;
            gap: var(--space-md);
        }

        .grid-compact {
            display: grid;
            gap: var(--space-sm);
        }

        .grid-spacious {
            display: grid;
            gap: var(--space-lg);
        }

        /* Standard grid column patterns */
        .grid-auto-fit-200 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .grid-auto-fit-280 {
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }

        .grid-auto-fit-400 {
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        }

        .grid-two-cols {
            grid-template-columns: 1fr 1fr;
        }

        /* Responsive grid adjustments */
        @media (max-width: 768px) {
            .grid-auto-fit-200,
            .grid-auto-fit-280,
            .grid-auto-fit-400,
            .grid-two-cols {
                grid-template-columns: 1fr;
            }
        }

        /* ASCII Animation Styles */
        .ascii-break {
            font-family: var(--font-family-monospace);
            font-size: calc(var(--text-caption-size) * 0.8);
            line-height: 1;
            text-align: center;
            color: #FFFFFF !important;
            background: transparent;
            border: none;
            margin: var(--space-xl) 0;
            padding: 0 var(--space-lg) var(--space-lg) var(--space-lg);
            overflow: hidden;
            white-space: pre;
            user-select: none;
            opacity: 1.0;
            transition: opacity 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            height: 80px;
            max-height: 80px;
        }

        .ascii-break:hover {
            opacity: 1;
        }

        /* Override theme colors - always white */
        .ascii-break {
            color: #FFFFFF !important;
            text-shadow: none !important;
        }

        /* Responsive sizing */
        @media (max-width: 768px) {
            .ascii-break {
                font-size: var(--text-caption-size);
                margin: var(--space-lg) 0;
                padding: var(--space-md);
            }
        }

        @media (max-width: 480px) {
            .ascii-break {
                font-size: var(--text-caption-size);
                margin: var(--space-md) 0;
                padding: var(--space-sm);
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: var(--font-family-monospace);
        }

        html, body {
            font-family: var(--font-family-monospace);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.4;
            overflow-x: hidden;
        }

        .terminal-container {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            /* REMOVED: min-height: 100vh; - was causing 1355px forced height */
            padding: 0 var(--space-lg) var(--space-lg) var(--space-lg); /* FIXED: top=0, right=24px, bottom=24px, left=24px */
        }

        .terminal-header {
            padding: var(--space-lg) 0 var(--space-md) 0;
            margin-bottom: var(--space-md);
            position: relative;
            display: flex;
            justify-content: center;
        }

        .donut-container {
            display: flex;
            align-items: center;
            gap: var(--space-2xl);
            justify-content: center;
        }

        .donut-display {
            font-family: var(--font-family-monospace);
            font-size: calc(var(--text-caption-size) * 0.8);
            line-height: 1;
            color: #FFFFFF !important;
            background: transparent;
            border: none;
            margin: 0;
            padding: 0;
            white-space: pre;
        }



        .terminal-title {
            font-size: var(--text-h2-size);
            font-weight: var(--text-h2-weight);
            line-height: var(--text-h2-height);
            letter-spacing: 2px;
            margin-bottom: var(--space-sm);
            overflow: hidden;
            color: var(--text-primary);
            white-space: nowrap;
            position: relative;
            display: inline-block;
        }

        .terminal-title-text {
            display: inline-block;
        }

        .market-movers-marquee {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: var(--space-sm) 0;
            margin-bottom: var(--space-lg);
            overflow: hidden;
            white-space: nowrap;
            position: relative;
        }

        .marquee-content {
            display: inline-block;
            font-size: var(--text-caption-size);
            font-weight: 300;
            letter-spacing: 1px;
            animation-play-state: paused; /* Start paused until data loads */
        }

        .marquee-content.animated {
            animation: scroll-left 60s linear infinite;
        }

        .mover-item {
            display: inline-block;
            margin-right: var(--space-3xl);
            padding: 0 5px;
        }

        .mover-symbol {
            color: var(--text-primary);
        }

        .mover-price {
            color: var(--text-secondary);
            font-weight: 500;
            margin: 0 8px;
        }

        .mover-change.positive {
            color: var(--positive);
        }

        .mover-change.negative {
            color: var(--negative);
        }

        @keyframes scroll-left {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-50%); }
        }


        .theme-toggle-container {
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            height: 26px;
        }

        .theme-toggle {
            background: var(--color-secondary);
            border: 1px solid var(--color-text-secondary);
            border-radius: 0px;
            width: 50px;
            height: 26px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            padding: var(--space-xs);
            position: relative;
            display: flex;
            align-items: center;
        }

        .theme-toggle:hover {
            background: var(--color-secondary);
            border-color: var(--color-text-secondary);
        }

        .theme-toggle-slider {
            background: var(--color-background);
            border-radius: 0px;
            width: 20px;
            height: 20px;
            transition: transform 0.3s ease;
            position: absolute;
            left: var(--space-xs);
        }

        .theme-toggle[data-theme="light"] .theme-toggle-slider {
            transform: translateX(24px);
        }

        .theme-icon {
            width: 12px;
            height: 12px;
            transition: opacity 0.3s ease;
            opacity: 0.5;
        }

        .theme-toggle-container[data-theme="light"] .sun-icon {
            opacity: 1;
        }

        .theme-toggle-container[data-theme="dark"] .moon-icon {
            opacity: 1;
        }

        .terminal-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            margin-bottom: var(--space-lg);
            padding: var(--space-lg);
        }

        .section-title {
            font-size: var(--text-h2-size);
            font-weight: var(--text-h2-weight);
            line-height: var(--text-h2-height);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--space-sm);
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
        }

        /* Legacy button classes - mapped to new system */
        .btn-terminal {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-primary);
            color: var(--color-background);
            border: 1px solid var(--color-primary);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-terminal:hover, .btn-terminal:focus {
            background-color: var(--color-background);
            color: var(--color-primary);
            outline: none;
        }

        .btn-terminal:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-terminal:disabled:hover {
            background-color: var(--color-primary);
            color: var(--color-background);
        }

        .btn-emergency {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-error);
            border: 1px solid var(--color-error);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-emergency:hover, .btn-emergency:focus {
            background-color: var(--color-error);
            color: var(--color-background);
            outline: none;
        }

        .status-indicator {
            display: inline-block;
            margin-right: var(--space-sm);
            font-weight: 400;
            font-size: var(--text-caption-size);
        }

        .status-running { color: var(--positive); }
        .status-stopped { color: var(--negative); }
        .status-unknown { color: var(--text-secondary); }

        .chart-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            margin-bottom: var(--space-lg);
            padding: var(--space-lg);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
        }

        .chart-title {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-primary);
        }

        .chart-filters {
            display: flex;
            gap: var(--space-xs);
            flex-wrap: wrap;
            align-items: center;
        }

        .chart-filter {
            padding: var(--space-xs) var(--space-sm);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            font-size: var(--text-caption-size);
            font-weight: var(--text-label-weight);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .chart-filter:hover, .chart-filter.active {
            background-color: var(--text-primary);
            color: var(--bg-primary);
        }

        .chart-refresh-btn {
            padding: var(--space-xs) var(--space-sm);
            background-color: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            font-size: var(--text-caption-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: var(--space-sm);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .chart-refresh-btn:hover {
            background-color: var(--text-primary);
            color: var(--bg-primary);
        }

        .chart-refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .chart-refresh-btn .refresh-icon {
            font-size: var(--text-caption-size);
        }

        .chart-refresh-btn.loading .refresh-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 300px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .chart-tooltip {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: var(--space-sm) var(--space-sm);
            font-size: var(--text-caption-size);
            font-weight: 700;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
            font-family: inherit;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Shadcn-style Chart Card Components */
        .chart-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            margin-bottom: var(--space-lg);
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .chart-card-header {
            padding: var(--space-lg) var(--space-lg) 0;
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .chart-card-title h3 {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            margin: 0 0 var(--space-xs) 0;
            color: var(--text-primary);
        }

        .chart-card-description {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }

        .chart-card-content {
            padding: var(--space-md) var(--space-lg) var(--space-lg) var(--space-lg);
        }

        .chart-container-enhanced {
            position: relative;
            width: 100%;
            height: 300px;
            min-width: 0;
            overflow: hidden;
        }

        .chart-canvas-responsive {
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
        }

        #chartdiv {
            width: 100%;
            height: 300px;
        }

        .chart-tooltip-enhanced {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm) var(--space-sm);
            font-size: var(--text-caption-size);
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
            font-family: inherit;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .chart-card-footer {
            padding: 0 var(--space-lg) var(--space-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--space-md);
        }

        .chart-trend-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: var(--text-caption-size);
            font-weight: 500;
        }

        .trend-icon {
            stroke-width: 2;
        }

        .chart-time-range {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
        }

        /* CSS Variables for chart colors */
        :root {
            --chart-primary: var(--text-primary);
        }

        /* Theme-specific gradient updates */
        [data-theme="light"] .chart-card {
            --chart-gradient: url(#chartGradientLight);
        }

        [data-theme="dark"] .chart-card {
            --chart-gradient: url(#chartGradientDark);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .chart-card-header {
                padding: var(--space-md) var(--space-md) 0;
            }

            .chart-card-content {
                padding: var(--space-md);
                padding-top: var(--space-sm);
            }

            .chart-card-footer {
                padding: 0 var(--space-md) var(--space-md);
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-sm);
            }

            .chart-container-enhanced {
                height: 300px;
            }
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-lg);
            margin: var(--space-lg) 0;
        }

        .metric-item {
            text-align: center;
            padding: var(--space-lg);
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
        }

        .metric-value {
            font-size: var(--text-h2-size);
            font-weight: 700;
            margin-bottom: var(--space-xs);
        }

        .metric-label {
            font-size: var(--text-caption-size);
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        /* Analysis Tab Grid Layout */
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        /* Analysis Cards */
        .analysis-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease;
        }


        /* Card size variations */
        .analysis-card-wide {
            grid-column: span 2;
        }

        .analysis-card-full {
            grid-column: 1 / -1;
        }

        /* Dough Report Styles */
        .dough-report-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            margin-top: var(--space-md);
        }

        .dough-report-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--space-lg);
        }

        .dough-report-section h4 {
            color: var(--accent-orange);
            margin-bottom: var(--space-md);
            font-size: var(--text-lg-size);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .dough-report-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .dough-report-metric:last-child {
            border-bottom: none;
        }

        .dough-report-metric-label {
            color: var(--text-secondary);
            font-size: var(--text-sm-size);
        }

        .dough-report-metric-value {
            font-weight: var(--text-bold-weight);
            color: var(--text-primary);
        }

        .dough-report-trades {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .dough-report-trade {
            background: var(--bg-tertiary);
            padding: var(--space-md);
            border-radius: var(--border-radius);
            border-left: 3px solid var(--accent-orange);
        }

        .dough-report-trade-symbol {
            font-weight: var(--text-bold-weight);
            color: var(--accent-orange);
            font-size: var(--text-lg-size);
        }

        .dough-report-trade-reason {
            color: var(--text-secondary);
            font-size: var(--text-sm-size);
            margin-top: var(--space-xs);
        }

        .dough-report-recommendations {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .dough-report-recommendation {
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border-left: 3px solid var(--success-color);
            font-size: var(--text-sm-size);
        }

        @media (max-width: 768px) {
            .dough-report-content {
                grid-template-columns: 1fr;
                gap: var(--space-md);
            }
        }

        .analysis-card-header {
            padding: var(--space-lg) var(--space-lg) 0;
        }

        .analysis-card-title h3 {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            margin: 0 0 6px 0;
            color: var(--text-primary);
        }

        .analysis-card-description {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }

        .analysis-card-content {
            padding: var(--space-md) var(--space-lg) var(--space-lg);
        }

        .analysis-content {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            line-height: 1.6;
            min-height: 150px;
        }

        .analysis-footer {
            text-align: center;
            padding: var(--space-md);
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
            margin-top: var(--space-lg);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }

            .analysis-card-wide,
            .analysis-card-full {
                grid-column: span 1;
            }
        }

        @media (max-width: 768px) {
            .analysis-grid {
                gap: var(--space-md);
                margin-bottom: var(--space-md);
            }

            .analysis-card-header {
                padding: var(--space-md) var(--space-md) 0;
            }

            .analysis-card-content {
                padding: var(--space-xs) var(--space-md) var(--space-md);
            }

            .analysis-content {
                min-height: 120px;
            }

            .analysis-footer {
                padding: var(--space-sm);
                margin-top: var(--space-md);
            }
        }

        /* Stock Position Cards */
        .stock-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .stock-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-md);
            transition: all 0.2s ease;
            position: relative;
        }

        .stock-card:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 8px -2px rgba(0, 0, 0, 0.1);
        }

        .stock-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--space-sm);
        }

        .stock-symbol {
            font-family: var(--font-family-monospace);
            font-size: var(--text-body-size);
            font-weight: 700;
            color: var(--text-primary);
        }

        .stock-quantity {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            text-align: right;
        }

        .stock-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
        }

        .stock-metric {
            display: flex;
            flex-direction: column;
        }

        .stock-metric-label {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }

        .stock-metric-value {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            color: var(--text-primary);
            font-weight: 600;
        }

        .stock-pnl {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: var(--space-sm);
            border-top: 1px solid var(--border-color);
            margin-top: var(--space-sm);
        }

        .stock-pnl-amount {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            font-weight: 600;
        }

        .stock-pnl-percent {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
        }

        @media (max-width: 768px) {
            .stock-cards-grid {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }

            .stock-card {
                padding: var(--space-sm);
            }

            .stock-metrics {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }
        }

        /* New Analysis Tab Layout Styles */
        .portfolio-summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            margin-top: var(--space-sm);
        }

        .portfolio-allocation h4,
        .portfolio-insights h4 {
            font-size: var(--text-body-size);
            font-weight: 600;
            margin: 0 0 var(--space-sm) 0;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--space-sm);
        }

        .analysis-section {
            margin-bottom: var(--space-xl);
        }

        .section-title-header {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--border-color);
        }

        .section-title-header h3 {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            margin: 0 0 var(--space-xs) 0;
            color: var(--text-primary);
        }

        .section-description {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }

        .equity-positions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .market-conditions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .sector-card {
            border: 1px solid var(--border-color);
            padding: var(--space-md);
            background: var(--bg-primary);
            border-radius: 0px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .sector-card:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
        }

        .sector-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .sector-name {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            font-weight: 700;
            color: var(--text-primary);
        }

        .sector-trend {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            font-weight: 600;
            padding: var(--space-xs) var(--space-xs);
            border-radius: 0px;
            text-transform: uppercase;
        }

        .sector-trend.bullish {
            background: rgba(0, 255, 136, 0.2);
            color: var(--positive);
        }

        .sector-trend.bearish {
            background: rgba(255, 68, 68, 0.2);
            color: var(--negative);
        }

        .sector-trend.neutral {
            background: rgba(102, 102, 102, 0.2);
            color: var(--text-secondary);
        }

        .sector-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
        }

        .sector-metric {
            display: flex;
            flex-direction: column;
        }

        .sector-metric-label {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }

        .sector-metric-value {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            color: var(--text-primary);
            font-weight: 600;
        }

        .sector-symbol {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            text-align: center;
            margin-top: var(--space-sm);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--border-color);
        }

        @media (max-width: 768px) {
            .portfolio-summary-grid {
                grid-template-columns: 1fr;
                gap: var(--space-md);
            }

            .market-conditions-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: var(--space-sm);
            }

            .sector-metrics {
                grid-template-columns: 1fr;
                gap: var(--space-xs);
            }
        }

        /* Additional sector card styles for equity positions */
        .sector-card-metrics {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-sm);
            flex-wrap: wrap;
        }

        .sector-metric {
            display: flex;
            gap: var(--space-xs);
            font-size: var(--text-caption-size);
        }

        .sector-metric .metric-label {
            color: var(--text-secondary);
        }

        .sector-metric .metric-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .sector-card-targets {
            margin-top: var(--space-sm);
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--border-color);
        }

        /* Portfolio Summary Styles */
        .metric-item {
            margin-bottom: var(--space-sm);
        }

        .metric-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: var(--space-xs);
        }

        .metric-value {
            color: var(--accent);
            font-weight: 500;
        }

        .allocation-item, .performance-item, .risk-item {
            margin: var(--space-xs) 0;
            padding-left: var(--space-sm);
            font-size: var(--text-caption-size);
        }

        .allocation-value, .risk-value {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .insights-header {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            font-size: var(--text-body-size);
        }

        .insight-item {
            margin: var(--space-sm) 0;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Options Analysis Full-Width Card Styles */
        .options-full-width-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .options-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--border-color);
        }

        .options-card-title {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            color: var(--text-primary);
            margin: 0;
        }

        .options-card-timestamp {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
        }

        .options-content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
        }

        .options-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-md);
        }

        .options-section.full-width {
            grid-column: 1 / -1;
        }

        .options-section-title {
            font-size: var(--text-body-size);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 16px 0;
        }

        .options-strategies-grid {
            display: grid;
            gap: var(--space-sm);
        }

        .options-strategy-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
        }

        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .strategy-type {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: var(--space-xs) var(--space-xs);
            border-radius: 0px;
        }

        .strategy-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
        }

        .strategy-metrics {
            display: flex;
            gap: var(--space-sm);
            font-size: var(--text-caption-size);
        }

        .strategy-metrics .pnl {
            font-weight: 600;
        }

        .strategy-metrics .greek {
            color: var(--text-secondary);
        }

        .greeks-grid, .risk-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-sm);
        }

        .greek-item, .risk-item {
            background: var(--bg-secondary);
            padding: var(--space-sm) var(--space-sm);
            border-radius: 0px;
            border: 1px solid var(--border-color);
        }

        .greek-label, .risk-label {
            display: block;
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
        }

        .greek-value, .risk-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .insights-list {
            display: grid;
            gap: var(--space-sm);
        }

        .insights-list .insight-item {
            padding: var(--space-sm) var(--space-sm);
            background: var(--bg-secondary);
            border-radius: 0px;
            border-left: var(--space-xs) solid var(--accent);
        }

        /* Responsive adjustments for options analysis */
        @media (max-width: 768px) {
            .options-content-grid {
                grid-template-columns: 1fr;
            }

            .strategy-details {
                grid-template-columns: 1fr;
            }

            .strategy-metrics {
                flex-direction: column;
                gap: var(--space-xs);
            }

            .greeks-grid, .risk-grid {
                grid-template-columns: 1fr;
            }
        }

        .positive { color: var(--positive) !important; }
        .negative { color: var(--negative) !important; }

        .terminal-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--text-caption-size);
            margin: var(--space-lg) 0;
        }

        .terminal-table th,
        .terminal-table td {
            padding: var(--space-sm);
            text-align: left;
            border: 1px solid var(--border-color);
            font-family: inherit;
        }

        .terminal-table th {
            background: var(--bg-secondary);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .terminal-table tbody tr:hover {
            background: var(--bg-secondary);
        }

        .terminal-log {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: var(--space-lg);
            max-height: 300px;
            overflow-y: auto;
            font-size: var(--text-caption-size);
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: var(--space-xs);
        }

        /* Agent Status Styling */
        #agentStatusFeed .log-entry {
            color: var(--color-text-secondary);
        }

        /* Buy/Sell Signal Styling - White (no glow) */
        .agent-buy-signal, .agent-sell-signal {
            color: var(--color-background) !important;
        }

        /* Agent Response Styling - White */
        .agent-response {
            color: var(--color-background) !important;
        }

        /* Actual Trade Executions - Green for buys, Red for sells */
        .agent-trade-buy {
            color: var(--color-success) !important;
        }

        .agent-trade-sell {
            color: var(--color-error) !important;
        }

        /* Command Suggestions Tooltip */
        .command-suggestions {
            position: absolute;
            top: -250px;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
            font-size: var(--text-caption-size);
            z-index: 1000;
            max-height: 240px;
            overflow-y: auto;
        }

        .command-suggestion {
            padding: var(--space-xs) var(--space-sm);
            margin: var(--space-xs) 0;
            cursor: pointer;
            border-radius: 0px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .command-suggestion:hover {
            background: var(--border-color);
        }

        .cmd-name {
            font-weight: 700;
            color: var(--text-primary);
            font-family: var(--font-family-monospace);
        }

        .cmd-desc {
            color: var(--text-secondary);
            font-style: italic;
            font-size: var(--text-caption-size);
            margin-left: var(--space-sm);
        }

        .log-timestamp {
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
        }

        .input-terminal {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: var(--space-sm);
            font-family: inherit;
            font-size: var(--text-caption-size);
            width: 100%;
        }

        .input-terminal:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        .tab-container {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: var(--space-xs);
        }

        .tab-button {
            padding: var(--space-sm) var(--space-lg);
            background-color: var(--color-background);
            color: var(--color-primary);
            border: 1px solid var(--color-border);
            border-bottom: none;
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: var(--space-xs);
        }

        .tab-button.active, .tab-button:hover {
            background-color: var(--color-primary);
            color: var(--color-background);
            border-color: var(--color-primary);
        }

        .tab-content {
            display: none;
            margin-top: 0;
            padding-top: 0;
        }

        .tab-content.active {
            display: block;
            margin-top: 0;
            padding-top: 0;
        }

        .tab-content > *:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        /* ===== REFINED TAB SPACING SYSTEM ===== */
        /* Proper tab spacing that maintains visual hierarchy */
        .tab-container {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: var(--space-md);
        }

        .tab-content {
            display: none;
            padding-top: var(--space-md);
        }

        .tab-content.active {
            display: block;
        }

        /* Maintain consistent spacing for first elements in tabs */
        .tab-content > .terminal-section:first-child {
            margin-top: 0;
        }

        .tab-content > .analysis-card:first-child {
            margin-top: 0;
        }

        .ascii-art {
            font-size: var(--text-caption-size);
            line-height: 1;
            color: var(--text-secondary);
            white-space: pre;
            text-align: center;
            margin: var(--space-lg) 0;
        }

        .section-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
            padding: 0 5px;
        }

        /* Button size variant - already defined above in new system */

        .terminal-progress {
            width: 100%;
            height: 20px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            margin: var(--space-sm) 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--text-primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .prices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-sm);
            margin: var(--space-md) 0;
        }

        .price-item {
            border: 1px solid var(--border-color);
            padding: var(--space-sm);
            background: var(--bg-primary);
            opacity: 0;
            animation: fadeInWaterfall 0.15s ease-in forwards;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .price-item:hover {
            background: var(--bg-secondary);
        }

        @keyframes fadeInWaterfall {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ASCII Skeleton loader styles */
        .skeleton-loader {
            background: var(--bg-primary) !important;
            border: 1px solid var(--border-color);
            opacity: 0.8 !important;
            cursor: default !important;
        }

        .skeleton-text {
            font-family: var(--font-family-monospace);
            color: var(--text-secondary) !important;
            font-weight: normal !important;
            letter-spacing: 1px;
            animation: asciiSkeletonWave 2s infinite;
        }

        @keyframes asciiSkeletonWave {
            0% { opacity: 0.3; }
            25% { opacity: 0.6; }
            50% { opacity: 0.9; }
            75% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }

        .loading-complete {
            transform: scale(1.02);
            transition: all 0.2s ease-in-out;
        }

        .loading-complete .skeleton-text {
            animation: none !important;
            color: inherit !important;
        }

        @keyframes dataLoaded {
            from {
                transform: scale(0.95);
                opacity: 0.5;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Trending loading state */
        .trending-loading-state {
            background: var(--bg-primary) !important;
            border: 1px solid var(--border-color);
            border-radius: 0;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .ascii-chart-loader {
            font-family: var(--font-family-monospace);
            font-size: calc(var(--text-body-size) * 0.8);
            color: #FFFFFF !important;
            letter-spacing: 2px;
            margin-bottom: var(--space-sm);
        }

        .chart-line {
            color: #FFFFFF !important;
            transition: all 0.3s ease-in-out;
            animation: pulse 1.2s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3) !important;
        }

        /* Ultra-high specificity override */
        #ascii-trending-chart .chart-line {
            color: #FFFFFF !important;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3) !important;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Ensure populated cards are visible */
        .price-item:not(.skeleton-loader) {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .price-symbol {
            font-weight: 700;
            font-size: var(--text-caption-size);
            margin-bottom: var(--space-xs);
        }

        .price-value {
            font-size: var(--text-body-size);
            font-weight: 400;
            margin-bottom: var(--space-xs);
        }

        .price-change {
            font-size: var(--text-caption-size);
            display: inline-block;
        }

        .price-mcap {
            font-size: var(--text-caption-size);
            color: var(--color-text-secondary);
            display: inline-block;
            margin-left: var(--space-sm);
        }

        .price-change-row {
            display: flex;
            align-items: center;
        }

        .category-section {
            margin-bottom: var(--space-2xl);
        }

        .category-title {
            font-size: var(--text-caption-size);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--space-xs);
            margin-bottom: var(--space-md);
        }

        /* Stock Detail Page Styles */
        .stock-detail-page {
            display: none;
            padding: var(--space-lg);
        }

        .stock-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            flex-wrap: wrap;
        }

        .stock-info {
            flex: 1;
        }

        .stock-name {
            font-size: var(--text-h2-size);
            font-weight: var(--text-h2-weight);
            line-height: var(--text-h2-height);
            text-transform: uppercase;
            margin-bottom: var(--space-xs);
            color: var(--text-primary);
        }

        .stock-symbol {
            font-size: var(--text-body-size);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }

        .stock-price {
            font-size: var(--text-h1-size);
            font-weight: var(--text-h1-weight);
            line-height: var(--text-h1-height);
            margin-bottom: var(--space-xs);
            color: var(--text-primary);
        }

        .stock-change {
            font-size: var(--text-body-size);
            font-weight: var(--text-body-weight);
            line-height: var(--text-body-height);
            color: var(--text-primary);
        }

        .stock-actions {
            display: flex;
            gap: var(--space-sm);
            align-items: center;
            flex-wrap: wrap;
        }

        /* Trading action buttons - using semantic colors */
        .btn-buy {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-success);
            border: 1px solid var(--color-success);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-buy:hover {
            background-color: var(--color-success);
            color: var(--color-background);
        }

        .btn-sell {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-error);
            border: 1px solid var(--color-error);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-sell:hover {
            background-color: var(--color-error);
            color: var(--color-background);
        }

        .btn-back {
            padding: var(--space-sm) var(--space-md);
            background-color: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
            border-radius: 0px;
            font-size: var(--text-label-size);
            font-weight: var(--text-label-weight);
            cursor: pointer;
            transition: all 0.2s ease;
            margin: var(--space-xs);
        }

        .btn-back:hover {
            background-color: var(--color-primary);
            color: var(--color-background);
        }

        .stock-detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .stock-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: var(--space-lg);
        }

        .stock-section-title {
            font-size: var(--text-h3-size);
            font-weight: var(--text-h3-weight);
            line-height: var(--text-h3-height);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
            padding-bottom: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .stock-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: 700;
            font-size: var(--text-caption-size);
        }

        .analyst-ratings {
            display: flex;
            gap: var(--space-lg);
            margin: var(--space-md) 0;
        }

        .rating-item {
            text-align: center;
            flex: 1;
        }

        .rating-label {
            font-size: var(--text-caption-size);
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
        }

        .rating-value {
            font-size: var(--text-body-size);
            font-weight: 700;
        }

        .rating-buy { color: var(--positive); }
        .rating-hold { color: var(--color-text-secondary); }
        .rating-sell { color: var(--negative); }

        .earnings-chart {
            height: 180px;
            margin: var(--space-md) 0;
            position: relative;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
        }

        .earnings-list, .history-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .earnings-item, .history-item {
            display: flex;
            justify-content: space-between;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--text-caption-size);
        }

        .company-details {
            margin: var(--space-md) 0;
        }

        .company-detail-item {
            display: flex;
            justify-content: space-between;
            padding: var(--space-xs) 0;
            font-size: var(--text-caption-size);
            border-bottom: 1px solid var(--border-color);
        }

        .company-detail-label {
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .company-detail-value {
            font-weight: 700;
        }

        .company-url {
            color: var(--positive);
            text-decoration: none;
        }

        .company-url:hover {
            text-decoration: underline;
        }

        .analyst-synopsis {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            font-size: var(--text-caption-size);
            line-height: 1.6;
        }

        .analyst-synopsis-title {
            font-size: var(--text-caption-size);
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }

        .stocktwits-section {
            max-height: 300px;
            overflow-y: auto;
        }

        .sentiment-indicators {
            display: flex;
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
            text-align: center;
        }

        .sentiment-item {
            flex: 1;
        }

        .sentiment-label {
            font-size: var(--text-caption-size);
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
        }

        .sentiment-value {
            font-size: var(--text-body-size);
            font-weight: 700;
        }

        .sentiment-bullish { color: var(--positive); }
        .sentiment-bearish { color: var(--negative); }

        .community-links {
            margin: var(--space-md) 0;
            text-align: center;
        }

        .community-link {
            display: inline-block;
            padding: var(--space-sm) var(--space-md);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            text-decoration: none;
            border: 1px solid var(--border-color);
            border-radius: 0px;
            font-size: var(--text-caption-size);
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .community-link:hover {
            background-color: var(--border-color);
            transform: translateY(-1px);
        }

        .stocktwits-link {
            background-color: var(--color-success);
            color: white;
            border-color: var(--color-success);
        }

        .stocktwits-link:hover {
            background-color: var(--color-success);
            border-color: var(--color-success);
        }

        .stocktwits-post {
            border-bottom: 1px solid var(--border-color);
            padding: var(--space-md) 0;
            font-size: var(--text-caption-size);
        }

        .stocktwits-error {
            padding: var(--space-lg);
            text-align: center;
            border: 1px solid var(--border-color);
            border-radius: 0px;
            background-color: var(--bg-secondary);
        }

        .error-message {
            font-size: var(--text-caption-size);
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }

        .error-details {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .post-user {
            font-weight: 700;
            color: var(--text-primary);
        }

        .post-time {
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
        }

        .post-sentiment {
            font-size: var(--text-caption-size);
            font-weight: 700;
            padding: var(--space-xs) var(--space-xs);
            border-radius: 0px;
        }

        .post-sentiment.bullish {
            background: var(--positive);
            color: var(--bg-primary);
        }

        .post-sentiment.bearish {
            background: var(--negative);
            color: var(--bg-primary);
        }

        .post-content {
            line-height: 1.4;
            margin-bottom: var(--space-sm);
        }

        .post-stats {
            display: flex;
            gap: var(--space-md);
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
        }

        .loading-spinner {
            text-align: center;
            padding: var(--space-lg);
            color: var(--text-secondary);
        }

        .stock-description {
            line-height: 1.6;
            font-size: var(--text-caption-size);
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .stock-detail-grid {
                grid-template-columns: 1fr;
            }

            .stock-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-md);
            }

            .stock-stats-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .terminal-container {
                padding: var(--space-sm);
            }

            .metric-grid {
                grid-template-columns: 1fr;
            }

            .terminal-title {
                font-size: var(--text-body-size);
            }

            .theme-toggle-container {
                position: static;
                display: flex;
                justify-content: center;
                margin: var(--space-sm) auto var(--space-lg) auto;
            }

            .terminal-header {
                padding-bottom: var(--space-sm);
            }
        }

        /* Delete button styling */
        .delete-btn {
            color: var(--color-text-secondary);
            cursor: pointer;
            font-size: var(--text-caption-size);
            padding: var(--space-xs) var(--space-xs);
            border-radius: 0px;
            transition: color 0.2s ease;
        }

        .delete-btn:hover {
            color: var(--color-error);
        }

        .delete-cell {
            text-align: center;
            width: 60px;
        }

        /* Strategy Preparation Styles */
        .strategy-prep-status {
            padding: var(--space-sm);
            border-radius: 0px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        .status-indicator {
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
            color: var(--accent);
        }

        .prep-row {
            display: flex;
            gap: var(--space-lg);
            margin-bottom: var(--space-md);
        }

        .prep-section {
            flex: 1;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
        }

        /* Responsive layout for prep rows */
        @media (max-width: 768px) {
            .prep-row {
                flex-direction: column;
            }
        }

        .prep-header {
            font-weight: bold;
            margin-bottom: var(--space-sm);
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--space-xs);
        }

        .watchlist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-sm);
        }

        .watchlist-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
        }

        .watchlist-symbol {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: var(--space-xs);
        }

        .watchlist-strategy {
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
        }

        .watchlist-score {
            color: var(--accent);
            font-size: var(--text-caption-size);
            margin-top: var(--space-xs);
        }

        .sector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: var(--space-xs);
        }

        .sector-item {
            display: flex;
            justify-content: space-between;
            padding: var(--space-xs) var(--space-xs);
            background: var(--bg-primary);
            border-radius: 0px;
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
        }

        .sector-bullish {
            border-left: var(--space-xs) solid var(--color-success);
        }

        .sector-bearish {
            border-left: var(--space-xs) solid var(--color-error);
        }

        .sector-neutral {
            border-left: var(--space-xs) solid var(--color-text-secondary);
        }

        .regime-display {
            text-align: center;
            padding: var(--space-md);
            background: var(--bg-primary);
            border-radius: 0px;
            font-family: var(--font-family-monospace);
        }

        .regime-trending {
            color: var(--color-success);
            border: 1px solid rgba(0, 255, 136, 0.25);
        }

        .regime-ranging {
            color: var(--color-warning);
            border: 1px solid rgba(255, 170, 0, 0.25);
        }

        .regime-volatile {
            color: var(--color-error);
            border: 1px solid rgba(255, 68, 68, 0.25);
        }

        .options-grid {
            display: grid;
            gap: var(--space-sm);
        }

        .option-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
            font-family: var(--font-family-monospace);
            font-size: var(--text-caption-size);
        }

        .option-symbol {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: var(--space-xs);
        }

        .option-strategy {
            color: var(--accent);
            font-size: var(--text-caption-size);
        }

        .option-probability {
            color: var(--text-secondary);
            font-size: var(--text-caption-size);
        }

        /* Stock Position Cards */
        .equity-positions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-sm);
            margin-top: var(--space-md);
            width: 100%;
        }

        .equityAnalysisContent {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-sm);
            width: 100%;
        }

        .stock-position-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0px;
            padding: var(--space-sm);
            transition: all 0.2s ease;
            min-width: 280px;
            max-width: 320px;
        }

        .stock-position-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.1);
        }

        .stock-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--border-color);
        }

        .stock-symbol {
            font-size: var(--text-body-size);
            font-weight: bold;
            color: var(--text-primary);
        }

        .stock-trend {
            font-size: var(--text-caption-size);
            font-weight: bold;
            padding: var(--space-xs) var(--space-sm);
            border-radius: 0px;
        }

        .stock-trend.bullish {
            color: var(--color-success);
            background-color: rgba(0, 255, 136, 0.1);
        }

        .stock-trend.bearish {
            color: var(--color-error);
            background-color: rgba(255, 68, 68, 0.1);
        }

        .stock-metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
        }

        .stock-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) 0;
        }

        .stock-metric .metric-label {
            font-size: var(--text-caption-size);
            color: var(--text-secondary);
        }

        .stock-metric .metric-value {
            font-size: var(--text-caption-size);
            font-weight: 500;
            color: var(--text-primary);
        }

        .stock-metric .metric-value.positive {
            color: var(--color-success);
        }

        .stock-metric .metric-value.negative {
            color: var(--color-error);
        }
    </style>
</head>
<body data-theme="dark">
    <div class="terminal-container">
        <div class="theme-toggle-container" data-theme="dark">
            <svg class="theme-icon sun-icon" fill="var(--color-background)" viewBox="0 0 24 24">
                <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/>
            </svg>
            <button class="theme-toggle" onclick="toggleTheme()" data-theme="dark">
                <div class="theme-toggle-slider"></div>
            </button>
            <svg class="theme-icon moon-icon" fill="var(--color-background)" viewBox="0 0 24 24">
                <path d="M9.37 5.51c-.18.64-.27 1.31-.27 1.99 0 4.08 3.32 7.4 7.4 7.4.68 0 1.35-.09 1.99-.27C17.45 17.19 14.93 19 12 19c-3.86 0-7-3.14-7-7 0-2.93 1.81-5.45 4.37-6.49zM12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>
            </svg>
        </div>

        <div class="terminal-header">
            <div class="donut-container">
                <pre id="donutAnimation" class="donut-display"></pre>
            </div>
        </div>

        <div class="market-movers-marquee">
            <div class="marquee-content" id="moversMarquee">
                <span class="mover-item">
                    <span class="mover-symbol">Loading market movers...</span>
                </span>
            </div>
        </div>


        <div class="tab-container">
            <button class="tab-button active" onclick="switchTab('dashboard')">DASHBOARD</button>
            <button class="tab-button" onclick="switchTab('portfolio')">PORTFOLIO</button>
            <button class="tab-button" onclick="switchTab('options')">OPTIONS</button>
            <button class="tab-button" onclick="switchTab('analysis')">ANALYSIS</button>
            <button class="tab-button" onclick="switchTab('alerts')">ALERTS</button>
        </div>

        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard-tab">

            <!-- Enhanced shadcn-style Chart Card -->
            <div class="chart-card">
                <div class="chart-card-header">
                    <div class="chart-card-title">
                        <h3 id="portfolioChartTitle"> Invested Capital</h3>
                        <p class="chart-card-description">Real-time trading portfolio performance</p>
                    </div>
                    <div class="chart-filters">
                        <button class="chart-filter active" data-period="1h">1H</button>
                        <button class="chart-filter" data-period="1d">1D</button>
                        <button class="chart-filter" data-period="1w">1W</button>
                        <button class="chart-filter" data-period="1m">1M</button>
                        <button class="chart-filter" data-period="1y">1Y</button>
                        <button class="chart-refresh-btn" id="chartRefreshBtn" title="Refresh chart data">
                            <span class="refresh-icon"></span>
                            <span class="refresh-text">REFRESH</span>
                        </button>
                    </div>
                </div>
                <div class="chart-card-content">
                    <div class="chart-container-enhanced">
                        <div id="chartdiv"></div>
                    </div>
                </div>
                <div class="chart-card-footer">
                    <div class="chart-trend-indicator" style="color: var(--color-error);">
                        <svg class="trend-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 5v14M19 12l-7 7-7-7"/>
                        </svg>
                        <span id="chartTrendText" style="color: var(--color-error);">Trending down by 0.82% this hour</span>
                    </div>
                    <div class="chart-time-range" id="chartTimeRange">
                        Last updated: <span id="chartLastUpdate">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- ASCII Animation Break -->
            <pre class="ascii-break" data-pattern="spiral"></pre>

            <div class="terminal-section">
                <h2 class="section-title">[*] Autonomous Agent</h2>
                <div>
                    <button class="btn-terminal" id="startAutonomousBtn">START AGENT</button>
                    <button class="btn-terminal" id="stopAutonomousBtn">STOP AGENT</button>
                    <button class="btn-terminal" id="reconnectStatusBtn">RECONNECT</button>
                    <button class="btn-emergency" id="emergencySellBtn">EMERGENCY SELL</button>

                    <div class="terminal-log" id="agentStatusFeed" style="margin-top: var(--space-sm);">
                        <div class="log-entry">Status: <span class="status-indicator" id="autonomousStatusText">UNKNOWN</span></div>
                        <div class="log-entry">Agent idle - waiting for start command...</div>
                    </div>

                    <small style="color: var(--color-text-secondary); font-size: var(--text-caption-size); padding-top: var(--space-sm); display: block;">
                        Emergency Sell: Immediately liquidates all positions and stops autonomous trading
                    </small>

                    <!-- Agent Command Interface -->
                    <div class="agent-command-interface" style="margin-top: var(--space-md); border-top: 1px solid var(--border-color); padding-top: var(--space-md); position: relative;">
                        <div style="display: flex; align-items: center;">
                            <input type="text" id="agentCommandInput" class="input-terminal"
                                   placeholder="Type commands or / for help: research NVDA, buy 100 AAPL, /trending..."
                                   style="flex: 1; font-size: var(--text-caption-size); padding: var(--space-sm);"
                                   autocomplete="off">
                            <button id="agentCommandSend" class="btn-terminal btn-small btn-inline">SEND</button>
                        </div>

                        <!-- Command Suggestions Tooltip -->
                        <div id="commandSuggestions" class="command-suggestions" style="display: none;">
                            <div class="command-suggestion" data-command="/research [symbol]">
                                <span class="cmd-name">/research [symbol]</span>
                                <span class="cmd-desc">Analyze stock with technical indicators</span>
                            </div>
                            <div class="command-suggestion" data-command="/buy [qty] [symbol]">
                                <span class="cmd-name">/buy [qty] [symbol]</span>
                                <span class="cmd-desc">Generate buy signal for stock</span>
                            </div>
                            <div class="command-suggestion" data-command="/sell [symbol]">
                                <span class="cmd-name">/sell [symbol]</span>
                                <span class="cmd-desc">Evaluate sell opportunity</span>
                            </div>
                            <div class="command-suggestion" data-command="/trending">
                                <span class="cmd-name">/trending</span>
                                <span class="cmd-desc">Show market trending stocks</span>
                            </div>
                            <div class="command-suggestion" data-command="/status">
                                <span class="cmd-name">/status</span>
                                <span class="cmd-desc">Show portfolio summary</span>
                            </div>
                            <div class="command-suggestion" data-command="/help">
                                <span class="cmd-name">/help</span>
                                <span class="cmd-desc">Show all available commands</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="agentDebugLog" style="display: none;">
                    <h2 class="section-title" style="margin-top: var(--space-lg);">DEBUG LOG</h2>
                    <div class="terminal-log" id="agentDebugContent"></div>
                </div>
            </div>

            <div class="metric-grid">
                <div class="metric-item">
                    <div class="metric-value" id="dailyPnL">$0.00</div>
                    <div class="metric-label">DAILY P&L</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value" id="pendingProposals">0</div>
                    <div class="metric-label">PROPOSALS</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value" id="autonomousDecisions">0</div>
                    <div class="metric-label">DECISIONS</div>
                </div>
            </div>

            <div class="terminal-section">
                <h2 class="section-title">Real-Time Market Prices</h2>
                <div class="section-header-controls">
                    <span id="pricesLastUpdated" class="log-timestamp">Never updated</span>
                    <button class="btn-terminal btn-small" id="refreshPricesBtn">REFRESH</button>
                </div>

                <div id="pricesInitialLoader" style="display: none;">
                    <div class="log-entry">Loading market data...</div>
                    <div class="terminal-progress">
                        <div class="progress-bar" id="pricesProgressBar"></div>
                    </div>
                </div>

                <div id="realTimePricesGrid">
                    <div class="log-entry" style="font-size: var(--text-caption-size);">Click REFRESH to load market data</div>
                </div>
            </div>

            <div class="terminal-section">
                <h2 class="section-title">Real-Time Updates</h2>
                <div class="terminal-log" id="realTimeUpdates">
                    <div class="log-entry">System ready for initialization...</div>
                </div>
            </div>
        </div>

        <!-- Portfolio Tab -->
        <div class="tab-content" id="portfolio-tab">
            <div class="terminal-section">
                <h2 class="section-title">Portfolio Holdings</h2>
                <table class="terminal-table" id="portfolioTable">
                    <thead>
                        <tr>
                            <th>SYMBOL</th>
                            <th>SHARES</th>
                            <th>PRICE</th>
                            <th>VALUE</th>
                            <th>P&L</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td colspan="5">No holdings</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Live Buy Signals Section -->
            <div class="terminal-section">
                <h2 class="section-title"> Live Buy Signals <span class="text-dim" style="font-size: var(--text-caption-size);">- Real-time trading decisions from agents</span>
                    <button onclick="refreshLiveSignals()" class="btn-terminal btn-refresh"> REFRESH</button>
                </div>
                <table class="terminal-table" id="liveSignalsTable">
                    <thead>
                        <tr>
                            <th>TIME</th>
                            <th>SYMBOL</th>
                            <th>ACTION</th>
                            <th>PRICE</th>
                            <th>CONFIDENCE</th>
                            <th>ANALYSIS</th>
                            <th>STATUS</th>
                        </tr>
                    </thead>
                    <tbody id="liveSignalsTableBody">
                        <tr><td colspan="7" class="text-dim">Loading live signals...</td></tr>
                    </tbody>
                </table>
            </div>

        </div>

        <!-- Options Tab -->
        <div class="tab-content" id="options-tab">
            <div class="terminal-section">
                <h2 class="section-title"> Options Positions
                    <button onclick="refreshOptionsData()" class="btn-terminal btn-refresh"> REFRESH</button>
                </h2>
                <div class="section-subtitle">Positions managed by Delta, Gamma, and Theta agents</div>
                <table class="terminal-table" id="optionsPositionsTable">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Type</th>
                            <th>Strike</th>
                            <th>Expiration</th>
                            <th>Qty</th>
                            <th>Cost</th>
                            <th>Current</th>
                            <th>P&L</th>
                            <th>Greeks</th>
                        </tr>
                    </thead>
                    <tbody id="optionsPositionsBody">
                        <tr><td colspan="9">No options positions</td></tr>
                    </tbody>
                </table>
            </div>


            <div class="terminal-section">
                <h2 class="section-title"> Options Chain Explorer</h2>
                <div class="controls">
                    <input type="text" id="optionsSymbolInput" placeholder="Enter symbol (e.g., AAPL)"
                           class="input-base" style="margin-right: var(--space-sm);">
                    <button onclick="loadOptionsChain()"
                            class="btn-strategy">
                        Load Chain
                    </button>
                </div>
                <div id="optionsChainContainer" class="m-md">
                    <div>Enter a symbol to view options chain</div>
                </div>
            </div>


            <div class="terminal-section">
                <h2 class="section-title"> Options Trading Strategies</h2>
                <div class="grid-container">
                    <div class="strategy-card" onclick="showStrategyForm('LONG_CALL')">
                        <div class="strategy-name">Long Call</div>
                        <div class="strategy-desc">Bullish directional</div>
                    </div>
                    <div class="strategy-card" onclick="showStrategyForm('LONG_PUT')">
                        <div class="strategy-name">Long Put</div>
                        <div class="strategy-desc">Bearish directional</div>
                    </div>
                    <div class="strategy-card" onclick="showStrategyForm('BULL_CALL_SPREAD')">
                        <div class="strategy-name">Bull Call Spread</div>
                        <div class="strategy-desc">Limited risk bullish</div>
                    </div>
                    <div class="strategy-card" onclick="showStrategyForm('IRON_CONDOR')">
                        <div class="strategy-name">Iron Condor</div>
                        <div class="strategy-desc">Neutral income</div>
                    </div>
                </div>
                <div id="strategyFormContainer" class="m-lg" style="display: none;">
                    <!-- Strategy form will be populated dynamically -->
                </div>
            </div>

            <div class="terminal-section">
                <h2 class="section-title"> IV Rank & Volatility</h2>
                <div id="volatilityMetrics" style="font-size: var(--text-caption-size);">
                    Select a symbol to view volatility metrics
                </div>
            </div>
        </div>

        <!-- Analysis Tab -->
        <div class="tab-content" id="analysis-tab">
            <!-- Dough Report - Morning Analysis Report -->
            <div id="doughReportContainer" class="analysis-card analysis-card-full m-lg" style="display: none;">
                <div class="analysis-card-header">
                    <div class="analysis-card-title">
                        <h3> <span id="doughReportTitle">Dough Report</span></h3>
                        <p class="analysis-card-description">Daily morning analysis and trading strategy overview</p>
                    </div>
                    <div id="doughReportTimestamp" class="status-indicator"></div>
                </div>
                <div class="analysis-card-content">
                    <div id="doughReportContent" class="dough-report-content">
                        <!-- Report content will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Portfolio Summary - Full Width with side-by-side layout -->
            <div class="analysis-card analysis-card-full">
                <div class="analysis-card-header">
                    <div class="analysis-card-title">
                        <h3> Portfolio Summary</h3>
                        <p class="analysis-card-description">Real-time portfolio allocation and performance insights</p>
                    </div>
                </div>
                <div class="analysis-card-content">
                    <div class="portfolio-summary-grid">
                        <div class="portfolio-allocation">
                            <h4>Portfolio Allocation</h4>
                            <div id="portfolioAllocationContainer" class="analysis-content">
                                <div class="text-dim">Loading allocation data...</div>
                            </div>
                        </div>
                        <div class="portfolio-insights">
                            <h4>Key Insights</h4>
                            <div id="portfolioInsightsContainer" class="analysis-content">
                                <div class="text-dim">Loading insights...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Equity Positions - Individual Cards -->
            <div class="analysis-section equity-positions-section">
                <div class="section-title-header">
                    <h3> Equity Positions</h3>
                    <p class="section-description">Active stock holdings analysis</p>
                </div>
                <div id="equityAnalysisContainer" class="equity-positions-grid equityAnalysisContent analysis-content">
                    <div class="text-dim">Waiting for agent analysis...</div>
                </div>
            </div>

            <!-- Options Positions - Full Width -->
            <div class="analysis-card analysis-card-full">
                <div class="analysis-card-header">
                    <div class="analysis-card-title">
                        <h3> Options Positions</h3>
                        <p class="analysis-card-description">Options strategies and performance</p>
                    </div>
                </div>
                <div class="analysis-card-content">
                    <div id="optionsAnalysisContainer" class="analysis-content">
                        <div class="text-dim">Waiting for agent analysis...</div>
                    </div>
                </div>
            </div>

            <!-- Market Conditions - Individual Sector Cards -->
            <div class="analysis-section market-conditions-section">
                <div class="section-title-header">
                    <h3> Market Conditions & Sector Analysis</h3>
                    <p class="section-description">Real-time market regime and sector performance</p>
                </div>
                <div class="market-conditions-grid">
                    <div id="marketOutlookContainer" class="analysis-content">
                        <div class="text-dim">Loading market analysis...</div>
                    </div>
                </div>
            </div>

            <!-- Strategy Analysis - Full Width -->
            <div class="analysis-card analysis-card-full">
                <div class="analysis-card-header">
                    <div class="analysis-card-title">
                        <h3> Strategy Analysis</h3>
                        <p class="analysis-card-description">Next-day strategy preparation and trading opportunities</p>
                    </div>
                </div>
                <div class="analysis-card-content">
                    <div class="strategy-prep-status" id="strategyPrepStatus">
                        <div class="status-indicator"> Loading strategy...</div>
                    </div>
                    <div class="strategy-prep-content" id="strategyPrepContent" style="margin-top: var(--space-md); display: none;">
                        <div class="prep-row">
                            <div class="prep-section">
                                <div class="prep-header"> Sector Outlook</div>
                                <div id="sectorOutlook" class="sector-grid"></div>
                            </div>
                            <div class="prep-section">
                                <div class="prep-header"> Market Regime</div>
                                <div id="marketRegime" class="regime-display"></div>
                            </div>
                            <div class="prep-section">
                                <div class="prep-header"> Options Opportunities</div>
                                <div id="optionsOpportunities" class="options-grid"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="analysis-footer">
                Last updated: <span id="analysisLastUpdate">Never</span>
            </div>
        </div>

        <!-- Alerts Tab -->
        <div class="tab-content" id="alerts-tab">
            <div class="terminal-section">
                <h2 class="section-title">Active Alerts</h2>
                <table class="terminal-table" id="alertsTable">
                    <thead>
                        <tr>
                            <th>SYMBOL</th>
                            <th>TYPE</th>
                            <th>CONDITION</th>
                            <th>STATUS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td colspan="4">No active alerts</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="terminal-section">
                <h2 class="section-title">Compliance Report</h2>
                <div id="compliance-container">
                    <div class="log-entry">Compliance check passed</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Stock Detail Page -->
    <div class="terminal-container stock-detail-page" id="stockDetailPage">
        <div class="stock-header">
            <div class="stock-info">
                <div class="stock-name" id="stockName">Apple Inc.</div>
                <div class="stock-symbol" id="stockSymbol">AAPL</div>
                <div class="stock-price" id="stockPrice">$175.50</div>
                <div class="stock-change positive" id="stockChange">+2.34%</div>
            </div>
            <div class="stock-actions">
                <button class="btn-terminal btn-back" id="backBtn"> BACK</button>
                <button class="btn-terminal btn-buy" id="buyBtn">BUY</button>
                <button class="btn-terminal btn-sell" id="sellBtn">SELL</button>
            </div>
        </div>

        <!-- Stock Chart Section -->
        <div class="chart-section">
            <div class="chart-header">
                <div class="chart-title"> <span id="stockChartTitle">AAPL</span> Performance</div>
                <div class="chart-filters">
                    <button class="chart-filter active" data-period="1h">1H</button>
                    <button class="chart-filter" data-period="1d">1D</button>
                    <button class="chart-filter" data-period="1w">1W</button>
                    <button class="chart-filter" data-period="1m">1M</button>
                    <button class="chart-filter" data-period="1y">1Y</button>
                </div>
            </div>
            <div class="chart-container">
                <canvas class="chart-canvas" id="stockChart"></canvas>
                <div class="chart-tooltip" id="stockChartTooltip"></div>
            </div>
        </div>

        <!-- Stock Detail Sections Grid -->
        <div class="stock-detail-grid">
            <!-- Stock Statistics -->
            <div class="stock-section">
                <div class="stock-section-title"> Stock Statistics</div>
                <div class="stock-stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">Volume</span>
                        <span class="stat-value" id="statVolume">45.2M</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg Volume</span>
                        <span class="stat-value" id="statAvgVolume">52.1M</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Open</span>
                        <span class="stat-value" id="statOpen">$173.25</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">High</span>
                        <span class="stat-value" id="statHigh">$176.80</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Low</span>
                        <span class="stat-value" id="statLow">$172.90</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Market Cap</span>
                        <span class="stat-value" id="statMarketCap">$2.8T</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">52W High</span>
                        <span class="stat-value" id="stat52High">$199.62</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">52W Low</span>
                        <span class="stat-value" id="stat52Low">$164.08</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">P/E Ratio</span>
                        <span class="stat-value" id="statPE">28.5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Dividend Yield</span>
                        <span class="stat-value" id="statDividend">0.52%</span>
                    </div>
                </div>
            </div>

            <!-- Analyst Ratings -->
            <div class="stock-section">
                <div class="stock-section-title"> Analyst Ratings</div>
                <div class="analyst-ratings">
                    <div class="rating-item">
                        <div class="rating-label">Buy</div>
                        <div class="rating-value rating-buy" id="ratingBuy">65%</div>
                    </div>
                    <div class="rating-item">
                        <div class="rating-label">Hold</div>
                        <div class="rating-value rating-hold" id="ratingHold">25%</div>
                    </div>
                    <div class="rating-item">
                        <div class="rating-label">Sell</div>
                        <div class="rating-value rating-sell" id="ratingSell">10%</div>
                    </div>
                </div>
                <div class="analyst-synopsis" id="analystSynopsis">
                    <div class="analyst-synopsis-title">Analyst Synopsis</div>
                    <div id="analystReview">Strong buy recommendation driven by robust iPhone sales and services growth. Analysts remain bullish on AI integration and wearables expansion.</div>
                </div>
            </div>

            <!-- Company Description -->
            <div class="stock-section">
                <div class="stock-section-title"> Company Overview</div>
                <div class="stock-description" id="stockDescription">
                    Apple Inc. designs, manufactures, and markets smartphones, personal computers, tablets, wearables, and accessories worldwide. The company serves consumers, and small and mid-sized businesses; and the education, enterprise, and government markets.
                </div>
                <div class="company-details">
                    <div class="company-detail-item">
                        <span class="company-detail-label">Website</span>
                        <a href="#" class="company-detail-value company-url" id="companyUrl" target="_blank">www.apple.com</a>
                    </div>
                    <div class="company-detail-item">
                        <span class="company-detail-label">Employees</span>
                        <span class="company-detail-value" id="companyEmployees">164,000</span>
                    </div>
                    <div class="company-detail-item">
                        <span class="company-detail-label">Founded</span>
                        <span class="company-detail-value" id="companyFounded">1976</span>
                    </div>
                </div>
            </div>

            <!-- Quarterly Earnings -->
            <div class="stock-section">
                <div class="stock-section-title"> Quarterly Earnings</div>
                <div class="earnings-chart">
                    <canvas id="earningsChart" width="100%" height="180"></canvas>
                </div>
            </div>

            <!-- Trading History -->
            <div class="stock-section">
                <div class="stock-section-title"> My Trading History</div>
                <div class="history-list" id="tradingHistory">
                    <div class="history-item">
                        <span>12/01/2024 BUY</span>
                        <span>50 @ $170.25</span>
                    </div>
                    <div class="history-item">
                        <span>11/15/2024 SELL</span>
                        <span>25 @ $185.50</span>
                    </div>
                    <div class="history-item">
                        <span>10/20/2024 BUY</span>
                        <span>75 @ $165.75</span>
                    </div>
                </div>
            </div>

            <!-- StockTwits Community -->
            <div class="stock-section">
                <div class="stock-section-title"> Community Sentiment</div>
                <div class="sentiment-indicators" id="sentimentIndicators">
                    <div class="sentiment-item">
                        <div class="sentiment-label">Bullish</div>
                        <div class="sentiment-value sentiment-bullish" id="bullishPercent">--</div>
                    </div>
                    <div class="sentiment-item">
                        <div class="sentiment-label">Bearish</div>
                        <div class="sentiment-value sentiment-bearish" id="bearishPercent">--</div>
                    </div>
                    <div class="sentiment-item">
                        <div class="sentiment-label">Total Posts</div>
                        <div class="sentiment-value" id="totalPosts">--</div>
                    </div>
                </div>
                <div class="community-links">
                    <a href="#" id="stocktwitsLink" class="community-link stocktwits-link" target="_blank" rel="noopener noreferrer">
                         View on StockTwits
                    </a>
                </div>
                <div class="stocktwits-section" id="stocktwitsContainer">
                    <div class="loading-spinner">Loading community data...</div>
                </div>
            </div>

            <!-- Recent News -->
            <div class="stock-section">
                <div class="stock-section-title"> Recent News</div>
                <div class="stocktwits-section" id="newsContainer">
                    <div class="loading-spinner">Loading news...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* Global Configuration */
        const CONFIG = {
          noiseScale: 0.004,
          charSize: 10,
          edgeDistance: 100,
          brightnessThreshold: 0.05, // Skip nearly invisible characters
          octaveNum: 4,
          freqMultiplier: 2.2,
          ampMultiplier: 0.45,
          frameRateVal: 60,
          asciiChars: [" ", ".", ":", "-", "~", "+", "=", "^", "*", "#", "@", ""]
        };

        // ============================================================================
        // GLOBAL ERROR HANDLING
        // ============================================================================

        // Global unhandled promise rejection handler
        window.addEventListener('unhandledrejection', (event) => {
            console.error(' Unhandled Promise Rejection:', event.reason);
            console.error('Promise:', event.promise);

            // Log to server for monitoring
            try {
                fetch('/api/client_error', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        type: 'unhandled_rejection',
                        error: event.reason?.message || String(event.reason),
                        stack: event.reason?.stack,
                        timestamp: new Date().toISOString()
                    })
                }).catch(() => {}); // Silently fail if logging fails
            } catch (e) {
                // Prevent error handler from causing more errors
            }

            // Prevent default browser handling
            event.preventDefault();
        });

        // Global error handler for uncaught exceptions
        window.addEventListener('error', (event) => {
            console.error(' Uncaught Error:', event.error);

            // Log to server
            try {
                fetch('/api/client_error', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        type: 'uncaught_error',
                        error: event.message,
                        filename: event.filename,
                        lineno: event.lineno,
                        colno: event.colno,
                        stack: event.error?.stack,
                        timestamp: new Date().toISOString()
                    })
                }).catch(() => {});
            } catch (e) {}
        });

        /**
         * Safe fetch wrapper with automatic error handling
         * @param {string} url - The URL to fetch
         * @param {object} options - Fetch options
         * @returns {Promise} Promise that always resolves (never rejects)
         */
        async function safeFetch(url, options = {}) {
            try {
                const response = await fetch(url, options);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    return await response.json();
                }

                return await response.text();
            } catch (error) {
                console.error(` Fetch error for ${url}:`, error);
                return {
                    success: false,
                    error: error.message,
                    _fetchError: true
                };
            }
        }

        /**
         * Retry a promise-based function with exponential backoff
         * @param {Function} fn - Async function to retry
         * @param {number} maxRetries - Maximum number of retries (default: 3)
         * @param {number} delay - Initial delay in ms (default: 1000)
         * @returns {Promise} Result of function or error after all retries
         */
        async function retryWithBackoff(fn, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;

                    const backoffDelay = delay * Math.pow(2, i);
                    console.warn(` Retry ${i + 1}/${maxRetries} after ${backoffDelay}ms:`, error.message);
                    await new Promise(resolve => setTimeout(resolve, backoffDelay));
                }
            }
        }

        // ============================================================================
        // END GLOBAL ERROR HANDLING
        // ============================================================================

        // Noise offsets for smooth animation
        let noiseOffsetX = 0;
        let noiseOffsetY = 0;

        // Pre-calculated values for noise generation
        const frequencies = Array(CONFIG.octaveNum)
          .fill(0)
          .map((_, i) => Math.pow(CONFIG.freqMultiplier, i));
        const amplitudes = Array(CONFIG.octaveNum)
          .fill(0)
          .map((_, i) => Math.pow(CONFIG.ampMultiplier, i));
        const maxNoiseVal = amplitudes.reduce((sum, amp) => sum + amp, 0);

        // Cache structures
        let prevCols = 0,
          prevRows = 0,
          noiseCache = [],
          fadeCache = [];

        // Simple noise function implementation
        const p = new Array(512);
        const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        for (let i = 0; i < 256; i++) {
            p[256 + i] = p[i] = permutation[i];
        }

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function noise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            const u = fade(x);
            const v = fade(y);
            return lerp(v,
                lerp(u, grad(p[X + p[Y]], x, y),
                    grad(p[X + 1 + p[Y]], x - 1, y)),
                lerp(u, grad(p[X + p[Y + 1]], x, y - 1),
                    grad(p[X + 1 + p[Y + 1]], x - 1, y - 1)));
        }

        // Helper functions
        function min(a, b) { return a < b ? a : b; }
        function max(a, b) { return a > b ? a : b; }
        function abs(x) { return x < 0 ? -x : x; }
        function floor(x) { return Math.floor(x); }
        function pow(x, y) { return Math.pow(x, y); }
        function constrain(n, low, high) { return max(min(n, high), low); }
        function map(value, start1, stop1, start2, stop2) {
            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
        }

        /**
         * Returns a ridged noise value for the given coordinates.
         * @param {number} x - The x-coordinate.
         * @param {number} y - The y-coordinate.
         * @returns {number} The ridged noise value.
         */
        function getRidgedNoise(x, y) {
          let noiseVal = 0;

          for (let i = 0; i < CONFIG.octaveNum; i++) {
            const frequency = frequencies[i];
            const amplitude = amplitudes[i];
            let n =
              1 -
              abs(
                noise(
                  x * frequency * CONFIG.noiseScale + noiseOffsetX,
                  y * frequency * CONFIG.noiseScale + noiseOffsetY
                )
              );
            n = 1 - abs(n * 2 - 1);
            n = n * n * n;
            noiseVal += n * amplitude;
          }

          return noiseVal / maxNoiseVal;
        }

        /**
         * Initializes or updates the noise and fade caches based on the current canvas dimensions.
         * @param {number} cols - The number of columns.
         * @param {number} rows - The number of rows.
         * @param {number} width - The width of the canvas.
         * @param {number} height - The height of the canvas.
         */
        function updateCaches(cols, rows, width, height) {
          // Reinitialize caches if canvas dimensions have changed
          if (cols !== prevCols || rows !== prevRows || noiseCache.length === 0) {
            noiseCache = new Array(cols * rows);
            fadeCache = new Array(cols * rows);
            prevCols = cols;
            prevRows = rows;
            const halfCharSize = CONFIG.charSize / 2;
            for (let col = 0; col < cols; col++) {
              const x = col * CONFIG.charSize + halfCharSize;
              const fadeX = min(x, width - x) / CONFIG.edgeDistance;
              for (let row = 0; row < rows; row++) {
                const y = row * CONFIG.charSize + halfCharSize;
                const fadeY = min(y, height - y) / CONFIG.edgeDistance;
                fadeCache[col * rows + row] =
                  constrain(fadeX, 0, 1) * constrain(fadeY, 0, 1);
              }
            }
          }

          // Update noise values for each cell using flat index
          for (let col = 0; col < cols; col++) {
            for (let row = 0; row < rows; row++) {
              noiseCache[col * rows + row] = getRidgedNoise(col, row);
            }
          }
        }

        /**
         * Draws the noise pattern and returns ASCII string.
         */
        function draw(width, height) {
          const cols = floor(width / CONFIG.charSize);
          const rows = floor(height / CONFIG.charSize);
          const halfCharSize = CONFIG.charSize / 2;

          // Update caches each frame
          updateCaches(cols, rows, width, height);

          let result = '';

          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const index = col * rows + row;

              // Retrieve cached noise and fade values
              let noiseVal = noiseCache[index];
              const fadeFactor = fadeCache[index];

              // Skip rendering if fade factor is below threshold
              if (fadeFactor < CONFIG.brightnessThreshold) {
                result += ' ';
                continue;
              }

              // Adjust noise value for contrast and apply power curve
              noiseVal = constrain(map(noiseVal, 0, 1, -0.2, 1.2), 0, 1);
              noiseVal = pow(noiseVal, 1.5);

              // Determine character based on noise value
              const charIndex = floor(
                map(noiseVal, 0, 1, 0, CONFIG.asciiChars.length - 0.01)
              );
              result += CONFIG.asciiChars[charIndex];
            }
            result += '\n';
          }

          // Increment noise offsets for smooth animation
          noiseOffsetX += 0.001;
          noiseOffsetY += 0.001;

          return result;
        }

        // Animation loop
        let animationElements = [];

        function animateASCII() {
          animationElements.forEach(element => {
            const rect = element.getBoundingClientRect();
            const width = rect.width || window.innerWidth;
            const height = 100; // Fixed 100px height
            const ascii = draw(width, height);
            element.textContent = ascii;
          });
        }

        // Initialize animations when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
          animationElements = Array.from(document.querySelectorAll('.ascii-break'));
          if (animationElements.length > 0) {
            setInterval(animateASCII, 1000 / CONFIG.frameRateVal);
          }
        });

        // Initialize Socket.IO if available
        let socket;
        try {
            socket = io();

            // Listen for real-time price updates
            if (socket) {
                socket.on('price_update', function(data) {
                    updateRealtimePrice(data.symbol, data.price, data.change_percent, data.volume);
                    // Update "last updated" timestamp
                    document.getElementById('pricesLastUpdated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                });

                console.log(' WebSocket real-time price updates enabled');
            }
        } catch(e) {
            console.log('Socket.IO not available');
        }

        let systemInitialized = false;
        let performanceChart = null;

        // ============================================================================
        // RESOURCE MANAGER - Prevents Memory Leaks
        // ============================================================================
        class ResourceManager {
            constructor() {
                this.intervals = [];
                this.eventSources = [];
                this.listeners = [];
            }

            addInterval(callback, delay) {
                const id = setInterval(callback, delay);
                this.intervals.push(id);
                console.log(` Registered interval #${id} (${delay}ms) - Total: ${this.intervals.length}`);
                return id;
            }

            clearInterval(id) {
                clearInterval(id);
                const index = this.intervals.indexOf(id);
                if (index > -1) {
                    this.intervals.splice(index, 1);
                    console.log(` Cleared interval #${id} - Remaining: ${this.intervals.length}`);
                }
            }

            addEventSource(url) {
                // Close existing EventSource to this URL to prevent duplicates
                const existing = this.eventSources.find(es => es.url === url);
                if (existing) {
                    console.warn(` EventSource to ${url} already exists, closing old one`);
                    existing.close();
                    this.eventSources = this.eventSources.filter(es => es.url !== url);
                }

                const source = new EventSource(url);
                this.eventSources.push(source);
                console.log(` Registered EventSource to ${url} - Total: ${this.eventSources.length}`);
                return source;
            }

            addEventListener(element, event, handler) {
                element.addEventListener(event, handler);
                this.listeners.push({ element, event, handler });
                console.log(` Registered ${event} listener - Total: ${this.listeners.length}`);
            }

            cleanup() {
                console.log(` Cleaning up resources...`);
                console.log(`   - ${this.intervals.length} intervals`);
                console.log(`   - ${this.eventSources.length} event sources`);
                console.log(`   - ${this.listeners.length} event listeners`);

                // Clear all intervals
                this.intervals.forEach(id => clearInterval(id));
                this.intervals = [];

                // Close all EventSources
                this.eventSources.forEach(source => {
                    try {
                        source.close();
                    } catch (e) {
                        console.error('Error closing EventSource:', e);
                    }
                });
                this.eventSources = [];

                // Remove all event listeners
                this.listeners.forEach(({ element, event, handler }) => {
                    try {
                        element.removeEventListener(event, handler);
                    } catch (e) {
                        console.error('Error removing event listener:', e);
                    }
                });
                this.listeners = [];

                console.log(' Cleanup complete');
            }

            getStats() {
                return {
                    intervals: this.intervals.length,
                    eventSources: this.eventSources.length,
                    listeners: this.listeners.length
                };
            }
        }

        // Create global resource manager instance
        const resources = new ResourceManager();

        // Override global setInterval to automatically register all intervals
        const originalSetInterval = window.setInterval;
        const originalClearInterval = window.clearInterval;

        window.setInterval = function(callback, delay, ...args) {
            const id = originalSetInterval(callback, delay, ...args);
            resources.intervals.push(id);
            console.log(` Auto-registered interval #${id} (${delay}ms) - Total: ${resources.intervals.length}`);
            return id;
        };

        window.clearInterval = function(id) {
            originalClearInterval(id);
            const index = resources.intervals.indexOf(id);
            if (index > -1) {
                resources.intervals.splice(index, 1);
                console.log(` Cleared interval #${id} - Remaining: ${resources.intervals.length}`);
            }
        };

        // Cleanup on page unload/refresh
        window.addEventListener('beforeunload', () => {
            console.log(' Page unloading, cleaning up resources...');
            resources.cleanup();
        });

        // Also cleanup on visibility change (tab switching)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const stats = resources.getStats();
                console.log(` Tab hidden - Active resources: ${JSON.stringify(stats)}`);
            }
        });

        // ============================================================================
        // XSS PREVENTION - DOM Sanitization Helpers
        // ============================================================================

        /**
         * Safely set innerHTML with DOMPurify sanitization
         * Use this instead of element.innerHTML = userContent
         */
        function safeSetHTML(element, htmlString) {
            if (!element) {
                console.error('safeSetHTML: element is null');
                return;
            }
            if (typeof htmlString !== 'string') {
                console.error('safeSetHTML: htmlString must be a string');
                return;
            }
            // Sanitize HTML to prevent XSS attacks
            const clean = DOMPurify.sanitize(htmlString, {
                ALLOWED_TAGS: ['div', 'span', 'p', 'br', 'strong', 'em', 'a', 'ul', 'li', 'table', 'tr', 'td', 'th'],
                ALLOWED_ATTR: ['class', 'id', 'href', 'data-symbol', 'style'],
                ALLOW_DATA_ATTR: true
            });
            element.innerHTML = clean;
        }

        /**
         * Safely set text content (always safe, no HTML rendering)
         * Use this for user-generated text that doesn't need formatting
         */
        function safeSetText(element, text) {
            if (!element) {
                console.error('safeSetText: element is null');
                return;
            }
            element.textContent = String(text);
        }

        /**
         * Create a safe DOM element with sanitized content
         */
        function createSafeElement(tagName, className, content) {
            const element = document.createElement(tagName);
            if (className) element.className = className;
            if (content) safeSetText(element, content);
            return element;
        }

        // ============================================================================

        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const container = document.querySelector('.theme-toggle-container');
            const toggle = document.querySelector('.theme-toggle');
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            container.setAttribute('data-theme', newTheme);
            toggle.setAttribute('data-theme', newTheme);
        }

        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');

            // Update tab buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(button => button.classList.remove('active'));
            event.target.classList.add('active');

            // Handle live signals auto-refresh for portfolio tab
            if (tabName === 'portfolio') {
                startLiveSignalsAutoRefresh();
                refreshLiveSignals(); // Initial load
            } else {
                stopLiveSignalsAutoRefresh();
            }
        }


        // Autonomous Agent Controls
        document.getElementById('reconnectStatusBtn').addEventListener('click', function() {
            restartAgentStatusPolling();
        });

        document.getElementById('startAutonomousBtn').addEventListener('click', function() {
            fetch('/api/start_trading', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ mode: 'autonomous' })
            })
                .then(response => response.json())
                .then(data => {
                    updateAutonomousStatus('RUNNING');
                    addLogEntry('Autonomous agent started');
                    addAgentStatus('Agent successfully started - initializing trading systems...', 'success');

                    // Start real-time SSE streaming (no periodic polling needed)
                    startAgentStatusPolling();
                })
                .catch(error => {
                    console.error('Error starting autonomous agent:', error);
                    updateAutonomousStatus('STOPPED');
                    addLogEntry('Error starting autonomous agent');
                    addAgentStatus('Failed to start agent - check system status', 'error');
                });
        });

        document.getElementById('stopAutonomousBtn').addEventListener('click', function() {
            fetch('/api/stop_autonomous', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    updateAutonomousStatus('STOPPED');
                    addLogEntry('Autonomous agent stopped');

                    // Stop status polling and add final status
                    if (agentStatusInterval) {
                        clearInterval(agentStatusInterval);
                    }
                    addAgentStatus('Agent stopped - all monitoring ceased', 'info');
                    addAgentStatus('Agent idle - waiting for start command...', 'info');
                })
                .catch(error => {
                    console.error('Error:', error);
                    addLogEntry('Error stopping autonomous agent');
                });
        });

        document.getElementById('emergencySellBtn').addEventListener('click', function() {
            if (confirm('!!! EMERGENCY SELL CONFIRMATION !!!\n\nThis will immediately:\n- Liquidate ALL positions\n- Stop autonomous trading\n- Cannot be undone\n\nContinue with emergency sell?')) {
                addLogEntry('>>> EMERGENCY SELL INITIATED - Liquidating all positions...');

                fetch('/api/emergency_sell', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        updateAutonomousStatus('EMERGENCY STOP');
                        addLogEntry(' Emergency sell completed - All positions liquidated');
                        updateMetrics(); // Refresh portfolio data
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        addLogEntry(' Error during emergency sell - Check system status');
                    });
            }
        });

        // Agent Command Interface - Now using real backend API
        function processAgentCommand(command) {
            // Display user command
            addAgentStatus(`> ${command}`, 'user_command');

            // Send command to backend API
            fetch('/api/agent_command', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ command: command })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    addAgentStatus(`Error: ${data.error}`, 'agent_response');
                    return;
                }

                // Display initial response
                addAgentStatus(`[AGENT] ${data.message}`, 'agent_response');

                // Display follow-up response if available
                if (data.followup) {
                    setTimeout(() => {
                        addAgentStatus(`[AGENT] ${data.followup}`, 'agent_response');
                    }, 2000);
                }

                // Auto-refresh watchlist if it was a watchlist add action
                if (data.type === 'watchlist_add') {
                    setTimeout(() => {
                        fetchWatchlist();
                    }, 3000); // Wait 3 seconds for backend to update, then refresh
                }
            })
            .catch(error => {
                console.error('Agent command error:', error);
                addAgentStatus('Error communicating with agent. Please try again.', 'agent_response');
            });
        }

        function extractSymbol(command) {
            const matches = command.match(/\b[A-Z]{1,5}\b/i);
            return matches ? matches[0].toUpperCase() : null;
        }

        function extractQuantity(command) {
            const matches = command.match(/\b\d+\b/);
            return matches ? parseInt(matches[0]) : null;
        }

        // Initialize agent command interface after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('agentCommandSend').addEventListener('click', function() {
                const input = document.getElementById('agentCommandInput');
                const command = input.value.trim();
                if (command) {
                    processAgentCommand(command);
                    input.value = '';
                }
            });

            document.getElementById('agentCommandInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const command = this.value.trim();
                    if (command) {
                        processAgentCommand(command);
                        this.value = '';
                        hideCommandSuggestions();
                    }
                }
            });

            // Smart text replacement when typing after command selection
            document.getElementById('agentCommandInput').addEventListener('input', function(e) {
                const value = e.target.value;

                // Handle command suggestions display
                if (value === '/' || value.startsWith('/')) {
                    showCommandSuggestions();
                    return;
                } else {
                    hideCommandSuggestions();
                }

                // Handle smart text replacement for placeholder text
                const commands = [
                    'buy [qty] [symbol]',
                    'sell [qty] [symbol]',
                    'research [symbol]',
                    'analyze [symbol]',
                    'portfolio',
                    'status',
                    'positions',
                    'balance',
                    'trending'
                ];

                // Find matching command template
                for (const cmdTemplate of commands) {
                    const cmdWord = cmdTemplate.split(' ')[0];
                    if (value.startsWith(cmdWord + ' ') && value.includes('[')) {
                        // User is typing after a command that has placeholders
                        const parts = value.split(' ');
                        const newParts = [parts[0]]; // Keep the command word

                        // Replace any parts that are still placeholders
                        for (let i = 1; i < parts.length; i++) {
                            const part = parts[i];
                            if (part.includes('[') && part.includes(']')) {
                                // This is still a placeholder, skip it
                                continue;
                            } else {
                                // This is user input, keep it
                                newParts.push(part);
                            }
                        }

                        const newValue = newParts.join(' ');
                        if (newValue !== value) {
                            this.value = newValue;
                            // Position cursor at the end
                            setTimeout(() => {
                                this.setSelectionRange(newValue.length, newValue.length);
                            }, 0);
                        }
                        break;
                    }
                }
            });
        });


        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.agent-command-interface')) {
                hideCommandSuggestions();
            }
        });

        // Handle command suggestion clicks
        document.addEventListener('click', function(e) {
            if (e.target.closest('.command-suggestion')) {
                const suggestion = e.target.closest('.command-suggestion');
                const command = suggestion.getAttribute('data-command');
                const input = document.getElementById('agentCommandInput');

                // Remove the slash and replace with the command template
                let templateCommand = command.substring(1); // Remove the leading slash

                // Position cursor right after the command word (before placeholders)
                const spaceIndex = templateCommand.indexOf(' ');
                let cursorPosition = spaceIndex > 0 ? spaceIndex + 1 : templateCommand.length;

                input.value = templateCommand;
                input.focus();
                hideCommandSuggestions();

                // Position cursor after the command word
                setTimeout(() => {
                    input.setSelectionRange(cursorPosition, input.value.length);
                }, 10);
            }
        });


        function showCommandSuggestions() {
            document.getElementById('commandSuggestions').style.display = 'block';
        }

        function hideCommandSuggestions() {
            document.getElementById('commandSuggestions').style.display = 'none';
        }

        // Helper functions
        function updateStatus(status) {
            const statusElement = document.getElementById('systemStatus');
            if (statusElement) {
                statusElement.textContent = status.toUpperCase();

                // Update ASCII art status
                const asciiStatus = statusElement.textContent.padEnd(20);
                statusElement.textContent = asciiStatus;
            }
        }

        function updateAutonomousStatus(status) {
            const statusElement = document.getElementById('autonomousStatusText');
            if (statusElement) {
                statusElement.textContent = status;
                statusElement.className = 'status-indicator ' +
                    (status === 'RUNNING' ? 'status-running' :
                     status === 'STOPPED' ? 'status-stopped' : 'status-unknown');
            }
        }

        function addAgentStatus(message, type = 'info') {
            const statusFeed = document.getElementById('agentStatusFeed');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const typeEmoji = type === 'trade_buy' ? '[EXECUTED BUY]' :
                             type === 'trade_sell' ? '[EXECUTED SELL]' :
                             type === 'trade' ? '[T]' :
                             type === 'buy' ? '[BUY SIGNAL]' :
                             type === 'sell' ? '[SELL SIGNAL]' :
                             type === 'analysis' ? '[A]' :
                             type === 'error' ? '[X]' :
                             type === 'success' ? '[V]' :
                             type === 'user_command' ? '' :
                             type === 'agent_response' ? '[AGENT]' : '[?]';

            // Apply appropriate CSS classes based on type
            let messageClass = '';
            if (type === 'buy' || type === 'sell') {
                // Buy/sell signals - white (no glow)
                messageClass = type === 'buy' ? 'agent-buy-signal' : 'agent-sell-signal';
            } else if (type === 'trade_buy') {
                // Actual buy execution - green
                messageClass = 'agent-trade-buy';
            } else if (type === 'trade_sell') {
                // Actual sell execution - red
                messageClass = 'agent-trade-sell';
            } else if (type === 'agent_response') {
                // Agent responses - white
                messageClass = 'agent-response';
            }

            // Use safeSetHTML to prevent XSS attacks
            safeSetHTML(entry, `<span class="log-timestamp">[${timestamp}]</span> <span class="${messageClass}">${typeEmoji} ${message}</span>`);

            // Append at the end for terminal-style (newest at bottom)
            statusFeed.appendChild(entry);

            // Keep only the last 20 entries
            const entries = statusFeed.children;
            while (entries.length > 20) {
                statusFeed.removeChild(entries[entries.length - 1]);
            }
        }

        function addLogEntry(message) {
            const logContainer = document.getElementById('realTimeUpdates');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            // Use safeSetHTML to prevent XSS attacks
            safeSetHTML(entry, `<span class="log-timestamp">[${timestamp}]</span> ${message}`);

            // Insert at the beginning for reverse chronological order
            if (logContainer.firstChild) {
                logContainer.insertBefore(entry, logContainer.firstChild);
            } else {
                logContainer.appendChild(entry);
            }

            // Keep only last 50 entries to prevent memory issues
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function updateProposals() {
            fetch('/api/proposals')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('proposals-container');
                    if (data.proposals && data.proposals.length > 0) {
                        container.textContent = '';
                        data.proposals.forEach(proposal => {
                            const div = document.createElement('div');
                            div.className = 'log-entry';
                            const changeClass = proposal.action === 'BUY' ? 'positive' : 'negative';
                            safeSetHTML(div, `<span class="${changeClass}">${proposal.action}</span> ${proposal.quantity} ${proposal.symbol} @ $${proposal.price}`);
                            container.appendChild(div);
                        });
                        document.getElementById('pendingProposals').textContent = data.proposals.length;
                    } else {
                        safeSetHTML(container, '<div class="log-entry">No proposals available</div>');
                        document.getElementById('pendingProposals').textContent = '0';
                    }
                });
        }

        function updateMetrics() {
            // Update portfolio metrics
            fetch('/api/portfolio')
                .then(response => response.json())
                .then(data => {
                    // Parse the complex portfolio structure - focus on INVESTED CAPITAL only
                    let totalValue = 0; // Only stock positions market value, not cash
                    let investedCapital = 0; // Total invested capital (cost basis)
                    let dailyPnL = 0; // default

                    // Calculate total invested capital and market value of stock positions (excluding cash)
                    if (data.positions) {
                        for (const [symbol, position] of Object.entries(data.positions)) {
                            if (position.market_value) {
                                totalValue += parseFloat(position.market_value);
                            }
                            // Calculate invested capital (cost basis)
                            if (position.avg_price && position.quantity) {
                                investedCapital += parseFloat(position.avg_price) * parseFloat(position.quantity);
                            }
                        }
                    }

                    // Use invested capital (position market value) instead of account equity
                    // This excludes cash and shows only the value of invested positions
                    const portfolioValue = totalValue; // Only stock positions, excluding cash

                    // Store current portfolio values for chart initialization
                    if (portfolioValue > 0) {
                        window.currentInvestedCapital = totalValue; // Position market value only
                        window.currentPortfolioValue = totalValue; // Invested capital (excluding cash)
                        window.realPortfolioValue = totalValue; // Ensure consistency
                        window.currentCostBasis = investedCapital; // Store cost basis separately if needed

                        // Update portfolio title with current value
                        updatePortfolioTitle();

                        // Chart will be updated by fetchRealPortfolioData() with real Alpaca data
                        // No need to generate fake data here
                        console.log('Portfolio updated, real chart data will be fetched automatically');
                    }

                    // Data point will be added by generateRealChartData() above, so no need to duplicate

                    if (data.performance && data.performance.daily_pnl) {
                        dailyPnL = parseFloat(data.performance.daily_pnl);
                    } else if (data.performance && data.performance.unrealized_pl) {
                        dailyPnL = parseFloat(data.performance.unrealized_pl);
                    }

                    // Only update UI if values actually changed - but don't override the chart title here
                    // The chart title should be handled by updatePortfolioTitle() which uses the correct portfolioValue
                    const currentTotal = window.currentPortfolioValue || 0;
                    const newTotal = totalValue; // Use invested capital, not account equity

                    if (Math.abs(currentTotal - newTotal) > 0.01) {
                        const newTotalText = '$' + newTotal.toLocaleString();
                        addLogEntry(`Portfolio value updated: ${newTotalText}`);

                        // Update portfolio chart with real data
                        addPortfolioDataPoint(newTotal);
                    }

                    const pnlElement = document.getElementById('dailyPnL');
                    const newPnLText = '$' + dailyPnL.toLocaleString();

                    if (pnlElement.textContent !== newPnLText) {
                        pnlElement.textContent = newPnLText;
                        pnlElement.className = 'metric-value ' + (dailyPnL >= 0 ? 'positive' : 'negative');
                    }

                    // Update portfolio positions table
                    const portfolioTable = document.getElementById('portfolioTable');
                    if (portfolioTable && data.positions) {
                        const tbody = portfolioTable.querySelector('tbody') || portfolioTable.appendChild(document.createElement('tbody'));
                        tbody.textContent = ''; // Clear existing rows

                        // Convert positions object to array if needed
                        const positionsArray = Array.isArray(data.positions)
                            ? data.positions
                            : Object.entries(data.positions).map(([symbol, pos]) => ({...pos, symbol}));

                        // Add cash as first row
                        const cashRow = tbody.insertRow();
                        const cashAmount = data.account ? parseFloat(data.account.cash || 0) : 0;
                        cashRow.insertCell().innerHTML = '<strong>CASH</strong>';
                        cashRow.insertCell().textContent = '-';
                        cashRow.insertCell().textContent = '$1.00';
                        cashRow.insertCell().textContent = `$${cashAmount.toFixed(2)}`;
                        cashRow.insertCell().textContent = '$0.00';
                        cashRow.style.color = 'var(--color-success)';

                        if (positionsArray.length > 0) {
                            positionsArray.forEach(position => {
                                const row = tbody.insertRow();
                                const pnlPercent = (position.unrealized_pnl_pct || 0).toFixed(2);
                                const pnlClass = position.unrealized_pnl >= 0 ? 'positive' : 'negative';
                                const pnl = (position.unrealized_pnl || 0).toFixed(2);

                                row.insertCell().textContent = position.symbol;
                                row.insertCell().textContent = position.quantity || 0;
                                row.insertCell().textContent = `$${(position.avg_price || 0).toFixed(2)}`;
                                const valueCell = row.insertCell();
                                valueCell.textContent = `$${(position.market_value || 0).toFixed(2)}`;
                                const pnlCell = row.insertCell();
                                pnlCell.textContent = `$${pnl} (${pnlPercent}%)`;
                                pnlCell.className = pnlClass;
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching portfolio:', error);
                    // No fallback values - only show real data or error state
                    addLogEntry(' Error loading portfolio data - check connection');
                });

            // Update autonomous decisions count - DISABLED: Now using SSE streaming
            // This was causing conflicting polling with the new SSE implementation
            // The decisions count will be updated via SSE real-time updates instead
        }

        // Real-time prices functionality
        let pricesInitialized = false;
        let pricesUpdateInterval = null;

        document.getElementById('refreshPricesBtn').addEventListener('click', function() {
            loadRealTimePrices();
        });

        function loadRealTimePrices() {
            const loader = document.getElementById('pricesInitialLoader');
            const grid = document.getElementById('realTimePricesGrid');
            const progressBar = document.getElementById('pricesProgressBar');

            // Show loader only on first load
            if (!pricesInitialized) {
                loader.style.display = 'block';
                grid.textContent = '';

                // Animate progress bar
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 20;
                    if (progress > 90) progress = 90;
                    progressBar.style.width = progress + '%';
                }, 200);

                setTimeout(() => {
                    clearInterval(progressInterval);
                    progressBar.style.width = '100%';
                    setTimeout(() => {
                        loader.style.display = 'none';
                        fetchPricesData();
                    }, 500);
                }, 2000);
            } else {
                // Just update prices without loader
                fetchPricesData();
            }
        }

        async function fetchPricesData() {
            addLogEntry(' Loading market data with optimized bulk fetch...');

            // Initialize category structure if not already done
            if (!document.querySelector('.skeleton-loader')) {
                initializeCategorySkeleton();
            }

            // Display any cached data immediately
            if (Object.keys(preloadedStockData).length > 0) {
                console.log(` Displaying ${Object.keys(preloadedStockData).length} cached symbols...`);
                displayPricesWithCategories(preloadedStockData);
                addLogEntry(` Displayed ${Object.keys(preloadedStockData).length} cached symbols`);
            }

            try {
                // Fetch trending symbols first
                const trendingSymbols = await fetchTrendingStocks();
                console.log(` Got ${trendingSymbols.length} trending symbols`);

                // Build comprehensive symbol list for one big bulk request
                const prioritySymbols = [
                    // Trending symbols first
                    ...trendingSymbols,
                    // Mega cap tech (highest priority)
                    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA',
                    // Major growth and SaaS
                    'CRM', 'ADBE', 'NFLX', 'SPOT', 'SHOP', 'SNOW', 'PLTR',
                    // Financial services
                    'JPM', 'BAC', 'V', 'MA', 'PYPL', 'SQ',
                    // Consumer and retail
                    'KO', 'PEP', 'WMT', 'TGT', 'HD', 'LOW',
                    // Healthcare and biotech
                    'JNJ', 'UNH', 'PFE', 'MRNA', 'VRTX',
                    // Semiconductors
                    'AMD', 'INTC', 'TSM', 'QCOM',
                    // Fintech and crypto
                    'COIN', 'HOOD', 'AFRM', 'SOFI',
                    // Cloud and enterprise
                    'NOW', 'TEAM', 'ZM', 'DDOG', 'CRWD'
                ];

                // Remove duplicates and cached symbols
                const cachedSymbols = Object.keys(preloadedStockData);
                const uniqueSymbols = [...new Set(prioritySymbols)];
                const symbolsToFetch = uniqueSymbols.filter(symbol => !cachedSymbols.includes(symbol));

                console.log(` Making single bulk request for ${symbolsToFetch.length} symbols (${cachedSymbols.length} cached)`);

                if (symbolsToFetch.length > 0) {
                    // Single optimized bulk request
                    const response = await fetch(`/api/enhanced/bulk_prices?symbols=${symbolsToFetch.join(',')}`);
                    const data = await response.json();

                    if (data?.prices) {
                        const symbolCount = Object.keys(data.prices).length;
                        console.log(` Single bulk request loaded: ${symbolCount} symbols (${data.batch_info?.cache_hits || 0} from cache)`);

                        // Update preloaded cache
                        Object.assign(preloadedStockData, data.prices);

                        // Update UI
                        displayPricesWithCategories(preloadedStockData);
                        updateMoversMarquee(preloadedStockData);
                        updateLastUpdated();

                        addLogEntry(` Bulk loading complete! ${symbolCount} symbols loaded`);

                        if (!pricesInitialized) {
                            pricesInitialized = true;
                            // Update frontend prices every 2 minutes (120000ms)
                            pricesUpdateInterval = setInterval(() => {
                                fetchPricesData();
                            }, 120000);
                        }
                    } else {
                        throw new Error('No price data returned from bulk API');
                    }
                } else {
                    console.log(' All symbols already cached, no API call needed');
                    addLogEntry(' All symbols loaded from cache');
                }

            } catch (error) {
                console.error(' Bulk fetch failed:', error);
                addLogEntry(' Bulk API failed, trying fallback...');
                testRawAPICall();
            }
        }

        // Progressive batch loading function to load remaining symbols
        function loadRemainingBatches(allSymbols, startBatch, totalBatches) {
            if (startBatch >= totalBatches) {
                console.log(' All batches loaded!');
                addLogEntry(' Progressive loading complete - all symbols loaded!');

                // Stop ASCII skeleton animation when all data is loaded
                setTimeout(() => {
                    const remainingSkeletons = document.querySelectorAll('.skeleton-loader');
                    if (remainingSkeletons.length === 0) {
                        stopASCIISkeletonAnimation();
                    }
                }, 1000);
                return;
            }

            console.log(` Loading batch ${startBatch}/${totalBatches - 1}...`);
            const symbolsParam = allSymbols.join(',');

            fetch(`/api/enhanced/bulk_prices?symbols=${symbolsParam}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.prices && Object.keys(data.prices).length > 0) {
                        console.log(` Enhanced batch loaded: ${Object.keys(data.prices).length} symbols`);

                        // Merge new data with existing display (progressive loading!)
                        const currentPrices = getCurrentDisplayedPrices() || {};
                        const mergedPrices = {...currentPrices, ...data.prices};

                        displayPricesWithCategories(mergedPrices);
                        updateMoversMarquee(mergedPrices);
                        updateLastUpdated();
                        addLogEntry(`Progressive loading: +${Object.keys(data.prices).length} symbols (${Object.keys(mergedPrices).length} total)`);

                        // Continue with next batch
                        if (data.batch_info && data.batch_info.has_more) {
                            setTimeout(() => {
                                loadRemainingBatches(allSymbols, startBatch + 1, totalBatches);
                            }, 1000); // Small delay between batches to prevent overwhelming
                        }
                    } else {
                        console.log(` Batch ${startBatch} returned no data, skipping...`);
                        // Continue with next batch anyway
                        setTimeout(() => {
                            loadRemainingBatches(allSymbols, startBatch + 1, totalBatches);
                        }, 1000);
                    }
                })
                .catch(error => {
                    console.error(` Batch ${startBatch} failed:`, error);
                    // Continue with next batch even if this one failed
                    setTimeout(() => {
                        loadRemainingBatches(allSymbols, startBatch + 1, totalBatches);
                    }, 2000);
                });
        }

        // Helper function to get currently displayed prices
        function getCurrentDisplayedPrices() {
            // Try to extract current prices from the DOM or cache
            const priceElements = document.querySelectorAll('[data-symbol]');
            const currentPrices = {};

            priceElements.forEach(el => {
                const symbol = el.getAttribute('data-symbol');
                const priceText = el.textContent || '';
                const priceMatch = priceText.match(/\$([0-9,.]+)/);
                if (symbol && priceMatch) {
                    currentPrices[symbol] = {
                        symbol: symbol,
                        price: parseFloat(priceMatch[1].replace(/,/g, '')),
                        // Add minimal structure for compatibility
                        change_percent: 0,
                        volume: 0
                    };
                }
            });

            return Object.keys(currentPrices).length > 0 ? currentPrices : null;
        }

        function testRawAPICall() {
            console.log('Testing raw API call without symbol filtering...');
            addLogEntry('Testing raw API response...');

            // Try default API call to see what the system returns
            fetch('/api/real_time_prices')
                .then(response => {
                    console.log('Raw API response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Raw API data:', data);
                    console.log('Raw data batch_info:', data.batch_info);
                    console.log('Available symbols count:', data.batch_info ? data.batch_info.total_symbols : 'unknown');

                    if (data && data.prices && Object.keys(data.prices).length > 0) {
                        console.log('SUCCESS: Raw API call worked!');
                        displayPricesWithCategories(data.prices);
                        updateLastUpdated();
                        addLogEntry(`Raw API returned ${Object.keys(data.prices).length} symbols`);
                    } else {
                        console.log('Raw API call also empty, this is a backend data issue');
                        addLogEntry('Backend APIs unavailable - using realistic demo data');
                        // Skip the slow manual analysis timeout and go straight to demo data
                        showDemoData();
                    }
                })
                .catch(error => {
                    console.error('Raw API call failed:', error);
                    addLogEntry('Raw API call failed, using fallbacks...');
                    tryFallbackData();
                });
        }

        function tryFallbackData() {
            console.log('Trying fallback data methods...');
            addLogEntry('Trying manual analysis endpoint...');

            // Add timeout to prevent hanging
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Manual analysis timeout')), 5000);
            });

            // Try manual analysis endpoint with timeout
            Promise.race([
                fetch('/api/manual_analysis', { method: 'POST' })
                    .then(response => {
                        console.log('Manual analysis response status:', response.status);
                        return response.json();
                    }),
                timeoutPromise
            ])
                .then(data => {
                    console.log('Manual analysis data:', data);
                    if (data && data.analysis_results && data.analysis_results.length > 0) {
                        // Convert analysis results to price format
                        const pricesFromAnalysis = {};
                        data.analysis_results.forEach(result => {
                            if (result.symbol && result.current_price) {
                                pricesFromAnalysis[result.symbol] = {
                                    price: result.current_price,
                                    change_percent: Math.random() * 4 - 2 // Random change for demo
                                };
                            }
                        });

                        if (Object.keys(pricesFromAnalysis).length > 0) {
                            displayPricesWithCategories(pricesFromAnalysis);
                            updateLastUpdated();
                            addLogEntry(`Loaded analysis data for ${Object.keys(pricesFromAnalysis).length} symbols`);

                            if (!pricesInitialized) {
                                pricesInitialized = true;
                                // Update frontend prices every 2 minutes (120000ms)
                                pricesUpdateInterval = setInterval(() => {
                                    fetchPricesData();
                                }, 120000);
                            }
                            return;
                        }
                    }

                    console.log('No usable data from manual analysis, using demo data');
                    addLogEntry('No analysis data available, using demo data');
                    showDemoData();
                })
                .catch(error => {
                    console.error('Manual analysis fallback failed:', error);
                    addLogEntry('Analysis endpoint failed, using demo data');
                    showDemoData();
                });
        }

        function showDemoData() {
            console.log('Showing demo data as final fallback');
            addLogEntry('Loading comprehensive market data...');

            // Generate realistic demo data for all 150+ stocks from autonomous agent
            const stockDatabase = {
                // Mega Cap
                'AAPL': 175.50, 'MSFT': 420.00, 'GOOGL': 2850.00, 'AMZN': 3400.00, 'NVDA': 880.00,
                'BRK.B': 450.00, 'TSLA': 250.00, 'META': 520.00, 'V': 280.00, 'JNJ': 165.00,

                // Large Cap Value
                'JPM': 185.00, 'BAC': 35.00, 'WMT': 165.00, 'PG': 155.00, 'KO': 62.00,
                'PEP': 175.00, 'HD': 340.00, 'UNH': 520.00, 'CVX': 158.00, 'XOM': 118.00,

                // Growth Leaders
                'AMD': 165.00, 'PLTR': 45.00, 'SNOW': 185.00, 'NET': 85.00, 'CRWD': 285.00,
                'ZS': 195.00, 'OKTA': 105.00, 'DDOG': 125.00, 'MDB': 410.00, 'CRM': 280.00,
                'NOW': 720.00, 'WDAY': 275.00, 'TEAM': 185.00, 'ZM': 75.00, 'DOCN': 65.00,
                'BILL': 95.00, 'S': 18.00, 'ESTC': 95.00,

                // Mid Cap Gems
                'RBLX': 45.00, 'PATH': 25.00, 'DKNG': 38.00, 'OPEN': 12.00, 'ABNB': 145.00,
                'UBER': 72.00, 'LYFT': 15.00, 'DASH': 125.00, 'COIN': 185.00, 'HOOD': 18.00,
                'SQ': 78.00, 'PYPL': 65.00, 'SHOP': 78.00, 'SPOT': 325.00, 'TTD': 95.00,
                'ROKU': 68.00, 'PINS': 28.00, 'SNAP': 15.00,

                // Small Cap Innovators
                'AI': 28.00, 'SMCI': 850.00, 'IONQ': 15.00, 'BBAI': 8.50, 'RGTI': 12.00,
                'QUBT': 15.00, 'AVAV': 185.00, 'KTOS': 28.00, 'IRDM': 12.00, 'MAXR': 8.50,
                'SPIR': 4.50, 'ASTR': 3.20, 'RKLB': 18.00, 'LUNR': 8.50, 'ASTS': 25.00,

                // Biotech Emerging
                'MRNA': 95.00, 'BNTX': 125.00, 'NVAX': 12.00, 'SGEN': 78.00, 'BMRN': 95.00,
                'VRTX': 435.00, 'ILMN': 145.00, 'REGN': 875.00, 'GILD': 78.00, 'BIIB': 275.00,
                'AMGN': 285.00, 'CELG': 125.00, 'INCY': 68.00, 'ALNY': 225.00, 'RARE': 32.00,

                // Fintech Disruptors
                'AFRM': 45.00, 'SOFI': 8.50, 'UPST': 45.00, 'LC': 12.00, 'NU': 12.00,
                'PAGS': 18.00, 'STNE': 15.00, 'MELI': 1850.00, 'SE': 85.00,

                // Clean Energy
                'ENPH': 125.00, 'SEDG': 85.00, 'RUN': 18.00, 'SPWR': 1.85, 'FSLR': 285.00,
                'PLUG': 3.50, 'BE': 2.25, 'NEE': 85.00, 'BEP': 28.00, 'AES': 15.00,
                'EIX': 78.00, 'DUK': 105.00,

                // Cybersecurity
                'PANW': 385.00, 'FTNT': 78.00, 'RPD': 28.00, 'CYBR': 285.00, 'FEYE': 45.00,
                'VRNS': 28.00, 'TENB': 45.00, 'QLYS': 125.00,

                // Robotics & AI
                'IRBT': 68.00, 'ROK': 285.00, 'ABB': 45.00,

                // International Growth
                'TSM': 125.00, 'ASML': 875.00, 'NVO': 125.00, 'TM': 185.00, 'SONY': 95.00,
                'SAP': 225.00, 'BABA': 95.00, 'JD': 45.00, 'PDD': 125.00, 'BIDU': 125.00,
                'NIO': 8.50, 'XPEV': 12.00, 'LI': 28.00,

                // Value-Growth Hybrid
                'MA': 485.00, 'COST': 875.00, 'LOW': 275.00, 'TGT': 155.00, 'DIS': 125.00,
                'NFLX': 485.00, 'ADBE': 585.00, 'INTU': 685.00, 'ORCL': 125.00, 'CSCO': 55.00,

                // Space Economy
                'LMT': 485.00, 'BA': 185.00, 'RTX': 125.00,

                // Quantum Computing
                'IBM': 185.00,

                // Gaming & Metaverse
                'U': 28.00, 'EA': 145.00, 'ATVI': 95.00, 'TTWO': 185.00
            };

            // Generate demo data with realistic market-like behavior
            const demoData = {};
            const marketTrend = (Math.random() - 0.5) * 2; // Overall market bias -1% to +1%

            Object.entries(stockDatabase).forEach(([symbol, basePrice]) => {
                // Combine overall market trend with individual stock movement
                const individualMove = (Math.random() - 0.5) * 6; // -3% to +3% individual
                const changePercent = marketTrend + individualMove;

                // Clamp to reasonable daily range
                const finalChange = Math.max(-8, Math.min(8, changePercent));
                const actualPrice = basePrice * (1 + finalChange / 100);

                demoData[symbol] = {
                    price: Math.round(actualPrice * 100) / 100,
                    change_percent: Math.round(finalChange * 100) / 100
                };
            });

            console.log('Demo data prepared:', demoData);

            try {
                displayPricesWithCategories(demoData);
                updateMoversMarquee(demoData);
                updateLastUpdated();
                addLogEntry(`Demo data loaded: ${Object.keys(demoData).length} symbols displayed`);

                if (!pricesInitialized) {
                    pricesInitialized = true;
                    // Check again in 2 minutes when using demo data
                    pricesUpdateInterval = setInterval(() => {
                        addLogEntry('Checking for real market data...');
                        fetchPricesData();
                    }, 120000);
                }
            } catch (error) {
                console.error('Error displaying demo data:', error);
                addLogEntry('Error displaying demo data');

                // Last resort - show simple message
                const grid = document.getElementById('realTimePricesGrid');
                safeSetHTML(grid, '<div class="log-entry">Market data temporarily unavailable</div>');
            }
        }

        // Generate ASCII pattern for skeleton loading animation
        function generateASCIIPattern(length) {
            const patterns = [
                '',  // Loading pattern 1
                '',  // Loading pattern 2
                '',  // Loading pattern 3
                '',  // Loading pattern 4
                '',  // Loading pattern 5
                '',  // Alternative pattern
                '',  // Mixed density
                ''   // Varied pattern
            ];

            // Select a random pattern and truncate/pad to desired length
            const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];

            if (selectedPattern.length >= length) {
                return selectedPattern.substring(0, length);
            } else {
                // Pad with lighter characters if needed
                return (selectedPattern + ''.repeat(length)).substring(0, length);
            }
        }

        // Animation for ASCII skeleton loaders
        let skeletonAnimationInterval = null;

        function startASCIISkeletonAnimation() {
            // Clear any existing animation
            if (skeletonAnimationInterval) {
                clearInterval(skeletonAnimationInterval);
            }

            const animationPatterns = [
                ['', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['>>>', '>>', '>', '', '', '', '', ''],
                ['', '', '', '', '', '', '', '']
            ];

            let currentFrame = 0;

            skeletonAnimationInterval = setInterval(() => {
                const skeletonElements = document.querySelectorAll('.skeleton-text');

                skeletonElements.forEach((element, index) => {
                    const patternSet = animationPatterns[index % animationPatterns.length];
                    const pattern = patternSet[currentFrame % patternSet.length];
                    const originalText = element.textContent;

                    // Only animate skeleton loaders, not real data
                    if (element.closest('.skeleton-loader')) {
                        // Replace numeric characters with animation pattern
                        let animatedText = originalText.replace(/[\d\.]/g, () => {
                            return pattern.charAt(Math.floor(Math.random() * pattern.length));
                        });

                        // For very short content, use full pattern
                        if (originalText.length <= 3) {
                            animatedText = pattern.substring(0, originalText.length);
                        }

                        element.textContent = animatedText;
                    }
                });

                currentFrame++;
            }, 300); // Animation speed
        }

        function stopASCIISkeletonAnimation() {
            if (skeletonAnimationInterval) {
                clearInterval(skeletonAnimationInterval);
                skeletonAnimationInterval = null;
            }
        }

        // Initialize category structure with skeleton loaders
        async function initializeCategorySkeleton() {
            const grid = document.getElementById('realTimePricesGrid');

            // Fetch trending symbols first
            let trendingSymbols = []; // No fallback symbols - show real data or loading state
            let trendingIsLoading = false;
            try {
                console.log(' Fetching trending symbols for skeleton...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout

                const response = await fetch('/api/trending_stocks', {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                const data = await response.json();
                if (data.success && data.trending_symbols && data.trending_symbols.length > 0) {
                    trendingSymbols = data.trending_symbols.map(item => item.symbol);
                    console.log(` Got ${trendingSymbols.length} trending symbols for skeleton:`, trendingSymbols.join(', '));
                } else if (data.message && data.message.includes('being generated')) {
                    // Show loading state when data is being generated
                    trendingIsLoading = true;
                    trendingSymbols = ['LOADING']; // Placeholder to show loading section
                    console.log(' Trending data is being generated - showing loading state');
                } else {
                    console.log(' No trending symbols available - will skip trending section');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log(' Trending API timeout (3s) - proceeding without trending data');
                } else {
                    console.error('Failed to fetch trending symbols for skeleton:', error);
                }
                console.log(' No trending symbols available - will skip trending section');
            }

            // Define categories that match our priority symbols
            const priorityCategories = {
                'Trending ': trendingSymbols, // Dynamic trending symbols
                'Mega Cap Tech': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA'],
                'Growth & SaaS': ['CRM', 'ADBE', 'NFLX', 'SPOT', 'SHOP', 'SNOW', 'PLTR'],
                'Financial Services': ['JPM', 'BAC', 'V', 'MA', 'PYPL', 'SQ'],
                'Consumer & Retail': ['KO', 'PEP', 'WMT', 'TGT', 'HD', 'LOW'],
                'Healthcare & Biotech': ['JNJ', 'UNH', 'PFE', 'MRNA', 'VRTX'],
                'Semiconductors': ['AMD', 'INTC', 'TSM', 'QCOM'],
                'Fintech & Crypto': ['COIN', 'HOOD', 'AFRM', 'SOFI'],
                'Cloud & Enterprise': ['NOW', 'TEAM', 'ZM', 'DDOG', 'CRWD']
            };

            let html = '';

            Object.entries(priorityCategories).forEach(([category, symbols]) => {
                // Skip empty categories (like trending when no data available)
                if (!symbols || symbols.length === 0) {
                    console.log(` Skipping empty category: ${category}`);
                    return;
                }

                html += `
                    <div class="category-section" id="category-${category.replace(/\s+/g, '-').toLowerCase()}">
                        <div class="category-title">${category}</div>
                        <div class="prices-grid">
                `;
                // Create skeleton loaders for expected symbols
                if (category === 'Trending ' && trendingIsLoading) {
                    // Special loading state for trending section with ASCII animation
                    html += `
                        <div class="price-item trending-loading-state" style="text-align: center; padding: var(--space-lg); opacity: 0.8;">
                            <div class="ascii-chart-loader" id="ascii-trending-chart">
                                <div class="chart-line">       </div>
                            </div>
                            <div style="margin-top: var(--space-sm); font-size: var(--text-caption-size); color: var(--color-text-secondary);">
                                Analyzing 580+ stocks...<br>
                                <small>This may take a few minutes</small>
                            </div>
                        </div>
                    `;
                } else {
                    symbols.forEach((symbol, index) => {
                        const animationDelay = index * 100; // Stagger the skeleton animation
                        const pricePattern = generateASCIIPattern(8);
                        const changePattern = generateASCIIPattern(6);
                        const mcapPattern = generateASCIIPattern(7);

                        html += `
                            <div class="price-item skeleton-loader" data-symbol="${symbol}" style="animation-delay: ${animationDelay}ms;">
                                <div class="price-symbol skeleton-text">${symbol}</div>
                                <div class="price-value skeleton-text">$${pricePattern}</div>
                                <div class="price-change-row">
                                    <div class="price-change skeleton-text">${changePattern}%</div>
                                    <div class="price-mcap skeleton-text">mcap ${mcapPattern}</div>
                                </div>
                            </div>
                        `;
                    });
                }

                html += '</div></div>';
            });

            safeSetHTML(grid, html);
            addLogEntry('Category structure loaded - waiting for market data...');

            // Start ASCII animation for skeleton loaders
            startASCIISkeletonAnimation();
        }

        // Fast individual skeleton update for immediate visual feedback
        function updateSkeletonWithRealData(symbol, data) {
            const element = document.querySelector(`[data-symbol="${symbol}"]`);
            if (!element || !element.classList.contains('skeleton-loader')) {
                return; // Not a skeleton or element not found
            }

            try {
                const price = data.price || data.current_price || 'N/A';
                const change = data.change_percent || data.percent_change ||
                          (data.fundamentals && data.fundamentals.regularMarketChangePercent) || 0;
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changeSymbol = change >= 0 ? '+' : '';
                const mcap = marketCapData[symbol];
                const mcapDisplay = mcap ? formatMarketCap(mcap) : 'N/A';

                // Update price value
                const priceEl = element.querySelector('.price-value');
                if (priceEl) {
                    priceEl.textContent = `$${typeof price === 'number' ? price.toFixed(2) : price}`;
                }

                // Update price change
                const changeEl = element.querySelector('.price-change');
                if (changeEl) {
                    changeEl.textContent = `${changeSymbol}${typeof change === 'number' ? change.toFixed(2) : change}%`;
                    changeEl.className = `price-change ${changeClass}`;
                }

                // Update market cap
                const mcapEl = element.querySelector('.price-mcap');
                if (mcapEl) {
                    mcapEl.textContent = `mcap ${mcapDisplay}`;
                }

                // Remove skeleton styling with smooth transition
                element.classList.add('loading-complete');
                setTimeout(() => {
                    element.classList.remove('skeleton-loader');
                    element.onclick = () => showStockDetail(symbol);
                    element.querySelectorAll('.skeleton-text').forEach(el => el.classList.remove('skeleton-text'));
                }, 100);

            } catch (error) {
                console.error(`Error updating skeleton for ${symbol}:`, error);
            }
        }

        // Real-time price update function for WebSocket data
        function updateRealtimePrice(symbol, price, changePercent, volume) {
            const elements = document.querySelectorAll(`[data-symbol="${symbol}"]`);

            elements.forEach(element => {
                try {
                    // Update price value
                    const priceEl = element.querySelector('.price-value');
                    if (priceEl) {
                        priceEl.textContent = `$${typeof price === 'number' ? price.toFixed(2) : price}`;

                        // Add subtle animation for real-time updates
                        priceEl.style.transition = 'all 0.3s ease';
                        priceEl.style.backgroundColor = changePercent >= 0 ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 68, 68, 0.1)';
                        setTimeout(() => {
                            priceEl.style.backgroundColor = '';
                        }, 1000);
                    }

                    // Update price change if available
                    if (typeof changePercent === 'number') {
                        const changeEl = element.querySelector('.price-change');
                        if (changeEl) {
                            const changeClass = changePercent >= 0 ? 'positive' : 'negative';
                            const changeSymbol = changePercent >= 0 ? '+' : '';
                            changeEl.textContent = `${changeSymbol}${changePercent.toFixed(2)}%`;
                            changeEl.className = `price-change ${changeClass}`;
                        }
                    }

                    // Update volume if available (in smaller text)
                    if (typeof volume === 'number') {
                        let volumeEl = element.querySelector('.price-volume');
                        if (!volumeEl) {
                            // Create volume element if it doesn't exist
                            const mcapEl = element.querySelector('.price-mcap');
                            if (mcapEl) {
                                volumeEl = document.createElement('div');
                                volumeEl.className = 'price-volume';
                                volumeEl.style.fontSize = '0.7rem';
                                volumeEl.style.opacity = '0.7';
                                mcapEl.parentNode.insertBefore(volumeEl, mcapEl.nextSibling);
                            }
                        }
                        if (volumeEl) {
                            volumeEl.textContent = `Vol: ${volume.toLocaleString()}`;
                        }
                    }

                    console.log(` Updated ${symbol}: $${price} (${changePercent}%)`);

                } catch (error) {
                    console.error(`Error updating real-time price for ${symbol}:`, error);
                }
            });
        }

        // Helper function to populate a single stock card with real data
        function populateStockCard(element, symbol, data) {
            console.log(`PopulateStockCard called for ${symbol}:`, element, data);

            const price = data.price || data.current_price || 'N/A';
            const change = data.change_percent || data.percent_change ||
                          (data.fundamentals && data.fundamentals.regularMarketChangePercent) || 0;
            const changeClass = change >= 0 ? 'positive' : 'negative';
            const changeSymbol = change >= 0 ? '+' : '';
            const mcap = marketCapData[symbol];
            const mcapDisplay = mcap ? `mcap ${formatMarketCap(mcap)}` : 'mcap N/A';

            console.log(`Processing ${symbol}: price=${price}, change=${change}, mcap=${mcapDisplay}`);

            // Remove skeleton classes and add real data
            element.classList.remove('skeleton-loader');
            element.onclick = () => showStockDetail(symbol);
            element.setAttribute('data-symbol', symbol);

            // Reset opacity and visibility
            element.style.opacity = '1';
            element.style.visibility = 'visible';

            // Stop animation for this element
            const skeletonTexts = element.querySelectorAll('.skeleton-text');
            skeletonTexts.forEach(el => el.classList.remove('skeleton-text'));

            console.log(`About to set innerHTML for ${symbol}`);

            safeSetHTML(element, `
                <div class="price-symbol">${symbol}</div>
                <div class="price-value">$${typeof price === 'number' ? price.toFixed(2) : price}</div>
                <div class="price-change-row">
                    <div class="price-change ${changeClass}">${changeSymbol}${typeof change === 'number' ? change.toFixed(2) : change}%</div>
                    <div class="price-mcap">${mcapDisplay}</div>
                </div>
            `);

            // Add a subtle animation to indicate data loaded
            element.style.animation = 'dataLoaded 0.5s ease-out';

            console.log(`Completed populating ${symbol}, element now contains:`, element.innerHTML);
        }

        function createStockElement(symbol, data) {
            console.log(`Creating new element for ${symbol}`);

            const element = document.createElement('div');
            element.className = 'price-item';
            element.setAttribute('data-symbol', symbol);
            element.style.opacity = '0';
            element.style.visibility = 'hidden';

            // Use the same structure as existing stock cards
            const changePercent = data.change_percent || data.percent_change ||
                                  (data.fundamentals && data.fundamentals.regularMarketChangePercent) || 0;
            const price = data.price || 0;
            const marketCap = formatMarketCapFromData(data);
            const changeClass = changePercent >= 0 ? 'positive' : 'negative';
            const changeSymbol = changePercent >= 0 ? '+' : '';

            safeSetHTML(element, `
                <div class="price-symbol">${symbol}</div>
                <div class="price-value">$${price.toFixed(2)}</div>
                <div class="price-change-row">
                    <div class="price-change ${changeClass}">${changeSymbol}${(Math.abs(changePercent) * 100).toFixed(2)}%</div>
                    <div class="price-mcap">${marketCap}</div>
                </div>
            `);

            // Add click handler for stock details
            element.addEventListener('click', () => showStockDetail(symbol));

            // Animate in
            setTimeout(() => {
                element.style.opacity = '1';
                element.style.visibility = 'visible';
                element.style.animation = '0.5s ease-out 0s 1 normal none running dataLoaded';
            }, 100);

            return element;
        }

        function formatMarketCapFromData(data) {
            if (data.market_cap && data.market_cap !== null) {
                return formatMarketCap(data.market_cap);
            }

            // Fallback market cap calculation or placeholder
            const price = data.price || 0;
            if (price > 500) return "mcap $2.8T";
            if (price > 200) return "mcap $1.6T";
            if (price > 100) return "mcap $850B";
            return "mcap $500B";
        }

        function displayPricesWithCategories(prices) {
            const grid = document.getElementById('realTimePricesGrid');

            if (Object.keys(prices).length === 0) {
                // Don't replace skeleton if no data - keep loading state
                return;
            }

            // Try to populate existing skeleton loaders first
            console.log('displayPricesWithCategories called with symbols:', Object.keys(prices));

            const processedSymbols = new Set();

            Object.entries(prices).forEach(([symbol, data]) => {
                const existingElement = grid.querySelector(`[data-symbol="${symbol}"]`);
                console.log(`Looking for skeleton for ${symbol}:`, existingElement ? 'FOUND' : 'NOT FOUND');
                if (existingElement) {
                    console.log(`Populating ${symbol} with data:`, data);
                    // Replace skeleton with real data
                    populateStockCard(existingElement, symbol, data);
                    processedSymbols.add(symbol);
                } else {
                    console.log(` No skeleton found for ${symbol}, checking if it belongs to a category...`);
                    console.log(` Current DOM has ${grid.querySelectorAll('[data-symbol]').length} stock elements total`);

                    // Find which category this symbol belongs to and ensure it gets displayed
                    const categoryMapping = {
                        'Mega Cap Tech': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA'],
                        'Growth & SaaS': ['CRM', 'ADBE', 'NFLX', 'SPOT', 'SHOP', 'SNOW', 'PLTR'],
                        'Financial Services': ['JPM', 'BAC', 'V', 'MA', 'PYPL', 'SQ'],
                        'Consumer & Retail': ['KO', 'PEP', 'WMT', 'TGT', 'HD', 'LOW'],
                        'Healthcare & Biotech': ['JNJ', 'UNH', 'PFE', 'MRNA', 'VRTX'],
                        'Semiconductors': ['AMD', 'INTC', 'TSM', 'QCOM'],
                        'Fintech & Crypto': ['COIN', 'HOOD', 'AFRM', 'SOFI'],
                        'Cloud & Enterprise': ['NOW', 'TEAM', 'ZM', 'DDOG', 'CRWD']
                    };

                    let foundCategory = null;
                    for (const [category, symbols] of Object.entries(categoryMapping)) {
                        if (symbols.includes(symbol)) {
                            foundCategory = category;
                            break;
                        }
                    }

                    console.log(`Category lookup for ${symbol}: ${foundCategory ? foundCategory : 'NOT FOUND'}`);

                    if (foundCategory) {
                        console.log(`${symbol} belongs to category: ${foundCategory}, attempting to display...`);
                        // Find the category section and add the stock there
                        const categoryId = `category-${foundCategory.replace(/\s+/g, '-').toLowerCase()}`;
                        const categorySection = grid.querySelector(`#${categoryId}`);

                        console.log(`Looking for category section: #${categoryId}`, categorySection ? 'FOUND' : 'NOT FOUND');

                        if (categorySection) {
                            const pricesGrid = categorySection.querySelector('.prices-grid');
                            console.log(`Found prices-grid in category:`, pricesGrid ? 'YES' : 'NO');

                            if (pricesGrid) {
                                // Check if element already exists in this category
                                const existingInCategory = pricesGrid.querySelector(`[data-symbol="${symbol}"]`);
                                if (existingInCategory) {
                                    console.log(`Found existing element for ${symbol} in category, populating...`);
                                    populateStockCard(existingInCategory, symbol, data);
                                    processedSymbols.add(symbol);
                                } else {
                                    console.log(`Creating new element for ${symbol} in ${foundCategory} category...`);
                                    // Create new stock element and populate it
                                    const newElement = createStockElement(symbol, data);
                                    pricesGrid.appendChild(newElement);
                                    processedSymbols.add(symbol);
                                }
                            }
                        } else {
                            // Category section doesn't exist, let's try to create it or handle this case
                            console.log(` Category section not found for ${symbol}. Available sections:`,
                                Array.from(grid.querySelectorAll('[id^="category-"]')).map(el => el.id));
                        }
                    } else {
                        console.log(` ${symbol} doesn't match any known category`);
                    }
                }
            });

            console.log(`Successfully processed ${processedSymbols.size} symbols:`, Array.from(processedSymbols));

            // If no skeleton structure exists or we have unprocessed symbols, fall back to original behavior
            const unprocessedSymbols = Object.keys(prices).filter(symbol => !processedSymbols.has(symbol));
            if (!grid.querySelector('.skeleton-loader') || unprocessedSymbols.length > 0) {
                if (unprocessedSymbols.length > 0) {
                    console.log(`Found ${unprocessedSymbols.length} symbols without skeletons: ${unprocessedSymbols.join(', ')}`);
                    console.log('Adding unprocessed symbols to existing display');

                    // Instead of rebuilding entire grid, just append missing symbols
                    unprocessedSymbols.forEach(symbol => {
                        const symbolData = prices[symbol];

                        // Create a simple stock card for the unprocessed symbol
                        const stockCard = document.createElement('div');
                        stockCard.className = 'price-item';
                        stockCard.setAttribute('data-symbol', symbol);

                        // Determine the price and change
                        const price = symbolData.current_price || symbolData.price || symbolData.regularMarketPrice || 'N/A';
                        const change = symbolData.change_percent || symbolData.percent_change ||
                                      (symbolData.fundamentals && symbolData.fundamentals.regularMarketChangePercent) || 0;
                        const changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
                        const changePercent = (Math.abs(change) * 100).toFixed(2);
                        const changeSign = change > 0 ? '+' : change < 0 ? '-' : '';

                        // Get market cap
                        const mcap = formatMarketCapFromData(symbolData);

                        safeSetHTML(stockCard, `
                            <div class="price-symbol">${symbol}</div>
                            <div class="price-value">$${typeof price === 'number' ? price.toFixed(2) : price}</div>
                            <div class="price-change-row">
                                <div class="price-change ${changeClass}">${changeSign}${changePercent}%</div>
                                <div class="price-mcap">${mcap}</div>
                            </div>
                        `);

                        // Find the best category section to append to
                        let targetSection = null;

                        // First try to find "Other Symbols" section
                        const categoryTitles = grid.querySelectorAll('.category-title');
                        categoryTitles.forEach(title => {
                            if (title.textContent.includes('Other Symbols')) {
                                targetSection = title.parentElement.querySelector('.prices-grid');
                            }
                        });

                        // If no "Other Symbols" section, create one
                        if (!targetSection) {
                            const otherSection = document.createElement('div');
                            otherSection.className = 'category-section';
                            safeSetHTML(otherSection, `
                                <div class="category-title">Other Symbols</div>
                                <div class="prices-grid"></div>
                            `);
                            grid.appendChild(otherSection);
                            targetSection = otherSection.querySelector('.prices-grid');
                        }

                        // Add the symbol to the target section
                        targetSection.appendChild(stockCard);

                        console.log(` Added ${symbol} to Other Symbols section`);
                    });
                } else {
                    console.log('No skeleton structure found, falling back to original behavior');
                    // Original function logic as fallback
                    displayPricesWithCategoriesFallback(prices);
                }
                return;
            }
        }

        // Fallback function with original logic for when skeleton structure isn't available
        // Function to fetch trending stocks
        async function fetchTrendingStocks() {
            try {
                console.log(' Fetching trending stocks...');
                const response = await fetch('/api/trending_stocks');
                const data = await response.json();

                if (data.success && data.trending_symbols && data.trending_symbols.length > 0) {
                    const trendingSymbols = data.trending_symbols.map(item => item.symbol);
                    console.log(` Got ${trendingSymbols.length} trending stocks:`, trendingSymbols.join(', '));
                    return trendingSymbols;
                } else {
                    console.log(' No trending stocks available');
                    return [];
                }
            } catch (error) {
                console.error(' Error fetching trending stocks:', error);
                return [];
            }
        }

        // Function to fetch and display enhanced watchlist data
        async function fetchWatchlist() {
            try {
                const response = await fetch('/api/enhanced-watchlist');
                const data = await response.json();

                if (data.entries) {
                    updateWatchlistTable(data.entries, data.summary);
                }
            } catch (error) {
                console.error(' Error fetching watchlist:', error);
            }
        }

        // Function to update the enhanced watchlist table
        function updateWatchlistTable(watchlistData, summary) {
            const tableBody = document.getElementById('watchlistTableBody');
            if (!tableBody) return;

            if (!watchlistData || watchlistData.length === 0) {
                safeSetHTML(tableBody, '<tr><td colspan="7" class="text-dim">Agents will populate watchlist with trading opportunities...</td></tr>');
                return;
            }

            const rows = watchlistData.map(entry => {
                const confidenceColor = entry.confidence > 0.7 ? 'var(--color-success)' : entry.confidence > 0.5 ? 'var(--color-warning)' : 'var(--color-background)';
                const confidenceDisplay = entry.confidence ? `${(entry.confidence * 100).toFixed(0)}%` : 'N/A';
                const priorityColor = entry.priority > 70 ? 'var(--color-success)' : entry.priority > 40 ? 'var(--color-warning)' : 'var(--color-error)';
                const statusColor = entry.status === 'active' ? 'var(--color-success)' : 'var(--color-warning)';

                // Truncate long reasons
                const reasonDisplay = entry.reason && entry.reason.length > 30 ? entry.reason.substring(0, 30) + '...' : (entry.reason || 'N/A');

                return `
                    <tr title="${entry.reason || ''}${entry.notes ? ' - ' + entry.notes : ''}">
                        <td class="symbol-cell"><strong>${entry.symbol}</strong></td>
                        <td class="submitter-cell">${entry.submitterDisplayName || entry.submitter}</td>
                        <td class="reason-cell" title="${entry.reason || ''}">${reasonDisplay}</td>
                        <td style="color: ${confidenceColor}">${confidenceDisplay}</td>
                        <td style="color: ${priorityColor}">${entry.priority || 0}</td>
                        <td class="status-cell" style="color: ${statusColor}">${(entry.status || 'active').toUpperCase()}</td>
                        <td class="delete-cell">
                            <span class="delete-btn" onclick="deleteWatchlistEntry('${entry.symbol}', '${entry.submitter}')" title="Remove from watchlist">Delete</span>
                        </td>
                    </tr>
                `;
            }).join('');

            safeSetHTML(tableBody, rows);

            // Update watchlist summary if available
            if (summary) {
                updateWatchlistSummary(summary);
            }
        }

        // Function to update watchlist summary (new)
        function updateWatchlistSummary(summary) {
            // Could add a summary display area in the future
            console.log(' Watchlist Summary:', summary);
        }

        // Function to delete watchlist entry
        async function deleteWatchlistEntry(symbol, submitter) {
            try {
                const response = await fetch('/api/enhanced-watchlist/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        submitter: submitter
                    })
                });

                const result = await response.json();

                if (result.success) {
                    console.log(` Removed ${symbol} from watchlist`);
                    // Refresh the watchlist to show updated data
                    fetchWatchlist();
                } else {
                    console.error(' Failed to remove entry:', result.error);
                }
            } catch (error) {
                console.error(' Error deleting watchlist entry:', error);
            }
        }

        async function displayPricesWithCategoriesFallback(prices) {
            const grid = document.getElementById('realTimePricesGrid');

            // Fetch trending stocks and update categories
            const trendingSymbols = await fetchTrendingStocks();

            // Define comprehensive categories matching autonomous agent
            const categories = {
                'Trending ': trendingSymbols, // Populated dynamically from StockTwits API
                'Mega Cap': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'BRK.B', 'TSLA', 'META', 'V', 'JNJ'],
                'Large Cap Value': ['JPM', 'BAC', 'WMT', 'PG', 'KO', 'PEP', 'HD', 'UNH', 'CVX', 'XOM'],
                'Growth Leaders': ['AMD', 'PLTR', 'SNOW', 'NET', 'CRWD', 'ZS', 'OKTA', 'DDOG', 'MDB', 'CRM', 'NOW', 'WDAY', 'TEAM', 'ZM', 'DOCN', 'BILL', 'S', 'ESTC'],
                'Mid Cap Gems': ['RBLX', 'PATH', 'DKNG', 'OPEN', 'ABNB', 'UBER', 'LYFT', 'DASH', 'SQ', 'PYPL', 'SHOP', 'SPOT', 'TTD', 'ROKU', 'PINS', 'SNAP'],
                'Small Cap Innovators': ['AI', 'SMCI', 'IONQ', 'BBAI', 'RGTI', 'QUBT', 'AVAV', 'KTOS', 'IRDM', 'MAXR', 'SPIR', 'ASTR', 'RKLB', 'LUNR', 'ASTS'],
                'Semiconductors': ['AMD', 'INTC', 'TSM', 'QCOM'],
                'Fintech & Crypto': ['COIN', 'HOOD', 'AFRM', 'SOFI'],
                'Biotech Emerging': ['MRNA', 'BNTX', 'NVAX', 'SGEN', 'BMRN', 'VRTX', 'ILMN', 'REGN', 'GILD', 'BIIB', 'AMGN', 'CELG', 'INCY', 'ALNY', 'RARE'],
                'Fintech Disruptors': ['UPST', 'LC', 'NU', 'PAGS', 'STNE', 'MELI', 'SE'],
                'Clean Energy': ['ENPH', 'SEDG', 'RUN', 'SPWR', 'FSLR', 'PLUG', 'BE', 'NEE', 'BEP', 'AES', 'EIX', 'DUK'],
                'Cybersecurity': ['PANW', 'FTNT', 'RPD', 'CYBR', 'FEYE', 'VRNS', 'TENB', 'QLYS'],
                'Robotics & AI': ['IRBT', 'ROK', 'ABB'],
                'International Growth': ['TSM', 'ASML', 'NVO', 'TM', 'SONY', 'SAP', 'BABA', 'JD', 'PDD', 'BIDU', 'NIO', 'XPEV', 'LI'],
                'Value-Growth Hybrid': ['MA', 'COST', 'LOW', 'TGT', 'DIS', 'NFLX', 'ADBE', 'INTU', 'ORCL', 'CSCO'],
                'Space Economy': ['LMT', 'BA', 'RTX'],
                'Quantum Computing': ['IBM'],
                'Gaming & Metaverse': ['U', 'EA', 'ATVI', 'TTWO']
            };

            let html = '';
            let itemIndex = 0; // Counter for animation delay

            Object.entries(categories).forEach(([category, symbols]) => {
                const categoryPrices = {};
                symbols.forEach(symbol => {
                    if (prices[symbol]) {
                        categoryPrices[symbol] = prices[symbol];
                    }
                });

                if (Object.keys(categoryPrices).length > 0) {
                    html += `
                        <div class="category-section">
                            <div class="category-title">${category}</div>
                            <div class="prices-grid">
                    `;
                    Object.entries(categoryPrices).forEach(([symbol, data]) => {
                        const price = data.price || data.current_price || 'N/A';
                        const change = data.change_percent || data.percent_change ||
                          (data.fundamentals && data.fundamentals.regularMarketChangePercent) || 0;
                        const changeClass = change >= 0 ? 'positive' : 'negative';
                        const changeSymbol = change >= 0 ? '+' : '';

                        const animationDelay = itemIndex * 50; // 50ms delay per item
                        const mcap = marketCapData[symbol];
                        const mcapDisplay = mcap ? `mcap ${formatMarketCap(mcap)}` : 'mcap N/A';

                        html += `
                            <div class="price-item" style="animation-delay: ${animationDelay}ms;" onclick="showStockDetail('${symbol}')">
                                <div class="price-symbol">${symbol}</div>
                                <div class="price-value">$${typeof price === 'number' ? price.toFixed(2) : price}</div>
                                <div class="price-change-row">
                                    <div class="price-change ${changeClass}">${changeSymbol}${typeof change === 'number' ? change.toFixed(2) : change}%</div>
                                    <div class="price-mcap">${mcapDisplay}</div>
                                </div>
                            </div>
                        `;
                        itemIndex++;
                    });

                    html += '</div></div>';
                }
            });

            // Add any remaining symbols not in categories
            const uncategorizedPrices = {};
            Object.keys(prices).forEach(symbol => {
                let found = false;
                Object.values(categories).forEach(categorySymbols => {
                    if (categorySymbols.includes(symbol)) found = true;
                });
                if (!found) {
                    uncategorizedPrices[symbol] = prices[symbol];
                }
            });

            if (Object.keys(uncategorizedPrices).length > 0) {
                html += `
                    <div class="category-section">
                        <div class="category-title">Other Symbols</div>
                        <div class="prices-grid">
                `;
                Object.entries(uncategorizedPrices).forEach(([symbol, data]) => {
                    const price = data.price || data.current_price || 'N/A';
                    const change = data.change_percent || data.percent_change ||
                          (data.fundamentals && data.fundamentals.regularMarketChangePercent) || 0;
                    const changeClass = change >= 0 ? 'positive' : 'negative';
                    const changeSymbol = change >= 0 ? '+' : '';

                    const animationDelay = itemIndex * 50; // 50ms delay per item
                    const mcap = marketCapData[symbol];
                    const mcapDisplay = mcap ? `mcap ${formatMarketCap(mcap)}` : 'mcap N/A';

                    html += `
                        <div class="price-item" style="animation-delay: ${animationDelay}ms;" onclick="showStockDetail('${symbol}')">
                            <div class="price-symbol">${symbol}</div>
                            <div class="price-value">$${typeof price === 'number' ? price.toFixed(2) : price}</div>
                            <div class="price-change-row">
                                <div class="price-change ${changeClass}">${changeSymbol}${typeof change === 'number' ? change.toFixed(2) : change}%</div>
                                <div class="price-mcap">${mcapDisplay}</div>
                            </div>
                        </div>
                    `;
                    itemIndex++;
                });

                html += '</div></div>';
            }

            safeSetHTML(grid, html);
        }

        // Keep old function for backward compatibility
        function displayPrices(prices) {
            displayPricesWithCategories(prices);
            updateMoversMarquee(prices);
        }

        function updateLastUpdated() {
            const timestamp = new Date().toLocaleTimeString();
            document.getElementById('pricesLastUpdated').textContent = `Last updated: ${timestamp}`;
        }

        // Market cap database (approximate values in millions USD)
        const marketCapData = {
            // Mega Cap
            'AAPL': 2800000, 'MSFT': 2750000, 'GOOGL': 1650000, 'AMZN': 1550000, 'NVDA': 1750000,
            'BRK.B': 750000, 'TSLA': 800000, 'META': 850000, 'V': 520000, 'JNJ': 450000,

            // Large Cap Value
            'JPM': 485000, 'BAC': 280000, 'WMT': 485000, 'PG': 385000, 'KO': 260000,
            'PEP': 235000, 'HD': 340000, 'UNH': 485000, 'CVX': 315000, 'XOM': 485000,

            // Growth Leaders
            'AMD': 235000, 'PLTR': 65000, 'SNOW': 52000, 'NET': 28000, 'CRWD': 65000,
            'ZS': 28000, 'OKTA': 18000, 'DDOG': 28000, 'MDB': 28000, 'CRM': 235000,
            'NOW': 135000, 'WDAY': 62000, 'TEAM': 42000, 'ZM': 18000, 'DOCN': 6500,
            'BILL': 8500, 'S': 18000, 'ESTC': 8500,

            // Mid Cap Gems
            'RBLX': 28000, 'PATH': 3500, 'DKNG': 18000, 'OPEN': 2800, 'ABNB': 85000,
            'UBER': 135000, 'LYFT': 6500, 'DASH': 52000, 'COIN': 42000, 'HOOD': 18000,
            'SQ': 62000, 'PYPL': 85000, 'SHOP': 85000, 'SPOT': 28000, 'TTD': 42000,
            'ROKU': 6500, 'PINS': 18000, 'SNAP': 18000,

            // Small Cap Innovators
            'AI': 2800, 'SMCI': 28000, 'IONQ': 1800, 'BBAI': 850, 'RGTI': 350,
            'QUBT': 180, 'AVAV': 6500, 'KTOS': 2800, 'IRDM': 3500, 'MAXR': 2800,
            'SPIR': 850, 'ASTR': 350, 'RKLB': 3500, 'LUNR': 850, 'ASTS': 1800,

            // Biotech Emerging
            'MRNA': 52000, 'BNTX': 28000, 'NVAX': 3500, 'SGEN': 18000, 'BMRN': 18000,
            'VRTX': 135000, 'ILMN': 28000, 'REGN': 85000, 'GILD': 85000, 'BIIB': 42000,
            'AMGN': 135000, 'CELG': 85000, 'INCY': 18000, 'ALNY': 28000, 'RARE': 6500,

            // Fintech Disruptors
            'AFRM': 8500, 'SOFI': 6500, 'UPST': 2800, 'LC': 850, 'NU': 52000,
            'PAGS': 8500, 'STNE': 18000, 'MELI': 85000, 'SE': 135000,

            // Clean Energy
            'ENPH': 18000, 'SEDG': 3500, 'RUN': 2800, 'SPWR': 850, 'FSLR': 8500,
            'PLUG': 6500, 'BE': 2800, 'NEE': 185000, 'BEP': 28000, 'AES': 18000,
            'EIX': 28000, 'DUK': 85000,

            // Cybersecurity
            'PANW': 105000, 'FTNT': 52000, 'RPD': 6500, 'CYBR': 6500, 'FEYE': 3500,
            'VRNS': 18000, 'TENB': 6500, 'QLYS': 6500,

            // Robotics & AI
            'IRBT': 1800, 'ROK': 85000, 'ABB': 62000,

            // International Growth
            'TSM': 485000, 'ASML': 285000, 'NVO': 485000, 'TM': 235000, 'SONY': 135000,
            'SAP': 185000, 'BABA': 235000, 'JD': 52000, 'PDD': 185000, 'BIDU': 42000,
            'NIO': 18000, 'XPEV': 8500, 'LI': 28000,

            // Value-Growth Hybrid
            'MA': 385000, 'COST': 285000, 'LOW': 135000, 'TGT': 62000, 'DIS': 185000,
            'NFLX': 185000, 'ADBE': 235000, 'INTU': 135000, 'ORCL': 285000, 'CSCO': 235000,

            // Space Economy
            'LMT': 105000, 'BA': 135000, 'RTX': 135000,

            // Quantum Computing
            'IBM': 135000,

            // Gaming & Metaverse
            'U': 6500, 'EA': 42000, 'ATVI': 62000, 'TTWO': 18000
        };

        function formatMarketCap(mcapInMillions) {
            if (!mcapInMillions) return 'N/A';

            if (mcapInMillions >= 1000000) {
                // Trillions
                return '$' + (mcapInMillions / 1000000).toFixed(1) + 'T';
            } else if (mcapInMillions >= 1000) {
                // Billions
                return '$' + (mcapInMillions / 1000).toFixed(0) + 'B';
            } else {
                // Millions
                return '$' + mcapInMillions.toFixed(0) + 'M';
            }
        }

        async function updateMoversMarquee() {
            const marquee = document.getElementById('moversMarquee');

            try {
                // Fetch marquee data from our new API
                const response = await fetch('/api/marquee_data');
                const data = await response.json();

                if (!data.success || !data.data || data.data.length === 0) {
                    safeSetHTML(marquee, '<span class="mover-item"><span class="mover-symbol">Loading market data...</span></span>');
                    marquee.classList.remove('animated');
                    return;
                }

                // Create marquee content from API data
                let marqueeItem = '';
                data.data.forEach(item => {
                    if (item.symbol === 'EVENT') {
                        // Economic calendar events
                        marqueeItem += `
                            <span class="mover-item">
                                <span class="mover-symbol">${item.name}</span>
                                <span class="mover-symbol" style="color: var(--color-warning);">${item.price}</span>
                            </span>
                        `;
                    } else {
                        // Market data
                        const changeClass = item.direction === 'up' ? 'positive' : item.direction === 'down' ? 'negative' : 'neutral';
                        const changeSymbol = item.change_pct >= 0 ? '+' : '';
                        const formattedChange = item.change_pct.toFixed(2);
                        const arrow = item.direction === 'up' ? '' : item.direction === 'down' ? '' : '';

                        marqueeItem += `
                            <span class="mover-item">
                                <span class="mover-symbol">${item.name}</span>
                                <span class="mover-price">${item.price}</span>
                                <span class="mover-change ${changeClass}">${arrow}${changeSymbol}${formattedChange}%</span>
                            </span>
                        `;
                    }
                });

                // Duplicate the content for seamless looping
                safeSetHTML(marquee, marqueeItem + marqueeItem);

                // Start animation
                marquee.classList.add('animated');

            } catch (error) {
                console.error('Error updating marquee:', error);
                safeSetHTML(marquee, '<span class="mover-item"><span class="mover-symbol">Market data unavailable</span></span>');
                marquee.classList.remove('animated');
            }
        }

        // Initialize the system
        function initialize() {
            updateStatus('OFFLINE');
            updateAutonomousStatus('UNKNOWN');

            // Initialize chart
            initializeChart();

            // Initialize marquee
            updateMoversMarquee();

            // Set up periodic updates - DISABLED: Portfolio data now refreshed via SSE
            // The old periodic updateMetrics() was causing conflicting polling with SSE
            // Portfolio updates are now handled through real-time SSE streaming instead

            // Set up trending data refresh (check every 30 seconds) - Using ResourceManager
            resources.addInterval(() => {
                if (systemInitialized) {
                    checkAndUpdateTrending();
                }
            }, 30000);

            // Set up marquee data refresh (check every 30 seconds) - Using ResourceManager
            resources.addInterval(() => {
                updateMoversMarquee();
            }, 30000);

            // Set up watchlist updates (every 15 seconds) - Using ResourceManager
            resources.addInterval(() => {
                if (systemInitialized) {
                    fetchWatchlist();
                }
            }, 15000);

            // Load options data immediately on page load
            refreshOptionsData();

            // Set up options data refresh (every 30 seconds) - Using ResourceManager
            resources.addInterval(() => {
                refreshOptionsData();
            }, 30000);

            // Load agent analysis immediately on page load
            refreshAgentAnalysis();

            // Set up agent analysis refresh (every 60 seconds) - Using ResourceManager
            resources.addInterval(() => {
                refreshAgentAnalysis();
            }, 60000);

            // Load Dough Report immediately on page load
            refreshDoughReport();

            // Set up Dough Report refresh (every 5 minutes) - Using ResourceManager
            resources.addInterval(() => {
                refreshDoughReport();
            }, 300000);

            // Initial watchlist fetch
            setTimeout(() => {
                fetchWatchlist();
            }, 2000);

            addLogEntry('Terminal initialized - ready for operation');

            // Start ASCII trending chart animation
            startASCIITrendingAnimation();
        }

        // ASCII Trending Chart Animation
        function startASCIITrendingAnimation() {
            const chartPatterns = [
                "       ",
                "       ",
                "       ",
                "       ",
                "       ",
                "       "
            ];

            let currentPatternIndex = 0;

            setInterval(() => {
                const chartElement = document.querySelector('#ascii-trending-chart .chart-line');
                if (chartElement) {
                    chartElement.textContent = chartPatterns[currentPatternIndex];
                    currentPatternIndex = (currentPatternIndex + 1) % chartPatterns.length;
                    // Force white color override
                    chartElement.style.setProperty('color', '#FFFFFF', 'important');
                }
            }, 800); // Change pattern every 800ms
        }

        // Function to check and update trending section
        async function checkAndUpdateTrending() {
            try {
                const response = await fetch('/api/trending_stocks');
                const data = await response.json();

                if (data.success && data.trending_symbols && data.trending_symbols.length > 0) {
                    // We have trending data! Replace the loading state
                    const trendingSection = document.querySelector('#category-trending-');
                    if (trendingSection && trendingSection.querySelector('.trending-loading-state')) {
                        console.log(' Trending data ready! Updating section with real data...');

                        // Rebuild the trending section with real data
                        const pricesGrid = trendingSection.querySelector('.prices-grid');
                        let html = '';

                        data.trending_symbols.forEach((item, index) => {
                            const animationDelay = index * 100;
                            const pricePattern = generateASCIIPattern(8);
                            const changePattern = generateASCIIPattern(6);
                            const mcapPattern = generateASCIIPattern(7);

                            html += `
                                <div class="price-item skeleton-loader" data-symbol="${item.symbol}" style="animation-delay: ${animationDelay}ms;">
                                    <div class="price-symbol skeleton-text">${item.symbol}</div>
                                    <div class="price-value skeleton-text">$${pricePattern}</div>
                                    <div class="price-change-row">
                                        <div class="price-change skeleton-text">${changePattern}%</div>
                                        <div class="price-mcap skeleton-text">mcap ${mcapPattern}</div>
                                    </div>
                                </div>
                            `;
                        });

                        safeSetHTML(pricesGrid, html);
                        addLogEntry(` Trending section updated with ${data.trending_symbols.length} stocks`);

                        // Trigger immediate data fetch for trending symbols
                        const trendingSymbols = data.trending_symbols.map(item => item.symbol);
                        // Use enhanced bulk API for trending symbols
                        fetch(`/api/enhanced/bulk_prices?symbols=${trendingSymbols.join(',')}`)
                            .then(response => response.json())
                            .then(data => {
                                if (data && data.prices) {
                                    console.log(` Enhanced trending update: ${Object.keys(data.prices).length} symbols`);
                                    displayPricesWithCategories(data.prices);
                                }
                            })
                            .catch(error => console.error(' Enhanced trending update failed:', error));
                    }
                }
            } catch (error) {
                console.error('Error checking trending data:', error);
            }
        }

        let agentStatusEventSource;
        let agentStatusInterval;
        let statusWatchdogInterval;
        let consecutiveErrors = 0;
        let lastSuccessfulStatusTime = Date.now();

        function startAgentStatusPolling() {
            // Stop any existing polling/streaming first
            if (agentStatusEventSource) {
                agentStatusEventSource.close();
            }
            if (agentStatusInterval) {
                clearInterval(agentStatusInterval);
            }
            if (statusWatchdogInterval) {
                clearInterval(statusWatchdogInterval);
            }

            // Reset error counters
            consecutiveErrors = 0;
            lastSuccessfulStatusTime = Date.now();

            // Initial status message - only show if not already connected
            if (!agentStatusEventSource || agentStatusEventSource.readyState !== EventSource.OPEN) {
                addAgentStatus('Connecting to real-time agent stream...', 'info');
            }

            // Start SSE connection for real-time agent output
            startAgentSSEStream();
        }

        // Enhanced EventSource connection management with robust reconnection
        let connectionWatchdog;
        let heartbeatTimeout;
        let connectionStartTime;
        let isManuallyDisconnected = false;

        function startAgentSSEStream() {
            console.log(' Starting enhanced SSE connection...');

            // Close existing connections and clear timers
            if (agentStatusEventSource) {
                agentStatusEventSource.close();
            }
            clearInterval(connectionWatchdog);
            clearTimeout(heartbeatTimeout);

            // Reset connection state
            isManuallyDisconnected = false;
            connectionStartTime = Date.now();

            try {
                // Use ResourceManager to track EventSource and prevent memory leaks
                agentStatusEventSource = resources.addEventSource('/api/agent_stream');

                agentStatusEventSource.onopen = function(event) {
                    console.log(' SSE connection established successfully');
                    consecutiveErrors = 0;
                    lastSuccessfulStatusTime = Date.now();

                    // Start connection monitoring
                    startConnectionWatchdog();

                    // Only show connection message on first connect
                    if (Date.now() - connectionStartTime < 5000) {
                        addAgentStatus(' Real-time agent stream connected with enhanced reliability', 'success');
                    }
                };

                agentStatusEventSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);

                        // Update last successful time and reset heartbeat timeout
                        lastSuccessfulStatusTime = Date.now();
                        consecutiveErrors = 0;
                        resetHeartbeatTimeout();

                        // Skip heartbeat messages from displaying in terminal but process them
                        if (data.type === 'heartbeat') {
                            console.log(' Heartbeat received - connection alive');
                            return;
                        }

                        // Add the real-time message to the terminal
                        const timestamp = new Date(data.timestamp).toLocaleTimeString();
                        let statusType = 'info';

                        // Color code based on message type
                        if (data.type === 'trade' || data.type === 'buy') {
                            statusType = 'success';
                        } else if (data.type === 'sell') {
                            statusType = 'warning';
                        } else if (data.type === 'error') {
                            statusType = 'error';
                        } else if (data.type === 'system') {
                            statusType = 'info';
                        }

                        addAgentStatus(data.message, statusType);

                        // Update autonomous status to running when we receive real data
                        updateAutonomousStatus('RUNNING');

                    } catch (error) {
                        console.error('Error parsing SSE data:', error);
                    }
                };

                agentStatusEventSource.onerror = function(event) {
                    console.error(' SSE connection error:', event);

                    // Clear monitoring timers
                    clearInterval(connectionWatchdog);
                    clearTimeout(heartbeatTimeout);

                    if (!isManuallyDisconnected) {
                        consecutiveErrors++;

                        if (consecutiveErrors === 1) {
                            console.log(' Connection lost, attempting immediate reconnection...');
                            setTimeout(() => {
                                if (!isManuallyDisconnected && agentStatusEventSource.readyState === EventSource.CLOSED) {
                                    startAgentSSEStream();
                                }
                            }, 1000); // Very quick first retry
                        } else if (consecutiveErrors <= 3) {
                            console.log(` Reconnection attempt ${consecutiveErrors}`);
                            setTimeout(() => {
                                if (!isManuallyDisconnected && agentStatusEventSource.readyState === EventSource.CLOSED) {
                                    startAgentSSEStream();
                                }
                            }, Math.min(2000 * consecutiveErrors, 10000)); // Exponential backoff, max 10s
                        } else if (consecutiveErrors === 4) {
                            addAgentStatus(' Stream connection unstable - implementing recovery strategy...', 'warning');
                            setTimeout(() => {
                                if (!isManuallyDisconnected) {
                                    startAgentSSEStream();
                                }
                            }, 5000);
                        } else if (consecutiveErrors >= 5) {
                            addAgentStatus(' Multiple stream failures - manual restart may be needed', 'error');
                            updateAutonomousStatus('CONNECTION ERROR');
                        }
                    }
                };

            } catch (error) {
                console.error('Failed to create EventSource:', error);
                addAgentStatus(' Failed to initialize stream connection', 'error');

                // Retry after delay
                setTimeout(() => {
                    if (!isManuallyDisconnected) {
                        startAgentSSEStream();
                    }
                }, 5000);
            }
        }

        // Connection monitoring functions
        function startConnectionWatchdog() {
            // Clear any existing watchdog
            clearInterval(connectionWatchdog);

            // Check connection health every 30 seconds
            connectionWatchdog = setInterval(() => {
                const timeSinceLastMessage = Date.now() - lastSuccessfulStatusTime;

                // If no message received in 120 seconds, assume connection is stale
                if (timeSinceLastMessage > 120000) {
                    console.warn(' Connection appears stale - forcing reconnection');
                    addAgentStatus(' Connection timeout detected - reconnecting...', 'warning');

                    // Force reconnection
                    if (agentStatusEventSource) {
                        agentStatusEventSource.close();
                    }
                    startAgentSSEStream();
                }
            }, 30000); // Check every 30 seconds

            // Set initial heartbeat timeout
            resetHeartbeatTimeout();
        }

        function resetHeartbeatTimeout() {
            clearTimeout(heartbeatTimeout);

            // Expect heartbeat or message within 30 seconds
            heartbeatTimeout = setTimeout(() => {
                if (!isManuallyDisconnected) {
                    console.warn(' Heartbeat timeout - connection may be dead');
                    addAgentStatus(' Connection heartbeat lost - reconnecting...', 'warning');

                    // Force reconnection
                    if (agentStatusEventSource) {
                        agentStatusEventSource.close();
                    }
                    startAgentSSEStream();
                }
            }, 30000); // 30 second timeout
        }

        // Function to manually disconnect (for graceful shutdowns)
        function disconnectAgentStream() {
            console.log(' Manually disconnecting agent stream');
            isManuallyDisconnected = true;

            // Clear all timers
            clearInterval(connectionWatchdog);
            clearTimeout(heartbeatTimeout);

            // Close connection
            if (agentStatusEventSource) {
                agentStatusEventSource.close();
                agentStatusEventSource = null;
            }
        }

        function restartAgentStatusPolling() {
            console.log(' Restarting agent status streaming...');
            addAgentStatus('Reconnecting to real-time stream...', 'info');
            startAgentStatusPolling();
        }

        let lastActivityShown = null;
        let statusCounter = 0;

        let maxConsecutiveErrors = 999;  // Effectively unlimited retries

        function fetchRealAgentStatus() {
            // DISABLED: This function is now replaced by SSE streaming
            // All real-time updates are handled via startAgentSSEStream()
            console.log(' fetchRealAgentStatus is disabled - using SSE instead');
        }

        function startStatusWatchdog() {
            // Status watchdog DISABLED: Using SSE streaming instead of polling
            console.log(' Status watchdog disabled - SSE streaming handles connection monitoring');

            // Clear any existing watchdog
            if (statusWatchdogInterval) {
                clearInterval(statusWatchdogInterval);
                statusWatchdogInterval = null;
            }
        }

        // Cache for preloaded data
        let preloadedStockData = {};
        let preloadingInProgress = false;

        // Preload stock data in background
        function startBackgroundPreloading() {
            if (preloadingInProgress) return;
            if (!systemInitialized) {
                console.log(' Cannot start preloading - system not initialized yet');
                return;
            }
            preloadingInProgress = true;

            console.log(' Starting INSTANT preloading with Enhanced Data Manager...');

            // Get all priority symbols for instant bulk loading
            const highPrioritySymbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA'];

            //  INSTANT BULK LOADING - Single API call with HTTP/2 connection pooling & Redis cache
            console.log(` Enhanced bulk loading ${highPrioritySymbols.length} priority symbols instantly...`);
            const symbolsParam = highPrioritySymbols.join(',');

            fetch(`/api/enhanced/bulk_prices?symbols=${symbolsParam}`)
                .then(response => response.json())
                .then(async data => {
                    if (data && data.prices) {
                        // Cache the preloaded data
                        Object.assign(preloadedStockData, data.prices);
                        console.log(` INSTANT Enhanced bulk load complete: ${Object.keys(data.prices).join(', ')}`);
                        console.log(` Cache now contains: ${Object.keys(preloadedStockData).length} symbols`);
                        console.log(` Source: ${data.batch_info?.source} | HTTP/2: ${data.batch_info?.http2_optimized} | Cached: ${data.batch_info?.cached}`);

                        //  Ensure skeleton structure exists before displaying data
                        console.log(' Ensuring skeleton structure exists...');
                        await initializeCategorySkeleton();

                        //  IMMEDIATELY DISPLAY all priority stocks at once
                        console.log(' Displaying all priority stocks instantly...');
                        displayPricesWithCategories(preloadedStockData);
                        updateLastUpdated();
                        addLogEntry(` Enhanced instant load: ${Object.keys(data.prices).join(', ')} (${Object.keys(preloadedStockData).length} total)`);

                        // Continue with extended symbols after successful priority load
                        console.log(' Priority symbols loaded instantly! Starting extended preloading...');
                        preloadExtendedSymbols();
                    } else {
                        console.log(' No price data returned from enhanced bulk API');
                        preloadingInProgress = false;
                    }
                })
                .catch(error => {
                    console.log(` Enhanced bulk preload failed: ${error.message}`);
                    preloadingInProgress = false;
                });
            }

            // COMPLETELY REWRITTEN: Simple extended symbol preloading
            let extendedPreloadingStarted = false;
            async function preloadExtendedSymbols() {
                if (extendedPreloadingStarted) {
                    console.log(' Extended preloading already started, skipping duplicate call');
                    return;
                }
                extendedPreloadingStarted = true;
                console.log(' V4.0 ULTRA CACHE BUSTER - Starting SIMPLE extended preloading... ');

                // TRENDING: Get current trending symbols and add to priority loading
                let trendingSymbolsForPreload = [];
                try {
                    const trendingResponse = await fetch('/api/trending_stocks');
                    const trendingData = await trendingResponse.json();
                    if (trendingData.success && trendingData.trending_symbols && trendingData.trending_symbols.length > 0) {
                        trendingSymbolsForPreload = trendingData.trending_symbols.map(item => item.symbol);
                        console.log(' Adding trending symbols to priority preload:', trendingSymbolsForPreload.join(', '));
                    } else {
                        console.log(' No trending symbols available for preload');
                    }
                } catch (error) {
                    console.error('Failed to fetch trending symbols for preload:', error);
                }

                // SIMPLE LIST: Trending symbols first, then other priority categories
                const extendedSymbols = [
                    // Trending stocks (highest priority)
                    ...trendingSymbolsForPreload,
                    // Growth & SaaS
                    'CRM', 'ADBE', 'NFLX', 'SPOT', 'SHOP', 'SNOW', 'PLTR',
                    // Financial Services
                    'JPM', 'BAC', 'V', 'MA', 'PYPL', 'SQ',
                    // Consumer & Retail
                    'KO', 'PEP', 'WMT', 'TGT', 'HD', 'LOW',
                    // Healthcare & Biotech
                    'JNJ', 'UNH', 'PFE', 'MRNA', 'VRTX',
                    // Energy & Materials
                    'XOM', 'CVX', 'COP',
                    // Cloud & Enterprise
                    'NOW', 'TEAM', 'ZM', 'DDOG', 'CRWD',
                    // Semiconductors
                    'AMD', 'INTC', 'TSM', 'QCOM',
                    // Fintech & Crypto
                    'COIN', 'HOOD', 'AFRM', 'SOFI'
                ];
                let currentExtendedIndex = 0;

                // Check if main loading already covered most symbols - skip batch loading
                const currentSymbols = Object.keys(preloadedStockData);
                if (currentSymbols.length >= 35) { // Most important symbols should be loaded by main function
                    console.log(` Main loading already covered ${currentSymbols.length} symbols, skipping extended batch loading`);
                    preloadingInProgress = false;
                    return;
                }

                console.log(` Extended bulk loading enabled - loading ${extendedSymbols.length} remaining symbols...`);

                // Get symbols that haven't been loaded yet
                const remainingSymbols = extendedSymbols.filter(symbol => !preloadedStockData[symbol]);
                console.log(` Loading ${remainingSymbols.length} remaining symbols: ${remainingSymbols.join(', ')}`);

                if (remainingSymbols.length > 0) {
                    // Single bulk request for all remaining symbols
                    const symbolsParam = remainingSymbols.join(',');
                    console.log(` Making bulk request for remaining symbols...`);

                    try {
                        const response = await fetch(`/api/enhanced/bulk_prices?symbols=${symbolsParam}`);
                        const data = await response.json();

                        if (data && data.prices) {
                            // Add to cache
                            Object.assign(preloadedStockData, data.prices);
                            console.log(` Extended bulk load complete: ${Object.keys(data.prices).length} additional symbols loaded`);
                            console.log(` Source: ${data.batch_info?.source} | HTTP/2: ${data.batch_info?.http2_optimized}`);

                            // Ensure skeleton exists and display new data
                            await initializeCategorySkeleton();
                            displayPricesWithCategories(preloadedStockData);
                            updateLastUpdated();
                        } else {
                            console.log(' No additional price data returned from extended bulk API');
                        }
                    } catch (error) {
                        console.error(` Extended bulk request failed: ${error.message}`);
                    }
                }

                let totalSymbolsLoaded = Object.keys(preloadedStockData).length;
                const batchPromises = [];

                // Wait for all batches to complete
                Promise.allSettled(batchPromises)
                    .then(results => {
                        const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;
                        console.log(` Progressive loading complete: ${successful}/0 batches successful (disabled)`);
                        console.log(` Total symbols loaded: ${totalSymbolsLoaded}/${extendedSymbols.length}`);
                        console.log(` Final cache size: ${Object.keys(preloadedStockData).length} symbols`);

                        // Final UI update
                        displayPricesWithCategories(preloadedStockData);
                        addLogEntry(` Progressive load complete: ${totalSymbolsLoaded} symbols (batch loading disabled)`);

                        preloadingInProgress = false;
                    });
            }

            // Enhanced preloading is now called directly from the system initialization

        // Global initialization flag to prevent multiple starts
        // systemInitialized is already declared above

        // Initialize system with retry logic
        function initializeSystemWithRetry(attempt = 1, maxAttempts = 3) {
            const delay = attempt === 1 ? 0 : Math.min(1000 * Math.pow(2, attempt - 1), 5000); // Exponential backoff, max 5s

            if (delay > 0) {
                console.log(` Retrying system initialization in ${delay}ms (attempt ${attempt}/${maxAttempts})...`);
                setTimeout(() => performInitialization(attempt, maxAttempts), delay);
            } else {
                performInitialization(attempt, maxAttempts);
            }
        }

        function performInitialization(attempt, maxAttempts) {
            fetch('/api/initialize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(` Trading system initialized for autonomous agent (attempt ${attempt})`);
                    systemInitialized = true; // Only set to true after successful initialization
                    updateStatus('Initialized');
                    // Update portfolio metrics
                    updateMetrics();

                    // Start background preloading only after successful initialization
                    console.log(' Starting background preloading after successful initialization...');
                    startBackgroundPreloading();
                })
                .catch(error => {
                    console.error(` Error initializing system (attempt ${attempt}):`, error);
                    systemInitialized = false; // Ensure it stays false on error

                    if (attempt < maxAttempts) {
                        updateStatus(`Initialization Failed - Retrying (${attempt}/${maxAttempts})`);
                        initializeSystemWithRetry(attempt + 1, maxAttempts);
                    } else {
                        updateStatus('Initialization Failed - Please refresh page');
                        console.error(` System initialization failed after ${maxAttempts} attempts. Please check backend status.`);
                    }
                });
        }

        // Start the system when page loads
        document.addEventListener('DOMContentLoaded', function() {
            if (systemInitialized) {
                console.log(' System already initialized, preventing duplicate initialization');
                return;
            }

            console.log('[*]>> TRADING-TERMINAL v5.4 - AUTONOMOUS AGENT READY - TIMESTAMP: ' + new Date().getTime() + ' <<[*]');
            console.log(' SIMPLE extended loading approach implemented!');

            // Auto-initialize backend system with retry logic
            console.log('[*] Auto-initializing trading system for autonomous agent...');
            initializeSystemWithRetry();

            initialize();

            // Auto-start agent status streaming on page load (AUTONOMOUS MODE)
            console.log(' [AUTONOMOUS MODE] Auto-starting agent status streaming...');
            setTimeout(() => {
                startAgentStatusPolling();
                addAgentStatus(' [AUTONOMOUS MODE] Agent status streaming auto-started on page load', 'info');
                updateAutonomousStatus('CONNECTING');
            }, 2000); // Give system a moment to initialize first

            // Auto-start autonomous trading agents (CONTINUOUS OPERATION MODE)
            console.log(' [CONTINUOUS MODE] Auto-starting autonomous trading agents...');
            setTimeout(() => {
                autoStartAutonomousTrading();
            }, 5000); // Give system more time to fully initialize before starting trading

            // Auto-initialize skeleton structure for immediate visual feedback
            console.log(' Auto-initializing skeleton structure for immediate display...');
            initializeCategorySkeleton();
        });

        // Advanced market conditions analysis for 24/7 trading operations
        function getAdvancedMarketConditions() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentDay = now.getDay(); // 0 = Sunday, 6 = Saturday
            const currentTime = currentHour + (currentMinute / 60); // Convert to decimal hours

            // Market session definitions (all times in ET/EDT)
            const marketSessions = {
                preMarket: { start: 4.0, end: 9.5 },     // 4:00 AM - 9:30 AM
                regularMarket: { start: 9.5, end: 16.0 }, // 9:30 AM - 4:00 PM
                afterHours: { start: 16.0, end: 20.0 }    // 4:00 PM - 8:00 PM
            };

            // Determine current market session
            let currentSession = 'closed';
            let sessionPriority = 0; // 0=closed, 1=after-hours/pre-market, 2=regular, 3=international

            if (currentDay >= 1 && currentDay <= 5) { // Monday-Friday
                if (currentTime >= marketSessions.preMarket.start && currentTime < marketSessions.preMarket.end) {
                    currentSession = 'preMarket';
                    sessionPriority = 1;
                } else if (currentTime >= marketSessions.regularMarket.start && currentTime < marketSessions.regularMarket.end) {
                    currentSession = 'regularMarket';
                    sessionPriority = 2;
                } else if (currentTime >= marketSessions.afterHours.start && currentTime < marketSessions.afterHours.end) {
                    currentSession = 'afterHours';
                    sessionPriority = 1;
                }
            }

            // International market coverage (24/7 operations)
            // When US markets are closed, check for international opportunities
            if (sessionPriority === 0) {
                // European markets (2:30 AM - 11:00 AM ET approx)
                // Asian markets (7:00 PM - 2:00 AM ET approx)
                // This provides near 24/7 coverage
                const isEuropeanHours = (currentTime >= 2.5 && currentTime < 11.0);
                const isAsianHours = (currentTime >= 19.0 || currentTime < 2.0);

                if (isEuropeanHours || isAsianHours) {
                    currentSession = 'international';
                    sessionPriority = 3;
                }
            }

            // Cryptocurrency markets (true 24/7)
            const cryptoAvailable = true; // Crypto markets never close

            // Trading decision logic for hedge fund operations
            const shouldTrade = (
                sessionPriority >= 1 ||      // Any market session active
                cryptoAvailable ||           // Crypto always available
                true                         // OVERRIDE: Always trade for continuous hedge fund operations
            );

            // Risk and liquidity adjustments based on session
            const riskMultiplier = {
                'regularMarket': 1.0,        // Full risk tolerance
                'preMarket': 0.7,            // Reduced risk (lower liquidity)
                'afterHours': 0.7,           // Reduced risk (lower liquidity)
                'international': 0.5,        // Conservative risk (different markets)
                'closed': 0.3                // Minimal risk (crypto/futures only)
            };

            const liquidityLevel = {
                'regularMarket': 'high',
                'preMarket': 'medium',
                'afterHours': 'medium',
                'international': 'medium',
                'closed': 'low'
            };

            return {
                shouldTrade,
                currentSession,
                sessionPriority,
                currentTime: now.toLocaleString(),
                timeOfDay: currentTime.toFixed(2),
                riskMultiplier: riskMultiplier[currentSession] || 0.3,
                liquidityLevel: liquidityLevel[currentSession] || 'low',
                recommendations: {
                    equities: sessionPriority >= 1,
                    options: sessionPriority >= 2, // Options mainly during regular hours
                    futures: sessionPriority >= 1,
                    forex: true,                    // Forex markets are 24/5
                    crypto: true,                   // Crypto markets are 24/7
                    international: sessionPriority === 3
                },
                nextSessionChange: getNextSessionChange(currentSession, currentTime, currentDay)
            };
        }

        // Helper function to calculate next session change
        function getNextSessionChange(currentSession, currentTime, currentDay) {
            const sessions = [
                { name: 'preMarket', start: 4.0, end: 9.5 },
                { name: 'regularMarket', start: 9.5, end: 16.0 },
                { name: 'afterHours', start: 16.0, end: 20.0 }
            ];

            for (const session of sessions) {
                if (currentTime < session.start) {
                    const hoursUntil = session.start - currentTime;
                    return {
                        session: session.name,
                        hoursUntil: hoursUntil.toFixed(1),
                        message: `${session.name} starts in ${hoursUntil.toFixed(1)} hours`
                    };
                }
            }

            // If past all sessions today, next is pre-market tomorrow
            const hoursUntilTomorrow = (24 - currentTime) + 4.0; // Hours until 4 AM tomorrow
            return {
                session: 'preMarket',
                hoursUntil: hoursUntilTomorrow.toFixed(1),
                message: `Next preMarket in ${hoursUntilTomorrow.toFixed(1)} hours`
            };
        }

        // Auto-start autonomous trading function for continuous operation
        async function autoStartAutonomousTrading() {
            console.log(' [AUTO-START] Initiating continuous autonomous trading mode...');

            try {
                // Advanced 24/7 market hours logic for hedge fund operations
                const marketConditions = getAdvancedMarketConditions();

                if (marketConditions.shouldTrade) { // Use sophisticated market hours logic
                    console.log(' [AUTO-START] Market conditions suitable - starting autonomous agents...');
                    console.log(' [MARKET CONDITIONS]', marketConditions);

                    addAgentStatus(' [AUTO-START] Initiating continuous autonomous trading mode...', 'info');
                    addAgentStatus(` [MARKET SESSION] ${marketConditions.currentSession.toUpperCase()} - Risk: ${(marketConditions.riskMultiplier * 100).toFixed(0)}% - Liquidity: ${marketConditions.liquidityLevel}`, 'info');

                    // Display market conditions and recommendations
                    const recommendations = Object.entries(marketConditions.recommendations)
                        .filter(([_, enabled]) => enabled)
                        .map(([market, _]) => market.toUpperCase())
                        .join(', ');

                    if (recommendations) {
                        addAgentStatus(` [ACTIVE MARKETS] ${recommendations}`, 'info');
                    }

                    // Start autonomous trading
                    const response = await fetch('/api/start_trading', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ mode: 'autonomous' })
                    });

                    const data = await response.json();

                    if (response.ok && data.status === 'started') {
                        console.log(' [AUTO-START] Autonomous agents successfully started');
                        updateAutonomousStatus('RUNNING');
                        addAgentStatus(' [AUTO-START] Autonomous trading agents started - continuous operation mode active', 'success');
                        addAgentStatus(' [HEDGE FUND MODE] Operating as autonomous hedge fund - managing portfolio 24/7', 'info');
                        addLogEntry(' Autonomous hedge fund mode activated - continuous trading enabled');

                        // Set up watchdog to ensure agents stay running
                        setupAutonomousTradingWatchdog();

                    } else {
                        console.warn(' [AUTO-START] Failed to start autonomous agents:', data);
                        addAgentStatus(` [AUTO-START] Failed to start autonomous agents: ${data.error || 'Unknown error'}`, 'warning');
                        updateAutonomousStatus('ERROR');

                        // Retry in 30 seconds
                        setTimeout(() => {
                            console.log(' [AUTO-START] Retrying autonomous agent startup...');
                            autoStartAutonomousTrading();
                        }, 30000);
                    }
                } else {
                    console.log(' [AUTO-START] Market conditions not optimal - scheduling next check...');
                    addAgentStatus(` [AUTO-START] Market conditions: ${marketConditions.currentSession} - ${marketConditions.nextSessionChange.message}`, 'info');
                    addAgentStatus(' [AUTO-START] Scheduling next trading opportunity check...', 'info');

                    // Check again based on next market session
                    const checkInterval = Math.min(parseFloat(marketConditions.nextSessionChange.hoursUntil) * 3600000, 3600000); // Max 1 hour
                    setTimeout(() => {
                        autoStartAutonomousTrading();
                    }, checkInterval);
                }

            } catch (error) {
                console.error(' [AUTO-START] Error starting autonomous agents:', error);
                addAgentStatus(' [AUTO-START] Error starting autonomous agents - will retry', 'error');
                updateAutonomousStatus('ERROR');

                // Retry in 60 seconds
                setTimeout(() => {
                    autoStartAutonomousTrading();
                }, 60000);
            }
        }

        // Watchdog function to ensure autonomous agents stay running
        function setupAutonomousTradingWatchdog() {
            console.log(' [WATCHDOG] Setting up autonomous trading watchdog...');

            setInterval(async () => {
                try {
                    // Check if agents are still running by pinging the status
                    const response = await fetch('/api/agent_status');

                    if (!response.ok) {
                        console.warn(' [WATCHDOG] Agent status check failed - attempting restart...');
                        addAgentStatus(' [WATCHDOG] Detected agent failure - restarting autonomous trading...', 'warning');
                        autoStartAutonomousTrading();
                    } else {
                        const status = await response.json();
                        // Additional health checks can be added here
                        console.log(' [WATCHDOG] Autonomous agents health check passed');
                    }
                } catch (error) {
                    console.warn(' [WATCHDOG] Health check failed:', error);
                    // Restart agents if health check fails
                    addAgentStatus(' [WATCHDOG] Health check failed - restarting agents...', 'warning');
                    autoStartAutonomousTrading();
                }
            }, 300000); // Check every 5 minutes
        }

        // Debug logging for autonomous agent
        function logAgentDebug(message) {
            const debugLog = document.getElementById('agentDebugLog');
            const debugContent = document.getElementById('agentDebugContent');

            if (debugLog && debugContent) {
                const timestamp = new Date().toLocaleTimeString();
                // Sanitize message to prevent XSS
                const sanitizedMessage = DOMPurify.sanitize(message);
                debugContent.innerHTML += `[${timestamp}] ${sanitizedMessage}<br>`;
                debugContent.scrollTop = debugContent.scrollHeight;
                debugLog.style.display = 'block';
            }
        }

        // Portfolio Chart functionality
        let chartData = {
            '1h': [],
            '1d': [],
            '1w': [],
            '1m': [],
            '1y': []
        };
        let currentPeriod = '1h';
        let portfolioChart = null;
        let currentChartData = [];

        // Helper function to get period text for trend indicator
        function getPeriodText(period) {
            switch(period) {
                case '1h': return 'this hour';
                case '1d': return 'today';
                case '1w': return 'this week';
                case '1m': return 'this month';
                case '1y': return 'this year';
                default: return 'this period';
            }
        }

        function initializeChart() {
            // Always initialize chart, even with empty portfolio
            // Set default value to 0 if no portfolio exists
            if (!window.currentPortfolioValue && !window.currentInvestedCapital) {
                window.currentPortfolioValue = 0;
                window.currentInvestedCapital = 0;
            }

            // Initialize with real portfolio data
            fetchRealPortfolioData();
        }

        let isInitializingPortfolio = false;
        let isFetchingChartData = false;

        async function fetchRealPortfolioData() {
            if (isInitializingPortfolio) {
                console.log(' Portfolio initialization already in progress, skipping duplicate call');
                return;
            }

            isInitializingPortfolio = true;
            console.log(' Starting portfolio data initialization...');

            try {
                const response = await fetch('/api/portfolio');
                const portfolioData = await response.json();

                // Calculate invested capital (market value of positions only, excluding cash)
                let investedCapital = 0;
                if (portfolioData.positions) {
                    for (const [symbol, position] of Object.entries(portfolioData.positions)) {
                        if (position.market_value) {
                            investedCapital += parseFloat(position.market_value);
                        }
                    }
                }

                // Update current portfolio value to use invested capital instead of account equity
                window.currentPortfolioValue = investedCapital;
                window.realPortfolioValue = investedCapital;

                console.log(' Portfolio value updated:', window.realPortfolioValue);

                // Get real portfolio history data instead of generating fake data
                currentChartData = await fetchRealPortfolioHistory('1D');

                // Cache the real chart data for consistent filter switching
                window.stableChartDataCache = currentChartData;

                // Create the D3 chart
                createD3Chart();

                // Update portfolio title with current value
                updatePortfolioTitle();

                // Update last updated time
                const lastUpdateElement = document.getElementById('chartLastUpdate');
                if (lastUpdateElement) {
                    lastUpdateElement.textContent = new Date().toLocaleTimeString();
                }

                // Add event listeners for filters
                setupChartEventListeners();

                console.log(' Portfolio initialization complete');
                isInitializingPortfolio = false;

            } catch (error) {
                console.error('Failed to fetch portfolio data:', error);
                // Show error state instead of fake data
                const chartDiv = document.getElementById('chartdiv');
                if (chartDiv) {
                    safeSetHTML(chartDiv, '<div style="text-align: center; padding: var(--space-3xl); color: var(--color-error);">Failed to load portfolio data</div>');
                }
                isInitializingPortfolio = false;
            }
        }

        // Cache for portfolio history data to prevent duplicate API calls
        const portfolioHistoryCache = new Map();
        const CACHE_DURATION = 30000; // 30 seconds cache

        // Global debounce mechanism to prevent rapid successive calls
        let fetchDebounceTimer = null;
        let lastFetchTime = 0;
        const MIN_FETCH_INTERVAL = 2000; // Minimum 2 seconds between calls
        let pendingFetches = new Map(); // Track pending fetches by period

        async function fetchRealPortfolioHistory(period) {
            const now = Date.now();
            const cacheKey = `portfolio_history_${period}`;

            // FIRST LAYER: Cache check - return cached data if still fresh
            if (portfolioHistoryCache.has(cacheKey)) {
                const cached = portfolioHistoryCache.get(cacheKey);
                if (now - cached.timestamp < CACHE_DURATION) {
                    console.log(` Using cached data for ${period} (${Math.round((now - cached.timestamp) / 1000)}s old)`);
                    return cached.data;
                }
            }

            // SECOND LAYER: Global fetch flag check
            if (isFetchingChartData) {
                console.log(` Global chart data fetch already in progress for ${period}, skipping duplicate call`);
                return [];
            }

            // THIRD LAYER: Period-specific pending fetch check
            if (pendingFetches.has(period)) {
                console.log(` Fetch already pending for ${period}, skipping duplicate call`);
                return [];
            }

            // FOURTH LAYER: Minimum time interval check
            if (now - lastFetchTime < MIN_FETCH_INTERVAL) {
                const timeRemaining = MIN_FETCH_INTERVAL - (now - lastFetchTime);
                console.log(` Too soon to fetch again, need to wait ${Math.round(timeRemaining / 1000)}s more`);
                return [];
            }

            // FIFTH LAYER: Clear any existing debounce timer and set new one
            if (fetchDebounceTimer) {
                clearTimeout(fetchDebounceTimer);
                fetchDebounceTimer = null;
            }

            // Mark this period as pending and update tracking
            pendingFetches.set(period, now);
            isFetchingChartData = true;
            lastFetchTime = now;

            console.log(` [LAYER CHECK PASSED] Starting chart data fetch for period: ${period}`);

            try {
                // Map frontend periods to Alpaca API parameters
                const periodMap = {
                    '1H': { period: '1D', timeframe: '5Min' },    // Show 1 day with 5min intervals for "1H" view
                    '1D': { period: '1D', timeframe: '15Min' },   // Show 1 day with 15min intervals
                    '1W': { period: '1W', timeframe: '1Hour' },   // Show 1 week with 1hour intervals
                    '1M': { period: '1M', timeframe: '1Day' },    // Show 1 month with 1day intervals
                    '1Y': { period: '1A', timeframe: '1Week' }    // Show 1 year with 1week intervals
                };

                const params = periodMap[period] || { period: '1D', timeframe: '15Min' };
                const url = `/api/portfolio_history_real?period=${params.period}&timeframe=${params.timeframe}`;

                console.log(` [API CALL] Fetching real portfolio history: ${url}`);

                const response = await fetch(url);
                const historyData = await response.json();

                console.log(` Portfolio history response for ${period}:`, historyData);

                if (historyData.equity && historyData.timestamp) {
                    // Convert Alpaca data to chart format (timestamps are in seconds, need milliseconds)
                    const chartData = historyData.equity.map((value, index) => ({
                        timestamp: new Date(historyData.timestamp[index] * 1000),
                        value: value
                    }));

                    console.log(` [SUCCESS] Converted to chart format: ${chartData.length} points for ${period}`);

                    // Cache the result
                    portfolioHistoryCache.set(cacheKey, {
                        data: chartData,
                        timestamp: now
                    });

                    // Clean up tracking
                    pendingFetches.delete(period);
                    isFetchingChartData = false;

                    return chartData;
                } else {
                    console.error(' [ERROR] Invalid portfolio history response format:', historyData);
                }
            } catch (error) {
                console.error(' [ERROR] Failed to fetch real portfolio history:', error);
            } finally {
                // Always clean up tracking in finally block
                pendingFetches.delete(period);
                isFetchingChartData = false;
            }

            // Only return empty array if truly no data available
            console.error(' [FALLBACK] No real portfolio history available');
            return [];
        }

        // Manual refresh function for the chart
        async function refreshChartData() {
            const refreshBtn = document.getElementById('chartRefreshBtn');
            const refreshIcon = refreshBtn.querySelector('.refresh-icon');
            const refreshText = refreshBtn.querySelector('.refresh-text');

            // Get current active period
            const activeFilter = document.querySelector('.chart-card .chart-filter.active');
            const currentPeriod = activeFilter ? activeFilter.dataset.period.toUpperCase() : '1D';

            console.log(` [MANUAL REFRESH] Forcing refresh for period: ${currentPeriod}`);

            // Disable button and show loading state
            refreshBtn.disabled = true;
            refreshBtn.classList.add('loading');
            refreshText.textContent = 'REFRESHING...';

            try {
                // Clear cache for current period to force fresh data
                const cacheKey = `portfolio_history_${currentPeriod}`;
                portfolioHistoryCache.delete(cacheKey);
                console.log(` [CACHE CLEARED] Removed cached data for ${currentPeriod}`);

                // Reset any blocking flags temporarily for manual refresh
                const wasBlocked = isFetchingChartData;
                pendingFetches.delete(currentPeriod);
                isFetchingChartData = false;
                lastFetchTime = 0; // Reset time check for manual refresh

                if (wasBlocked) {
                    console.log(` [MANUAL OVERRIDE] Cleared blocking flags for manual refresh`);
                }

                // Fetch fresh data
                currentChartData = await fetchRealPortfolioHistory(currentPeriod);

                if (currentChartData && currentChartData.length > 0) {
                    // Recreate the chart with fresh data
                    createD3Chart();
                    console.log(` [MANUAL REFRESH SUCCESS] Chart refreshed with ${currentChartData.length} data points`);

                    // Show success feedback
                    refreshText.textContent = 'REFRESHED!';
                    setTimeout(() => {
                        refreshText.textContent = 'REFRESH';
                    }, 1500);
                } else {
                    console.log(` [MANUAL REFRESH] No new data received`);
                    refreshText.textContent = 'NO DATA';
                    setTimeout(() => {
                        refreshText.textContent = 'REFRESH';
                    }, 2000);
                }

            } catch (error) {
                console.error(' [MANUAL REFRESH ERROR]:', error);
                refreshText.textContent = 'ERROR';
                setTimeout(() => {
                    refreshText.textContent = 'REFRESH';
                }, 2000);
            } finally {
                // Re-enable button and remove loading state
                setTimeout(() => {
                    refreshBtn.disabled = false;
                    refreshBtn.classList.remove('loading');
                }, 1000);
            }
        }

        function updatePortfolioTitle() {
            // Always prefer the real portfolio value (account equity) over position market value
            const portfolioValue = window.currentPortfolioValue || window.realPortfolioValue;
            if (portfolioValue) {
                const formattedValue = "$" + portfolioValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                safeSetHTML(document.getElementById('portfolioChartTitle'), ` ${formattedValue}`);
            }
        }

        function createD3Chart() {
            // Clear existing chart
            d3.select("#chartdiv").selectAll("*").remove();

            // Chart dimensions and margins
            const containerWidth = document.getElementById('chartdiv').clientWidth;
            const containerHeight = 300;
            const margin = { top: 20, right: 0, bottom: 30, left: 0 };
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            // Scales
            const x = d3.scaleTime()
                .domain(d3.extent(currentChartData, d => d.timestamp || new Date(d.date)))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain(d3.extent(currentChartData, d => d.value))
                .range([height, 0]);

            // Line generator
            const line = d3.line()
                .x(d => x(d.timestamp || new Date(d.date)))
                .y(d => y(d.value))
                .curve(d3.curveMonotoneX);

            // Create SVG
            const svg = d3.select("#chartdiv")
                .append("svg")
                .attr("width", containerWidth)
                .attr("height", containerHeight)
                .style("background", "transparent");

            // Add gradient definition
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "chartGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "var(--text-primary)")
                .attr("stop-opacity", "0.1");

            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "var(--text-primary)")
                .attr("stop-opacity", "0");

            // Create textured gradient that combines base gradient with noise
            const texturedGradient = defs.append("linearGradient")
                .attr("id", "texturedGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            texturedGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "var(--text-primary)")
                .attr("stop-opacity", "0.1");

            texturedGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "var(--text-primary)")
                .attr("stop-opacity", "0");

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add X axis (hidden)
            // g.append("g")
            //     .attr("transform", `translate(0,${height})`)
            //     .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))
            //     .selectAll("text")
            //     .style("fill", "var(--text-secondary)")
            //     .style("font-size", "10px");

            // Add Y axis (hidden)
            // g.append("g")
            //     .call(d3.axisLeft(y).ticks(height / 40).tickFormat(d => `$${d.toLocaleString()}`))
            //     .selectAll("text")
            //     .style("fill", "var(--text-secondary)")
            //     .style("font-size", "10px");

            // Add grid lines
            g.selectAll(".grid-line")
                .data(y.ticks(height / 40))
                .enter()
                .append("line")
                .attr("class", "grid-line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => y(d))
                .attr("y2", d => y(d))
                .style("stroke", "var(--border-color)")
                .style("stroke-opacity", 0.1);

            // Add the line path
            g.append("path")
                .datum(currentChartData)
                .attr("fill", "none")
                .attr("stroke", "var(--text-primary)")
                .attr("stroke-width", 1)
                .attr("stroke-opacity", 0.5)
                .attr("d", line);

            // Add area under the line
            const area = d3.area()
                .x(d => x(d.timestamp || new Date(d.date)))
                .y0(height)
                .y1(d => y(d.value))
                .curve(d3.curveMonotoneX);

            // Add gradient fill
            g.append("path")
                .datum(currentChartData)
                .attr("fill", "url(#chartGradient)")
                .attr("d", area);

            // Add tooltip functionality
            const tooltip = d3.select("body").append("div")
                .attr("class", "d3-tooltip")
                .style("position", "absolute")
                .style("background", "var(--bg-primary)")
                .style("border", "1px solid var(--border-color)")
                .style("border-radius", "4px")
                .style("padding", "8px")
                .style("font-size", "var(--text-caption-size)")
                .style("color", "var(--text-primary)")
                .style("pointer-events", "none")
                .style("opacity", 0);

            // Add invisible overlay for mouse tracking
            g.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("mousemove", function(event) {
                    const [mouseX] = d3.pointer(event);
                    const xDate = x.invert(mouseX);

                    // Find closest data point
                    const bisect = d3.bisector(d => d.timestamp || new Date(d.date)).left;
                    const index = bisect(currentChartData, xDate, 1);
                    const d0 = currentChartData[index - 1];
                    const d1 = currentChartData[index];
                    const d = d1 && (xDate - (d0.timestamp || new Date(d0.date)) > (d1.timestamp || new Date(d1.date)) - xDate) ? d1 : d0;

                    if (d) {
                        tooltip.transition().duration(50).style("opacity", 1);

                        const formattedValue = "$" + d.value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                        const date = d.timestamp || new Date(d.date);

                        let dateFormat = "";
                        if (currentPeriod === '1h' || currentPeriod === '1d') {
                            dateFormat = date.toLocaleTimeString('en-US', {
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: true
                            });
                        } else {
                            const timeStr = date.toLocaleTimeString('en-US', {
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: true
                            });
                            const dateStr = date.toLocaleDateString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                year: 'numeric'
                            });
                            dateFormat = timeStr + "<br>" + dateStr;
                        }

                        tooltip
                            .html(`<strong>${formattedValue}</strong><br>${dateFormat}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    }
                })
                .on("mouseleave", function() {
                    tooltip.transition().duration(50).style("opacity", 0);
                });

            // Update trend indicator with current portfolio performance
            if (currentChartData && currentChartData.length > 0) {
                const currentValue = currentChartData[currentChartData.length - 1]?.value || 0;
                const startOfDayValue = currentChartData[0]?.value || currentValue;
                const dailyChange = currentValue - startOfDayValue;
                const dailyChangePercent = startOfDayValue !== 0 ? ((dailyChange / startOfDayValue) * 100) : 0;

                // Update trend indicator with both dollar amount and percentage
                const dollarSign = dailyChange >= 0 ? '+' : '';
                const trendDirection = dailyChange >= 0 ? 'up' : 'down';
                const formattedChange = Math.abs(dailyChange).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

                const trendText = `Trending ${trendDirection} ${dollarSign}$${formattedChange} (${dailyChangePercent >= 0 ? '+' : ''}${dailyChangePercent.toFixed(2)}%) ${getPeriodText(currentPeriod)}`;

                const trendElement = document.getElementById('chartTrendText');
                if (trendElement) {
                    trendElement.textContent = trendText;
                    // Apply color directly to the text element instead of parent
                    trendElement.style.color = dailyChange >= 0 ? 'var(--color-success)' : 'var(--color-error)';

                    // Also update the parent container color for the icon
                    const parentElement = trendElement.parentElement;
                    if (parentElement) {
                        parentElement.style.color = dailyChange >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                    }

                    // Also update the trend icon to point up or down
                    const trendIcon = trendElement.parentElement.querySelector('.trend-icon');
                    if (trendIcon) {
                        if (dailyChange >= 0) {
                            // Arrow pointing UP
                            trendIcon.innerHTML = '<path d="M12 19V5M5 12l7-7 7 7"/>';
                        } else {
                            // Arrow pointing DOWN
                            trendIcon.innerHTML = '<path d="M12 5v14M19 12l-7 7-7-7"/>';
                        }
                    }
                }
            }
        }

        function generateSampleData() {
            return generateDataForPeriod('1h');
        }

        function generateStableChartData(portfolioValue) {
            // Generate stable chart data based on real portfolio value
            // This shows a realistic trend ending at the current portfolio value
            const data = [];
            const now = new Date();
            const timeInterval = 2 * 60 * 1000; // 2 minutes
            const dataPoints = 30;

            if (portfolioValue === 0) {
                // Show flat line at 0 for empty portfolio
                for (let i = 0; i < dataPoints; i++) {
                    const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                    data.push({
                        date: date.getTime(),
                        value: 0
                    });
                }
            } else {
                // Generate realistic trend ending at current value
                const startValue = 100000; // Starting capital
                const finalValue = portfolioValue;
                const totalReturn = (finalValue - startValue) / startValue;
                let randomSeed = 12345;

                for (let i = 0; i < dataPoints; i++) {
                    const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                    const progress = i / (dataPoints - 1);

                    // Gradual progression from start to final value
                    let value = startValue + (finalValue - startValue) * progress;

                    // Add some realistic volatility (smaller towards the end)
                    const volatility = (1 - progress * 0.7) * 0.01; // 1% volatility declining to 0.3%
                    randomSeed++; // Increment seed for each data point
                    const randomChange = (seededRandom(randomSeed) - 0.5) * volatility * value;
                    value += randomChange;

                    // Ensure final point is exactly the current portfolio value
                    if (i === dataPoints - 1) {
                        value = finalValue;
                    }

                    data.push({
                        date: date.getTime(),
                        value: Math.round(value)
                    });
                }
            }

            return data;
        }

        // Simple seeded random number generator for consistent chart data
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateStableDataForPeriod(period, portfolioValue) {
            // Generate stable chart data for different time periods based on real portfolio value
            const data = [];
            const now = new Date();

            // Create a consistent seed based on portfolio value and period
            const portfolioSeed = Math.floor(portfolioValue || 102537);
            const periodSeed = period === '1h' ? 1 : period === '1d' ? 24 : period === '1w' ? 168 : period === '1m' ? 720 : 8760;
            let randomSeed = portfolioSeed + periodSeed;

            // Define time intervals and data points for each period
            let timeInterval, dataPoints;
            switch(period) {
                case '1h':
                    timeInterval = 2 * 60 * 1000; // 2 minutes
                    dataPoints = 30;
                    break;
                case '1d':
                    timeInterval = 30 * 60 * 1000; // 30 minutes
                    dataPoints = 48;
                    break;
                case '1w':
                    timeInterval = 2 * 60 * 60 * 1000; // 2 hours
                    dataPoints = 84;
                    break;
                case '1m':
                    timeInterval = 12 * 60 * 60 * 1000; // 12 hours
                    dataPoints = 60;
                    break;
                case '1y':
                    timeInterval = 7 * 24 * 60 * 60 * 1000; // 1 week
                    dataPoints = 52;
                    break;
                default:
                    timeInterval = 60 * 60 * 1000; // 1 hour
                    dataPoints = 50;
            }

            const finalValue = portfolioValue || 102537; // Use real portfolio value
            const startValue = 100000; // Starting capital

            if (finalValue === 0) {
                // Show flat line at 0 for empty portfolio
                for (let i = 0; i < dataPoints; i++) {
                    const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                    data.push({
                        date: date.getTime(),
                        value: 0
                    });
                }
            } else {
                // Generate realistic trend ending at current value
                for (let i = 0; i < dataPoints; i++) {
                    const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                    const progress = i / (dataPoints - 1);

                    // Gradual progression from start to final value
                    let value = startValue + (finalValue - startValue) * progress;

                    // Add some realistic volatility (smaller towards the end)
                    const volatility = (1 - progress * 0.7) * 0.01; // 1% volatility declining to 0.3%
                    randomSeed++; // Increment seed for each data point
                    const randomChange = (seededRandom(randomSeed) - 0.5) * volatility * value;
                    value += randomChange;

                    // Ensure final point is exactly the current portfolio value
                    if (i === dataPoints - 1) {
                        value = finalValue;
                    }

                    data.push({
                        date: date.getTime(),
                        value: Math.round(value)
                    });
                }
            }

            return data;
        }

        function generateDataForPeriod(period) {
            const data = [];
            const now = new Date();
            // Always use current portfolio market value, not old invested capital
            let currentValue = window.currentPortfolioValue || window.currentInvestedCapital || 0;
            const baseValue = currentValue;

            // Create a consistent seed based on portfolio value and period
            const portfolioSeed = Math.floor(currentValue || 102537);
            const periodSeed = period === '1h' ? 1 : period === '1d' ? 24 : period === '1w' ? 168 : period === '1m' ? 720 : 8760;
            let randomSeed = portfolioSeed + periodSeed;

            // Define time intervals and data points for each period
            let timeInterval, dataPoints;
            switch(period) {
                case '1h':
                    timeInterval = 2 * 60 * 1000; // 2 minutes
                    dataPoints = 30;
                    break;
                case '1d':
                    timeInterval = 30 * 60 * 1000; // 30 minutes
                    dataPoints = 48;
                    break;
                case '1w':
                    timeInterval = 2 * 60 * 60 * 1000; // 2 hours
                    dataPoints = 84;
                    break;
                case '1m':
                    timeInterval = 12 * 60 * 60 * 1000; // 12 hours
                    dataPoints = 60;
                    break;
                case '1y':
                    timeInterval = 7 * 24 * 60 * 60 * 1000; // 1 week
                    dataPoints = 52;
                    break;
                default:
                    timeInterval = 60 * 60 * 1000; // 1 hour
                    dataPoints = 50;
            }

            // For empty portfolio (value is 0), create flat line at 0
            if (baseValue === 0) {
                for (let i = 0; i < dataPoints; i++) {
                    const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                    data.push({
                        date: date.getTime(),
                        value: 0
                    });
                }
                return data;
            }

            for (let i = 0; i < dataPoints; i++) {
                const date = new Date(now.getTime() - (dataPoints - 1 - i) * timeInterval);
                // Create trending data with some volatility
                const change = (Math.random() - 0.48) * 500; // Slight upward bias
                currentValue += change;
                // Keep values in reasonable range around the base invested capital
                currentValue = Math.max(baseValue * 0.98, Math.min(baseValue * 1.02, currentValue));

                data.push({
                    date: date.getTime(),
                    value: Math.round(currentValue)
                });
            }
            return data;
        }

        // Store real portfolio values over time
        let portfolioHistory = [];

        function generateRealChartData() {
            // Use the real portfolio value from account equity
            const portfolioValue = window.realPortfolioValue || window.currentPortfolioValue;
            const now = Date.now();
            // Use the real portfolio value from account equity
            const baseValue = portfolioValue || 100000;

            // Force regeneration for demo purposes or if history is empty
            if (portfolioHistory.length === 0 || window.forceChartRegeneration) {
                portfolioHistory = []; // Clear existing history
                window.forceChartRegeneration = false;
                // Create data points for different timeframes with realistic market fluctuations
                const timePoints = [
                    now - (365 * 24 * 60 * 60 * 1000), // 1 year ago
                    now - (30 * 24 * 60 * 60 * 1000),  // 1 month ago
                    now - (7 * 24 * 60 * 60 * 1000),   // 1 week ago
                    now - (24 * 60 * 60 * 1000),       // 1 day ago
                    now - (4 * 60 * 60 * 1000),        // 4 hours ago
                    now - (60 * 60 * 1000),            // 1 hour ago
                    now - (30 * 60 * 1000),            // 30 minutes ago
                    now - (5 * 60 * 1000),             // 5 minutes ago
                    now                                 // now
                ];

                // Generate fluctuating values that trend toward current value
                timePoints.forEach((time, index) => {
                    let multiplier;
                    if (index === timePoints.length - 1) {
                        // Current time - use exact current value
                        multiplier = 1.0;
                    } else {
                        // Create realistic fluctuations (5% variance)
                        const randomVariation = (Math.random() - 0.5) * 0.1; // 5%
                        const timeWeight = index / (timePoints.length - 1); // Weight toward current value
                        multiplier = 0.95 + (0.1 * timeWeight) + randomVariation;
                    }

                    portfolioHistory.push({
                        time: time,
                        value: Math.round(baseValue * multiplier * 100) / 100, // Round to 2 decimals
                        formattedTime: new Date(time).toLocaleString()
                    });
                });

                // Sort by time to ensure chronological order
                portfolioHistory.sort((a, b) => a.time - b.time);
            }

            // Generate chart data based on actual history, converting to the format expected by SVG chart
            chartData['1h'] = filterHistoryByPeriod(60 * 60 * 1000).map(entry => ({
                value: entry.value,
                timestamp: entry.time,
                label: new Date(entry.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
            }));
            chartData['1d'] = filterHistoryByPeriod(24 * 60 * 60 * 1000).map(entry => ({
                value: entry.value,
                timestamp: entry.time,
                label: new Date(entry.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
            }));
            chartData['1w'] = filterHistoryByPeriod(7 * 24 * 60 * 60 * 1000).map(entry => ({
                value: entry.value,
                timestamp: entry.time,
                label: new Date(entry.time).toLocaleDateString([], {weekday: 'short'})
            }));
            chartData['1m'] = filterHistoryByPeriod(30 * 24 * 60 * 60 * 1000).map(entry => ({
                value: entry.value,
                timestamp: entry.time,
                label: new Date(entry.time).toLocaleDateString([], {month: 'short', day: 'numeric'})
            }));
            chartData['1y'] = filterHistoryByPeriod(365 * 24 * 60 * 60 * 1000).map(entry => ({
                value: entry.value,
                timestamp: entry.time,
                label: new Date(entry.time).toLocaleDateString([], {month: 'short'})
            }));
        }

        function filterHistoryByPeriod(duration) {
            const now = Date.now();
            const cutoff = now - duration;
            return portfolioHistory.filter(entry => entry.time >= cutoff);
        }

        function addPortfolioDataPoint(value) {
            const now = Date.now();
            const newEntry = {
                time: now,
                value: value,
                formattedTime: new Date(now).toLocaleString()
            };

            portfolioHistory.push(newEntry);

            // Keep only last 1000 data points to prevent memory issues
            if (portfolioHistory.length > 1000) {
                portfolioHistory = portfolioHistory.slice(-1000);
            }

            // Chart uses real Alpaca data, no need to regenerate fake data
            console.log('Chart refresh requested - using real portfolio data');
        }

        // Live Signals Functions
        async function refreshLiveSignals() {
            try {
                const response = await fetch('/api/live_signals?limit=15');
                const data = await response.json();

                if (data.success && data.signals) {
                    updateLiveSignalsTable(data.signals);
                } else {
                    console.error('Failed to fetch live signals:', data.error);
                }
            } catch (error) {
                console.error('Error fetching live signals:', error);
                // Show error in table
                const tbody = document.getElementById('liveSignalsTableBody');
                if (tbody) {
                    safeSetHTML(tbody, '<tr><td colspan="7" class="text-dim" style="color: var(--color-error);">Error loading signals</td></tr>');
                }
            }
        }

        function updateLiveSignalsTable(signals) {
            const tbody = document.getElementById('liveSignalsTableBody');
            if (!tbody) return;

            if (signals.length === 0) {
                safeSetHTML(tbody, '<tr><td colspan="7" class="text-dim">No recent signals detected...</td></tr>');
                return;
            }

            tbody.textContent = '';

            signals.forEach(signal => {
                const row = tbody.insertRow();

                // Add appropriate styling based on signal type
                const statusColor = signal.status === 'Order Executed' ? 'var(--color-success)' : 'var(--color-warning)';
                const actionColor = signal.action === 'BUY SIGNAL' ? 'var(--color-success)' : 'var(--color-error)';

                safeSetHTML(row, `
                    <td>${signal.timestamp}</td>
                    <td><strong>${signal.symbol}</strong></td>
                    <td style="color: ${actionColor};">${signal.action}</td>
                    <td>$${signal.price.toFixed(2)}</td>
                    <td>${signal.confidence}</td>
                    <td style="font-size: var(--text-caption-size);" title="${signal.reasoning}">${signal.reasoning.length > 50 ? signal.reasoning.substring(0, 50) + '...' : signal.reasoning}</td>
                    <td style="color: ${statusColor};">${signal.status}</td>
                `);

                // Add slight fade animation for new rows
                row.style.animation = 'fadeIn 0.5s ease-in';
            });
        }

        // Auto-refresh live signals every 10 seconds when on portfolio tab
        let liveSignalsInterval = null;

        function startLiveSignalsAutoRefresh() {
            // Refresh immediately
            refreshLiveSignals();

            // Set up interval
            liveSignalsInterval = setInterval(() => {
                if (document.getElementById('portfolio-tab').style.display !== 'none') {
                    refreshLiveSignals();
                }
            }, 10000); // 10 seconds
        }

        function stopLiveSignalsAutoRefresh() {
            if (liveSignalsInterval) {
                clearInterval(liveSignalsInterval);
                liveSignalsInterval = null;
            }
        }

        // Sell Signals functionality
        async function refreshSellSignals() {
            try {
                const response = await fetch('/api/live_signals?limit=15&action=sell');
                const data = await response.json();

                if (data.success && data.signals) {
                    const sellSignals = data.signals.filter(signal =>
                        signal.action === 'SELL SIGNAL' || signal.action === 'SELL'
                    );
                    updateSellSignalsTable(sellSignals);
                } else {
                    console.error('Failed to fetch sell signals:', data.error);
                }
            } catch (error) {
                console.error('Error fetching sell signals:', error);
                const tbody = document.querySelector('#liveSellSignalsTable tbody');
                if (tbody) {
                    safeSetHTML(tbody, '<tr><td colspan="6" class="text-dim" style="color: var(--color-error);">Error loading sell signals</td></tr>');
                }
            }
        }

        function updateSellSignalsTable(signals) {
            const tbody = document.querySelector('#liveSellSignalsTable tbody');
            if (!tbody) return;

            if (signals.length === 0) {
                safeSetHTML(tbody, '<tr><td colspan="6" class="text-dim">No recent sell signals detected...</td></tr>');
                return;
            }

            tbody.textContent = '';

            signals.forEach(signal => {
                const row = tbody.insertRow();

                safeSetHTML(row, `
                    <td>${signal.timestamp}</td>
                    <td><strong>${signal.symbol}</strong></td>
                    <td style="color: var(--color-error);">${signal.action}</td>
                    <td>$${signal.price.toFixed(2)}</td>
                    <td>${signal.confidence}</td>
                    <td style="font-size: var(--text-caption-size);" title="${signal.reasoning}">${signal.reasoning.length > 50 ? signal.reasoning.substring(0, 50) + '...' : signal.reasoning}</td>
                `);

                row.style.animation = 'fadeIn 0.5s ease-in';
            });
        }

        // Options refresh functionality
        async function refreshOptionsData() {
            try {
                console.log(' [OPTIONS] Refreshing options data...');
                const response = await fetch('/api/options/positions');
                console.log(' [OPTIONS] Response status:', response.status);

                const data = await response.json();
                console.log(' [OPTIONS] Response data:', data);
                console.log(' [OPTIONS] Positions count:', data.positions ? data.positions.length : 0);
                console.log(' [OPTIONS] Full positions array:', JSON.stringify(data.positions, null, 2));

                if (data.status === 'success') {
                    console.log(' [OPTIONS] Status is success, updating table with', data.positions.length, 'positions');
                    updateOptionsPositionsTable(data.positions || []);
                } else {
                    console.error(' [OPTIONS] Failed to fetch options positions:', data.error || 'Unknown error');
                }
            } catch (error) {
                console.error(' [OPTIONS] Error refreshing options data:', error);
                const tbody = document.getElementById('optionsPositionsBody');
                if (tbody) {
                    safeSetHTML(tbody, '<tr><td colspan="9" class="text-dim" style="color: var(--color-error);">Error loading options data</td></tr>');
                }
            }
        }

        function updateOptionsPositionsTable(positions) {
            console.log(' [OPTIONS] updateOptionsPositionsTable called with', positions.length, 'positions');
            const tbody = document.getElementById('optionsPositionsBody');

            if (!tbody) {
                console.error(' [OPTIONS] Table body element not found!');
                return;
            }
            console.log(' [OPTIONS] Table body element found');

            if (positions.length === 0) {
                console.log('  [OPTIONS] No positions to display');
                safeSetHTML(tbody, '<tr><td colspan="9" class="text-dim">No options positions</td></tr>');
                return;
            }

            console.log(' [OPTIONS] Rendering', positions.length, 'positions to table');
            tbody.textContent = '';
            positions.forEach((position, index) => {
                console.log(`  [${index}] Rendering position:`, position.symbol, position.strategy);
                const row = tbody.insertRow();
                const pnlColor = position.unrealized_pl >= 0 ? 'var(--color-success)' : 'var(--color-error)';

                safeSetHTML(row, `
                    <td><strong>${position.symbol}</strong></td>
                    <td>${position.option_type.toUpperCase()}</td>
                    <td>$${position.strike}</td>
                    <td>${position.expiration}</td>
                    <td>${position.quantity}</td>
                    <td>$${position.avg_cost.toFixed(2)}</td>
                    <td>$${position.current_price.toFixed(2)}</td>
                    <td style="color: ${pnlColor};">$${position.unrealized_pl.toFixed(2)}</td>
                    <td style="font-size: var(--text-caption-size);">:${position.greeks.delta || 0}</td>
                `);
                row.style.animation = 'fadeIn 0.5s ease-in';
            });
            console.log(' [OPTIONS] Table updated successfully');
        }

        async function refreshAgentAnalysis() {
            try {
                console.log(' [ANALYSIS] Fetching agent analysis...');
                const response = await fetch('/api/agent_analysis');
                const data = await response.json();

                console.log(' [ANALYSIS] Analysis data:', data);

                if (data.status === 'success') {
                    updatePortfolioSummary(data.portfolio_summary);
                    updateEquityAnalysis(data.portfolio_summary);
                    updateOptionsAnalysis(data.options_analysis);
                    updateMarketOutlook(data.market_outlook);

                    if (data.last_update) {
                        const updateTime = new Date(data.last_update);
                        document.getElementById('analysisLastUpdate').textContent = updateTime.toLocaleString();
                    }
                }
            } catch (error) {
                console.error(' [ANALYSIS] Error fetching analysis:', error);
            }
        }

        async function refreshDoughReport() {
            try {
                console.log(' [DOUGH_REPORT] Fetching Dough Report...');
                const response = await fetch('/api/dough-report');
                const data = await response.json();

                console.log(' [DOUGH_REPORT] Report data:', data);

                if (data.status === 'success' && data.has_report) {
                    displayDoughReport(data.report);
                } else {
                    hideDoughReport();
                }
            } catch (error) {
                console.error(' [DOUGH_REPORT] Error fetching report:', error);
                hideDoughReport();
            }
        }

        function displayDoughReport(report) {
            const container = document.getElementById('doughReportContainer');
            const title = document.getElementById('doughReportTitle');
            const timestamp = document.getElementById('doughReportTimestamp');
            const content = document.getElementById('doughReportContent');

            // Update title and timestamp
            title.textContent = `Dough Report - ${report.report_date}`;
            const reportTime = new Date(report.timestamp);
            timestamp.textContent = `Generated: ${reportTime.toLocaleString()}`;

            // Build content HTML
            const portfolioStatus = report.portfolio_status || {};
            const keyTrades = report.key_trades || [];
            const recommendations = report.strategy_recommendations || [];
            const agentInsights = report.agent_insights || [];

            safeSetHTML(content, `
                <div class="dough-report-section">
                    <h4> Portfolio Status</h4>
                    <div class="dough-report-metric">
                        <span class="dough-report-metric-label">Total Positions</span>
                        <span class="dough-report-metric-value">${portfolioStatus.total_positions || 0}</span>
                    </div>
                    <div class="dough-report-metric">
                        <span class="dough-report-metric-label">Market Value</span>
                        <span class="dough-report-metric-value">$${(portfolioStatus.total_market_value || 0).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                    </div>
                    <div class="dough-report-metric">
                        <span class="dough-report-metric-label">P&L</span>
                        <span class="dough-report-metric-value" style="color: ${(portfolioStatus.pnl_percentage || 0) >= 0 ? 'var(--success-color)' : 'var(--danger-color)'}">
                            ${(portfolioStatus.pnl_percentage || 0).toFixed(2)}%
                        </span>
                    </div>
                    <div class="dough-report-metric">
                        <span class="dough-report-metric-label">Market Sentiment</span>
                        <span class="dough-report-metric-value">${report.market_sentiment || 'NEUTRAL'}</span>
                    </div>
                    <div class="dough-report-metric">
                        <span class="dough-report-metric-label">Market Regime</span>
                        <span class="dough-report-metric-value">${report.market_regime || 'NEUTRAL'}</span>
                    </div>
                </div>

                <div class="dough-report-section">
                    <h4> Key Trades Today</h4>
                    <div class="dough-report-trades">
                        ${keyTrades.length > 0 ? keyTrades.map(trade => `
                            <div class="dough-report-trade">
                                <div class="dough-report-trade-symbol">${trade.symbol}</div>
                                <div class="dough-report-trade-reason">${trade.reason}</div>
                                ${trade.entry_target ? `<div class="dough-report-trade-reason">Target: $${trade.entry_target}</div>` : ''}
                            </div>
                        `).join('') : '<div class="text-dim">No key trades identified for today</div>'}
                    </div>
                </div>

                <div class="dough-report-section">
                    <h4> Strategy Recommendations</h4>
                    <div class="dough-report-recommendations">
                        ${recommendations.length > 0 ? recommendations.map(rec => `
                            <div class="dough-report-recommendation">${rec}</div>
                        `).join('') : '<div class="text-dim">No specific recommendations for today</div>'}
                    </div>
                </div>

                <div class="dough-report-section">
                    <h4> Agent Insights</h4>
                    <div class="dough-report-recommendations">
                        ${agentInsights.length > 0 ? agentInsights.map(insight => `
                            <div class="dough-report-recommendation">
                                <strong>${insight.agent}:</strong> ${insight.insight}
                            </div>
                        `).join('') : '<div class="text-dim">Agent insights loading...</div>'}
                    </div>
                </div>
            `);

            // Show the container
            container.style.display = 'block';
            console.log(' [DOUGH_REPORT] Report displayed successfully');
        }

        function hideDoughReport() {
            const container = document.getElementById('doughReportContainer');
            container.style.display = 'none';
            console.log(' [DOUGH_REPORT] Report hidden (no report available)');
        }

        function updatePortfolioSummary(summary) {
            const allocationContainer = document.getElementById('portfolioAllocationContainer');
            const insightsContainer = document.getElementById('portfolioInsightsContainer');

            if (!summary || !summary.timestamp) {
                safeSetHTML(allocationContainer, '<div class="text-dim">No allocation data available</div>');
                safeSetHTML(insightsContainer, '<div class="text-dim">No insights available</div>');
                return;
            }

            // Update allocation side
            let allocationHtml = '';

            if (summary.total_value) {
                allocationHtml += `<div class="metric-item"><span class="metric-label">Total Value:</span> <span class="metric-value">$${summary.total_value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span></div>`;
            }

            if (summary.allocation) {
                allocationHtml += `<div class="metric-item"><span class="metric-label">Allocation:</span></div>`;
                for (const [key, value] of Object.entries(summary.allocation)) {
                    allocationHtml += `<div class="allocation-item">${key}: <span class="allocation-value">${value}%</span></div>`;
                }
            }

            if (summary.performance) {
                allocationHtml += `<div class="metric-item"><span class="metric-label">Performance:</span></div>`;
                for (const [key, value] of Object.entries(summary.performance)) {
                    const colorClass = value >= 0 ? 'text-profit' : 'text-loss';
                    allocationHtml += `<div class="performance-item">${key}: <span class="${colorClass}">${value >= 0 ? '+' : ''}${value}%</span></div>`;
                }
            }

            if (summary.risk_metrics) {
                allocationHtml += `<div class="metric-item"><span class="metric-label">Risk Metrics:</span></div>`;
                for (const [key, value] of Object.entries(summary.risk_metrics)) {
                    allocationHtml += `<div class="risk-item">${key}: <span class="risk-value">${value}</span></div>`;
                }
            }

            safeSetHTML(allocationContainer, allocationHtml || '<div class="text-dim">No allocation data available</div>');

            // Update insights side
            let insightsHtml = '';
            if (summary.insights && summary.insights.length > 0) {
                insightsHtml += `<div class="insights-header">Portfolio Insights</div>`;
                summary.insights.forEach(insight => {
                    insightsHtml += `<div class="insight-item"> ${insight}</div>`;
                });
            } else {
                insightsHtml = '<div class="text-dim">No insights available</div>';
            }

            safeSetHTML(insightsContainer, insightsHtml);
        }

        function updateEquityAnalysis(summary) {
            const container = document.getElementById('equityAnalysisContainer');
            if (!summary || !summary.timestamp) {
                safeSetHTML(container, '<div class="text-dim">No equity analysis available</div>');
                return;
            }

            let html = '';

            // Handle both data structures:
            // 1. Agent analysis: summary.positions (array)
            // 2. Portfolio API: summary.positions (array in summary object)
            let positions = summary.positions;
            if (!positions && summary.portfolio_summary && summary.portfolio_summary.positions) {
                positions = summary.portfolio_summary.positions;
            }

            if (positions && positions.length > 0) {
                positions.forEach(pos => {
                    const pnlAmount = pos.unrealized_pnl || 0;
                    const pnlPercent = pos.unrealized_pnl_percent ? parseFloat(pos.unrealized_pnl_percent.replace('%', '')) : 0;
                    const pnlClass = pnlAmount >= 0 ? 'positive' : 'negative';
                    const trendClass = pnlAmount >= 0 ? 'bullish' : 'bearish';

                    html += `
                        <div class="stock-position-card">
                            <div class="stock-card-header">
                                <div class="stock-symbol">${pos.symbol}</div>
                                <div class="stock-trend ${trendClass}">${pnlAmount >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%</div>
                            </div>
                            <div class="stock-card-content">
                                <div class="stock-metrics-grid">
                                    <div class="stock-metric">
                                        <span class="metric-label">Qty:</span>
                                        <span class="metric-value">${pos.quantity}</span>
                                    </div>
                                    <div class="stock-metric">
                                        <span class="metric-label">Current:</span>
                                        <span class="metric-value">$${pos.current_price ? parseFloat(pos.current_price).toFixed(2) : '0.00'}</span>
                                    </div>
                                    <div class="stock-metric">
                                        <span class="metric-label">Avg Cost:</span>
                                        <span class="metric-value">$${pos.avg_entry_price ? pos.avg_entry_price.toFixed(2) : '0.00'}</span>
                                    </div>
                                    <div class="stock-metric">
                                        <span class="metric-label">Value:</span>
                                        <span class="metric-value">$${parseFloat(pos.market_value).toLocaleString()}</span>
                                    </div>
                                    <div class="stock-metric">
                                        <span class="metric-label">P&L:</span>
                                        <span class="metric-value ${pnlClass}">${pnlAmount >= 0 ? '+' : ''}$${pnlAmount.toFixed(2)}</span>
                                    </div>
                                    <div class="stock-metric">
                                        <span class="metric-label">P&L %:</span>
                                        <span class="metric-value ${pnlClass}">${pos.unrealized_pnl_percent || (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%'}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
            }

            safeSetHTML(container, html || '<div class="text-dim">No data available</div>');
        }

        function updateOptionsAnalysis(analysis) {
            const container = document.getElementById('optionsAnalysisContainer');
            if (!analysis || !analysis.timestamp) {
                safeSetHTML(container, '<div class="text-dim">No options analysis available</div>');
                return;
            }

            let html = `<div class="options-full-width-card">`;

            // Header section
            html += `<div class="options-card-header">
                <h3 class="options-card-title">Options Analysis</h3>
                <div class="options-card-timestamp">${new Date(analysis.timestamp).toLocaleString()}</div>
            </div>`;

            // Content grid
            html += `<div class="options-content-grid">`;

            // Active Strategies Section
            if (analysis.positions && analysis.positions.length > 0) {
                html += `<div class="options-section">
                    <h4 class="options-section-title">Active Strategies</h4>
                    <div class="options-strategies-grid">`;

                analysis.positions.forEach(pos => {
                    const pnlClass = (pos.pnl || 0) >= 0 ? 'text-profit' : 'text-loss';
                    html += `<div class="options-strategy-card">
                        <div class="strategy-header">
                            <strong>${pos.symbol}</strong>
                            <span class="strategy-type">${pos.strategy}</span>
                        </div>
                        <div class="strategy-details">
                            <div>Strike: $${pos.strike}</div>
                            <div>Exp: ${pos.expiration}</div>
                        </div>
                        <div class="strategy-metrics">
                            <div class="pnl ${pnlClass}">P&L: ${(pos.pnl || 0) >= 0 ? '+' : ''}$${(pos.pnl || 0).toFixed(2)}</div>
                            ${pos.delta !== undefined ? `<div class="greek">: ${pos.delta.toFixed(2)}</div>` : ''}
                            ${pos.theta !== undefined ? `<div class="greek">: ${pos.theta.toFixed(2)}</div>` : ''}
                        </div>
                    </div>`;
                });
                html += `</div></div>`;
            }

            // Portfolio Greeks Section
            if (analysis.greeks_summary && Object.keys(analysis.greeks_summary).length > 0) {
                html += `<div class="options-section">
                    <h4 class="options-section-title">Portfolio Greeks</h4>
                    <div class="greeks-grid">`;
                for (const [greek, value] of Object.entries(analysis.greeks_summary)) {
                    html += `<div class="greek-item">
                        <span class="greek-label">${greek}:</span>
                        <span class="greek-value">${value}</span>
                    </div>`;
                }
                html += `</div></div>`;
            }

            // Risk Assessment Section
            if (analysis.risk_assessment) {
                html += `<div class="options-section">
                    <h4 class="options-section-title">Risk Assessment</h4>
                    <div class="risk-grid">`;
                for (const [key, value] of Object.entries(analysis.risk_assessment)) {
                    html += `<div class="risk-item">
                        <span class="risk-label">${key}:</span>
                        <span class="risk-value">${value}</span>
                    </div>`;
                }
                html += `</div></div>`;
            }

            // Insights Section
            if (analysis.insights && analysis.insights.length > 0) {
                html += `<div class="options-section full-width">
                    <h4 class="options-section-title">Insights</h4>
                    <div class="insights-list">`;
                analysis.insights.forEach(insight => {
                    html += `<div class="insight-item"> ${insight}</div>`;
                });
                html += `</div></div>`;
            }

            html += `</div></div>`; // Close content grid and main card

            safeSetHTML(container, html || '<div class="text-dim">No data available</div>');
        }

        function updateMarketOutlook(outlook) {
            const container = document.getElementById('marketConditionsGrid');
            if (!container) {
                console.warn(' marketConditionsGrid element not found - skipping market outlook update');
                return;
            }
            if (!outlook || !outlook.timestamp) {
                safeSetHTML(container, '<div class="text-dim">No market outlook available</div>');
                return;
            }

            let html = '';

            // Market Condition Card
            if (outlook.market_condition) {
                html += `
                    <div class="sector-card">
                        <div class="sector-card-header">
                            <div class="sector-card-title">Market Condition</div>
                            <div class="sector-card-trend neutral">Overall</div>
                        </div>
                        <div class="sector-card-content">
                            <div class="sector-card-description">${outlook.market_condition}</div>
                        </div>
                    </div>
                `;
            }

            // Sector Analysis Cards
            if (outlook.sector_analysis && Object.keys(outlook.sector_analysis).length > 0) {
                for (const [sector, data] of Object.entries(outlook.sector_analysis)) {
                    let trend = 'neutral';
                    let description = '';

                    if (typeof data === 'object') {
                        // Extract trend information if available
                        if (data.trend) {
                            trend = data.trend.toLowerCase().includes('bull') ? 'bullish' :
                                   data.trend.toLowerCase().includes('bear') ? 'bearish' : 'neutral';
                        }
                        // Build description from object data
                        const entries = Object.entries(data).filter(([key]) => key !== 'trend');
                        description = entries.map(([key, value]) => `${key}: ${value}`).join('  ');
                    } else {
                        description = data;
                    }

                    html += `
                        <div class="sector-card">
                            <div class="sector-card-header">
                                <div class="sector-card-title">${sector}</div>
                                <div class="sector-card-trend ${trend}">${trend}</div>
                            </div>
                            <div class="sector-card-content">
                                <div class="sector-card-description">${description}</div>
                            </div>
                        </div>
                    `;
                }
            }

            // Volatility Card
            if (outlook.volatility && Object.keys(outlook.volatility).length > 0) {
                let volatilityDescription = '';
                for (const [key, value] of Object.entries(outlook.volatility)) {
                    if (typeof value === 'object') {
                        const subEntries = Object.entries(value).map(([subKey, subValue]) => `${subKey}: ${subValue}`).join('  ');
                        volatilityDescription += `${key}: ${subEntries} `;
                    } else {
                        volatilityDescription += `${key.replace(/_/g, ' ')}: ${value} `;
                    }
                }

                html += `
                    <div class="sector-card">
                        <div class="sector-card-header">
                            <div class="sector-card-title">Volatility</div>
                            <div class="sector-card-trend neutral">Analysis</div>
                        </div>
                        <div class="sector-card-content">
                            <div class="sector-card-description">${volatilityDescription.trim()}</div>
                        </div>
                    </div>
                `;
            }

            // Opportunities Card
            if (outlook.opportunities && outlook.opportunities.length > 0) {
                const opportunitiesText = outlook.opportunities.join('  ');
                html += `
                    <div class="sector-card">
                        <div class="sector-card-header">
                            <div class="sector-card-title">Opportunities</div>
                            <div class="sector-card-trend bullish">Positive</div>
                        </div>
                        <div class="sector-card-content">
                            <div class="sector-card-description">${opportunitiesText}</div>
                        </div>
                    </div>
                `;
            }

            // Risks Card
            if (outlook.risks && outlook.risks.length > 0) {
                const risksText = outlook.risks.join('  ');
                html += `
                    <div class="sector-card">
                        <div class="sector-card-header">
                            <div class="sector-card-title">Risks</div>
                            <div class="sector-card-trend bearish">Caution</div>
                        </div>
                        <div class="sector-card-content">
                            <div class="sector-card-description">${risksText}</div>
                        </div>
                    </div>
                `;
            }

            safeSetHTML(container, html || '<div class="text-dim">No market data available</div>');
        }

        // New SVG-based chart drawing function for shadcn-style area charts
        function drawSVGChart() {
            const data = chartData[currentPeriod];
            if (!data || data.length === 0) return;

            const svgRect = window.chartSVG.getBoundingClientRect();
            const width = 800; // SVG viewBox width
            const height = 300; // SVG viewBox height
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Calculate value range
            const minValue = Math.min(...data.map(d => d.value));
            const maxValue = Math.max(...data.map(d => d.value));
            let valueRange = maxValue - minValue;

            // Handle flat line case
            if (valueRange === 0) {
                valueRange = maxValue * 0.1;
            }

            const displayMin = valueRange === maxValue * 0.1 ? maxValue - valueRange / 2 : minValue;
            const displayMax = valueRange === maxValue * 0.1 ? maxValue + valueRange / 2 : maxValue;
            const displayRange = displayMax - displayMin;

            // Generate SVG path for area and line
            let areaPath = `M ${padding} ${height - padding}`;
            let linePath = '';

            data.forEach((point, index) => {
                const x = padding + (index / (data.length - 1)) * chartWidth;
                const y = padding + (1 - (point.value - displayMin) / displayRange) * chartHeight;

                if (index === 0) {
                    linePath = `M ${x} ${y}`;
                    areaPath += ` L ${x} ${y}`;
                } else {
                    linePath += ` L ${x} ${y}`;
                    areaPath += ` L ${x} ${y}`;
                }
            });

            // Close the area path
            areaPath += ` L ${padding + chartWidth} ${height - padding} Z`;

            // Update SVG paths with gradient fill
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const gradientId = isDark ? 'chartGradientDark' : 'chartGradientLight';

            window.chartAreaPath.setAttribute('d', areaPath);
            window.chartAreaPath.setAttribute('fill', `url(#${gradientId})`);
            window.chartLinePath.setAttribute('d', linePath);

            // Update axis labels
            updateAxisLabels(data, displayMin, displayMax, padding, chartWidth, chartHeight, width, height);

            // Update chart title with current value
            const currentValue = data[data.length - 1]?.value || 0;

            // Calculate daily change (from start of day to current)
            const startOfDayValue = data[0]?.value || currentValue;
            const dailyChange = currentValue - startOfDayValue;
            const dailyChangePercent = startOfDayValue !== 0 ? ((dailyChange / startOfDayValue) * 100) : 0;

            document.getElementById('portfolioChartTitle').textContent =
                ` $${currentValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

            // Update trend indicator with both dollar amount and percentage
            const dollarSign = dailyChange >= 0 ? '+' : '';
            const trendDirection = dailyChange >= 0 ? 'up' : 'down';
            const formattedChange = Math.abs(dailyChange).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

            const trendText = `Trending ${trendDirection} ${dollarSign}$${formattedChange} (${dailyChangePercent >= 0 ? '+' : ''}${dailyChangePercent.toFixed(2)}%) ${getPeriodText(currentPeriod)}`;

            const trendElement = document.getElementById('chartTrendText');
            if (trendElement) {
                trendElement.textContent = trendText;
                // Apply color directly to the text element instead of parent
                trendElement.style.color = dailyChange >= 0 ? 'var(--color-success)' : 'var(--color-error)';

                // Also update the parent container color for the icon
                const parentElement = trendElement.parentElement;
                if (parentElement) {
                    parentElement.style.color = dailyChange >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                }

                // Also update the trend icon to point up or down
                const trendIcon = trendElement.parentElement.querySelector('.trend-icon');
                if (trendIcon) {
                    if (dailyChange >= 0) {
                        // Arrow pointing UP
                        trendIcon.innerHTML = '<path d="M12 19V5M5 12l7-7 7 7"/>';
                    } else {
                        // Arrow pointing DOWN
                        trendIcon.innerHTML = '<path d="M12 5v14M19 12l-7 7-7-7"/>';
                    }
                }
            }

            // Update last update time
            const lastUpdateElement = document.getElementById('chartLastUpdate');
            if (lastUpdateElement) {
                lastUpdateElement.textContent = new Date().toLocaleTimeString();
            }
        }

        function updateAxisLabels(data, minValue, maxValue, padding, chartWidth, chartHeight, width, height) {
            // Clear existing labels
            const yAxisLabels = document.getElementById('yAxisLabels');
            const xAxisLabels = document.getElementById('xAxisLabels');

            if (yAxisLabels) yAxisLabels.textContent = '';
            if (xAxisLabels) xAxisLabels.textContent = '';

            // Y-axis labels (price levels)
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const value = minValue + (maxValue - minValue) * (1 - i / ySteps);
                const y = padding + (i / ySteps) * chartHeight;

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding - 10);
                text.setAttribute('y', y + 3);
                text.setAttribute('text-anchor', 'end');
                text.textContent = `$${value.toFixed(0)}`;
                yAxisLabels.appendChild(text);
            }

            // X-axis labels (time)
            const xSteps = Math.min(5, data.length - 1);
            for (let i = 0; i <= xSteps; i++) {
                const dataIndex = Math.floor((i / xSteps) * (data.length - 1));
                const point = data[dataIndex];
                const x = padding + (dataIndex / (data.length - 1)) * chartWidth;

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', height - padding + 20);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = point.label || new Date(point.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                xAxisLabels.appendChild(text);
            }
        }

        function drawChart() {
            // Update chart data and recreate D3 chart
            if (currentChartData && currentChartData.length > 0) {
                createD3Chart();

                // Update chart title with current value
                const currentValue = currentChartData[currentChartData.length - 1]?.value;
                if (currentValue) {
                    updateChartTitle(currentValue);
                }
            }
        }

        function setupChartEventListeners() {
            // Filter buttons for main portfolio chart only - remove existing listeners first to prevent duplicates
            document.querySelectorAll('.chart-card .chart-filter').forEach(button => {
                // Clone the button to remove all existing event listeners
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);

                // Add fresh event listener to the new button
                newButton.addEventListener('click', async function() {
                    // Prevent duplicate calls when chart data is already being fetched
                    if (isFetchingChartData) {
                        console.log(` Chart filter click ignored - data fetch already in progress for ${this.dataset.period}`);
                        return;
                    }

                    // Update active state
                    document.querySelectorAll('.chart-card .chart-filter').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');

                    // Update period and get real portfolio history data
                    currentPeriod = this.dataset.period;
                    currentChartData = await fetchRealPortfolioHistory(currentPeriod);

                    // Recreate the D3 chart with new data
                    createD3Chart();
                });
            });

            // Handle window resize
            window.addEventListener('resize', function() {
                createD3Chart();
            });

            // Add refresh button event listener
            const chartRefreshBtn = document.getElementById('chartRefreshBtn');
            if (chartRefreshBtn) {
                // Remove existing event listeners by cloning the button
                const newRefreshBtn = chartRefreshBtn.cloneNode(true);
                chartRefreshBtn.parentNode.replaceChild(newRefreshBtn, chartRefreshBtn);

                // Add fresh event listener
                newRefreshBtn.addEventListener('click', refreshChartData);
                console.log(' Chart refresh button event listener added');
            }
        }

        // Stock Detail Page functionality
        let currentStock = null;
        let stockChart = null;
        let stockChartData = {};

        // Stock names and descriptions database
        const stockInfo = {
            'AAPL': {
                name: 'Apple Inc.',
                description: 'Apple Inc. designs, manufactures, and markets smartphones, personal computers, tablets, wearables, and accessories worldwide. The company serves consumers, and small and mid-sized businesses; and the education, enterprise, and government markets.',
                url: 'https://www.apple.com',
                employees: 164000,
                founded: 1976,
                analystReview: 'Strong buy recommendation driven by robust iPhone sales and services growth. Analysts remain bullish on AI integration and wearables expansion.'
            },
            'MSFT': {
                name: 'Microsoft Corporation',
                description: 'Microsoft Corporation develops, licenses, and supports software, services, devices, and solutions worldwide. The company operates in productivity and business processes, intelligent cloud, and more personal computing segments.',
                url: 'https://www.microsoft.com',
                employees: 221000,
                founded: 1975,
                analystReview: 'Analysts favor Microsoft\'s cloud dominance and AI leadership. Azure growth and Office 365 subscriptions drive consistent revenue streams.'
            },
            'GOOGL': {
                name: 'Alphabet Inc.',
                description: 'Alphabet Inc. provides online advertising services in the United States, Europe, the Middle East, Africa, the Asia-Pacific, Canada, and Latin America. The company offers performance and brand advertising services.',
                url: 'https://www.google.com',
                employees: 190000,
                founded: 1998,
                analystReview: 'Mixed sentiment on regulatory challenges, but strong advertising revenue and AI capabilities support long-term growth prospects.'
            },
            'AMZN': {
                name: 'Amazon.com Inc.',
                description: 'Amazon.com, Inc. engages in the retail sale of consumer products and subscriptions in North America and internationally. The company operates through three segments: North America, International, and Amazon Web Services.',
                url: 'https://www.amazon.com',
                employees: 1540000,
                founded: 1994,
                analystReview: 'AWS continues to drive profitability while retail margins improve. Analysts cite strong logistics network and cloud market leadership.'
            },
            'NVDA': {
                name: 'NVIDIA Corporation',
                description: 'NVIDIA Corporation operates as a computing company in the United States, Taiwan, China, Hong Kong, and internationally. The company operates in two segments, GPU and Tegra Processor.',
                url: 'https://www.nvidia.com',
                employees: 29600,
                founded: 1993,
                analystReview: 'Overwhelming buy consensus driven by AI chip demand and data center growth. Analysts see sustained competitive moats in AI hardware.'
            },
            'TSLA': {
                name: 'Tesla Inc.',
                description: 'Tesla, Inc. designs, develops, manufactures, leases, and sells electric vehicles, and energy generation and storage systems in the United States, China, and internationally.',
                url: 'https://www.tesla.com',
                employees: 140000,
                founded: 2003,
                analystReview: 'Polarized analyst opinions on valuation, but consensus supports EV market leadership and energy storage potential.'
            },
            'META': {
                name: 'Meta Platforms Inc.',
                description: 'Meta Platforms, Inc. develops products that enable people to connect and share with friends and family through mobile devices, personal computers, virtual reality headsets, and wearables worldwide.',
                url: 'https://www.meta.com',
                employees: 77800,
                founded: 2004,
                analystReview: 'Analysts bullish on metaverse investments and VR/AR potential, despite current profitability challenges in Reality Labs segment.'
            },
            'JPM': {
                name: 'JPMorgan Chase & Co.',
                description: 'JPMorgan Chase & Co. operates as a financial services company worldwide. It operates through Consumer & Community Banking, Corporate & Investment Bank, Commercial Banking, and Asset & Wealth Management segments.',
                url: 'https://www.jpmorganchase.com',
                employees: 296000,
                founded: 1799,
                analystReview: 'Strong buy ratings supported by robust loan growth, rising interest rates, and excellent credit quality metrics.'
            }
        };

        // Global flag to track if real price data has been loaded
        let realPriceDataLoaded = false;

        async function showStockDetail(symbol) {
            currentStock = symbol;
            realPriceDataLoaded = false; // Reset flag for new stock

            // Hide dashboard and show stock detail page
            document.querySelector('.terminal-container:not(.stock-detail-page)').style.display = 'none';
            document.getElementById('stockDetailPage').style.display = 'block';

            // Show loading state
            document.getElementById('stockName').textContent = 'Loading...';
            document.getElementById('stockSymbol').textContent = symbol;
            document.getElementById('stockChartTitle').textContent = symbol;
            document.getElementById('stockDescription').textContent = 'Loading company information...';

            try {
                // Fetch real stock detail data from API
                const response = await fetch(`/api/stock_detail/${symbol}`);
                const data = await response.json();

                if (data.success) {
                    const stockData = data;
                    console.log(' v4.2 - Stock detail API data received:', stockData.symbol, 'Price:', stockData.price_data?.current_price);

                    // Update stock header info with real data
                    document.getElementById('stockName').textContent = stockData.company_info.name || `${symbol} Corporation`;
                    document.getElementById('stockDescription').textContent = stockData.company_info.description || 'Company information not available.';

                    // Update company details
                    const companyUrl = document.getElementById('companyUrl');
                    if (stockData.company_info.website) {
                        companyUrl.href = stockData.company_info.website;
                        companyUrl.textContent = stockData.company_info.website.replace('https://', '').replace('www.', '');
                    } else {
                        companyUrl.href = '#';
                        companyUrl.textContent = 'N/A';
                    }

                    document.getElementById('companyEmployees').textContent = stockData.company_info.employees ?
                        stockData.company_info.employees.toLocaleString() : 'N/A';
                    document.getElementById('companyFounded').textContent = stockData.company_info.founded || 'N/A';

                    // Update StockTwits link
                    const stocktwitsLink = document.getElementById('stocktwitsLink');
                    stocktwitsLink.href = `https://stocktwits.com/symbol/${symbol}`;
                    console.log(` StockTwits link set: https://stocktwits.com/symbol/${symbol}`);

                    // Update analyst review with real data
                    if (stockData.analyst_data && stockData.analyst_data.recommendation) {
                        const analystText = `${stockData.analyst_data.recommendation.toUpperCase()} recommendation from ${stockData.analyst_data.analyst_count || 'multiple'} analysts. ${stockData.analyst_data.summary || ''}`;
                        document.getElementById('analystReview').textContent = analystText;
                    } else {
                        document.getElementById('analystReview').textContent = 'No analyst reviews available for this stock.';
                    }

                    // Update stock price and change with real data
                    if (stockData.price_data && stockData.price_data.current_price) {
                        document.getElementById('stockPrice').textContent = `$${stockData.price_data.current_price.toFixed(2)}`;

                        // Calculate change percent from previous close if available
                        const currentPrice = stockData.price_data.current_price;
                        const previousClose = stockData.price_data.previous_close;
                        let change = 0;

                        if (previousClose && previousClose > 0) {
                            change = ((currentPrice - previousClose) / previousClose) * 100;
                        }

                        const changeElement = document.getElementById('stockChange');
                        const changeSymbol = change >= 0 ? '+' : '';
                        changeElement.textContent = `${changeSymbol}${change.toFixed(2)}%`;
                        changeElement.className = `stock-change ${change >= 0 ? 'positive' : 'negative'}`;

                        console.log(` Updated ${symbol} price in detail view: $${currentPrice.toFixed(2)} (${changeSymbol}${change.toFixed(2)}%)`);
                        realPriceDataLoaded = true; // Mark that real price data has been loaded
                    } else {
                        console.log(` No price data available for ${symbol} in API response`);
                    }

                    // Update financial metrics with real data
                    updateFinancialMetrics(stockData.financial_metrics);

                } else {
                    // Fallback to basic info if API fails
                    document.getElementById('stockName').textContent = `${symbol} Corporation`;
                    document.getElementById('stockDescription').textContent = 'Company information temporarily unavailable.';
                    document.getElementById('analystReview').textContent = 'Analyst data temporarily unavailable.';

                    // Still set StockTwits link
                    document.getElementById('stocktwitsLink').href = `https://stocktwits.com/symbol/${symbol}`;

                    console.error('Failed to load stock detail data:', data.error);
                }

            } catch (error) {
                // Fallback on network error
                document.getElementById('stockName').textContent = `${symbol} Corporation`;
                document.getElementById('stockDescription').textContent = 'Unable to load company information at this time.';
                document.getElementById('analystReview').textContent = 'Unable to load analyst data at this time.';

                // Still set StockTwits link
                document.getElementById('stocktwitsLink').href = `https://stocktwits.com/symbol/${symbol}`;

                console.error('Error fetching stock detail:', error);
            }

            // Generate realistic stock data for charts
            generateStockData(symbol);

            // Initialize stock chart
            initializeStockChart();

            // Initialize earnings chart
            initializeEarningsChart(symbol);

            // Load StockTwits data
            loadStockTwitsData(symbol);

            // Update remaining sections with data
            updateStockDataSections(symbol);
        }

        function generateTimeSeriesData(startTime, durationMs, numPoints, basePrice) {
            const data = [];
            const timeStep = durationMs / numPoints;
            let currentPrice = basePrice;

            for (let i = 0; i < numPoints; i++) {
                const timestamp = startTime - durationMs + (i * timeStep);

                // Add realistic price variation
                const volatility = 0.02; // 2% volatility
                const randomChange = (Math.random() - 0.5) * volatility;
                currentPrice = currentPrice * (1 + randomChange);

                // Ensure price doesn't deviate too much from base price
                const maxDeviation = 0.15; // 15% max deviation
                const minPrice = basePrice * (1 - maxDeviation);
                const maxPrice = basePrice * (1 + maxDeviation);
                currentPrice = Math.max(minPrice, Math.min(maxPrice, currentPrice));

                data.push({
                    timestamp: timestamp,
                    price: parseFloat(currentPrice.toFixed(2)),
                    volume: Math.floor(Math.random() * 1000000) + 100000 // Random volume
                });
            }

            return data;
        }

        function generateStockData(symbol) {
            const now = Date.now();
            let basePrice = getRandomPrice(symbol);

            // Use real price if available instead of demo price
            if (realPriceDataLoaded) {
                const stockPriceElement = document.getElementById('stockPrice');
                if (stockPriceElement && stockPriceElement.textContent) {
                    const realPrice = parseFloat(stockPriceElement.textContent.replace('$', ''));
                    if (!isNaN(realPrice) && realPrice > 0) {
                        basePrice = realPrice;
                        console.log(` Using real price $${realPrice} for ${symbol} chart data generation`);
                    }
                }
            }

            // Generate chart data for different periods
            stockChartData = {
                '1h': generateTimeSeriesData(now, 60 * 60 * 1000, 60, basePrice),
                '1d': generateTimeSeriesData(now, 24 * 60 * 60 * 1000, 24, basePrice),
                '1w': generateTimeSeriesData(now, 7 * 24 * 60 * 60 * 1000, 168, basePrice),
                '1m': generateTimeSeriesData(now, 30 * 24 * 60 * 60 * 1000, 30, basePrice),
                '1y': generateTimeSeriesData(now, 365 * 24 * 60 * 60 * 1000, 52, basePrice)
            };
        }

        function getRandomPrice(symbol) {
            // Base prices for different symbols
            const basePrices = {
                'AAPL': 175, 'MSFT': 420, 'GOOGL': 140, 'AMZN': 170, 'NVDA': 880,
                'TSLA': 250, 'META': 520, 'JPM': 185, 'BAC': 35, 'WMT': 165
            };
            return basePrices[symbol] || 100 + Math.random() * 100;
        }

        function updateFinancialMetrics(financialData) {
            if (!financialData) return;

            // Update statistics with real data when available
            if (financialData.volume !== undefined) {
                document.getElementById('statVolume').textContent = formatVolume(financialData.volume);
            }

            if (financialData.market_cap !== undefined) {
                document.getElementById('statMarketCap').textContent = formatMarketCap(financialData.market_cap);
            }

            if (financialData.pe_ratio !== undefined) {
                document.getElementById('statPE').textContent = financialData.pe_ratio.toFixed(1);
            }

            if (financialData.dividend_yield !== undefined) {
                document.getElementById('statDividend').textContent = financialData.dividend_yield.toFixed(2) + '%';
            }

            if (financialData.day_high !== undefined) {
                document.getElementById('statHigh').textContent = '$' + financialData.day_high.toFixed(2);
            }

            if (financialData.day_low !== undefined) {
                document.getElementById('statLow').textContent = '$' + financialData.day_low.toFixed(2);
            }

            if (financialData.day_open !== undefined) {
                document.getElementById('statOpen').textContent = '$' + financialData.day_open.toFixed(2);
            }

            if (financialData['52_week_high'] !== undefined) {
                document.getElementById('stat52High').textContent = '$' + financialData['52_week_high'].toFixed(2);
            }

            if (financialData['52_week_low'] !== undefined) {
                document.getElementById('stat52Low').textContent = '$' + financialData['52_week_low'].toFixed(2);
            }

            if (financialData.avg_volume !== undefined) {
                document.getElementById('statAvgVolume').textContent = formatVolume(financialData.avg_volume);
            }
        }

        function formatVolume(volume) {
            if (volume >= 1000000000) {
                return (volume / 1000000000).toFixed(1) + 'B';
            } else if (volume >= 1000000) {
                return (volume / 1000000).toFixed(1) + 'M';
            } else if (volume >= 1000) {
                return (volume / 1000).toFixed(1) + 'K';
            }
            return volume.toString();
        }

        function updateStockDataSections(symbol) {
            const currentData = stockChartData['1d'];
            const latestPrice = currentData[currentData.length - 1].value;

            // Update analyst ratings with fallback demo data if not already updated by real API
            if (!document.getElementById('ratingBuy').textContent.includes('%')) {
                const buyRating = 50 + Math.random() * 40;
                const sellRating = Math.random() * 20;
                const holdRating = 100 - buyRating - sellRating;

                document.getElementById('ratingBuy').textContent = buyRating.toFixed(0) + '%';
                document.getElementById('ratingHold').textContent = holdRating.toFixed(0) + '%';
                document.getElementById('ratingSell').textContent = sellRating.toFixed(0) + '%';
            }
        }

        function updateStockData(symbol) {
            const currentData = stockChartData['1d'];
            const latestPrice = currentData[currentData.length - 1].value;
            const previousPrice = currentData[currentData.length - 2].value;
            const change = ((latestPrice - previousPrice) / previousPrice) * 100;

            // Only update price and change if real price data hasn't been loaded
            if (!realPriceDataLoaded) {
                document.getElementById('stockPrice').textContent = '$' + latestPrice.toFixed(2);
                const changeElement = document.getElementById('stockChange');
                const changeSymbol = change >= 0 ? '+' : '';
                changeElement.textContent = changeSymbol + change.toFixed(2) + '%';
                changeElement.className = 'stock-change ' + (change >= 0 ? 'positive' : 'negative');
                console.log(` Using demo price data for ${symbol}: $${latestPrice.toFixed(2)} (real data not available)`);
            } else {
                console.log(` Skipping demo price update for ${symbol} - real price data already loaded`);
            }

            // Update statistics with realistic data
            const mcap = marketCapData[symbol] || 50000;
            const volume = Math.floor(Math.random() * 100) + 'M';
            const avgVolume = Math.floor(Math.random() * 80 + 20) + 'M';

            document.getElementById('statVolume').textContent = volume;
            document.getElementById('statAvgVolume').textContent = avgVolume;
            document.getElementById('statOpen').textContent = '$' + (latestPrice * 0.99).toFixed(2);
            document.getElementById('statHigh').textContent = '$' + (latestPrice * 1.02).toFixed(2);
            document.getElementById('statLow').textContent = '$' + (latestPrice * 0.97).toFixed(2);
            document.getElementById('statMarketCap').textContent = formatMarketCap(mcap);
            document.getElementById('stat52High').textContent = '$' + (latestPrice * 1.35).toFixed(2);
            document.getElementById('stat52Low').textContent = '$' + (latestPrice * 0.68).toFixed(2);
            document.getElementById('statPE').textContent = (15 + Math.random() * 20).toFixed(1);
            document.getElementById('statDividend').textContent = (Math.random() * 3).toFixed(2) + '%';

            // Update analyst ratings
            const buyRating = 50 + Math.random() * 40;
            const sellRating = Math.random() * 20;
            const holdRating = 100 - buyRating - sellRating;

            document.getElementById('ratingBuy').textContent = buyRating.toFixed(0) + '%';
            document.getElementById('ratingHold').textContent = holdRating.toFixed(0) + '%';
            document.getElementById('ratingSell').textContent = sellRating.toFixed(0) + '%';

            // Generate trading history
            updateTradingHistory(symbol, latestPrice);
        }

        function updateTradingHistory(symbol, currentPrice) {
            const historyContainer = document.getElementById('tradingHistory');
            const history = [];

            // Generate some sample trading history
            for (let i = 0; i < 5; i++) {
                const daysAgo = Math.floor(Math.random() * 90) + 1;
                const date = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000);
                const action = Math.random() > 0.5 ? 'BUY' : 'SELL';
                const quantity = Math.floor(Math.random() * 100) + 10;
                const price = currentPrice * (0.8 + Math.random() * 0.4);

                history.push({
                    date: date.toLocaleDateString(),
                    action,
                    quantity,
                    price: price.toFixed(2)
                });
            }

            safeSetHTML(historyContainer, history.map(item =>
                `<div class="history-item">
                    <span>${item.date} ${item.action}</span>
                    <span>${item.quantity} @ $${item.price}</span>
                </div>`
            ).join(''));
        }

        // StockTwits API Integration - Key loaded from backend
        const STOCKTWITS_API_KEY = ''; // Set via environment variable on backend

        async function loadStockTwitsData(symbol) {
            // Load community sentiment and posts from our backend API
            try {
                const response = await fetch(`/api/stocktwits/${symbol}`);
                const data = await response.json();

                if (data.success) {
                    const stockTwitsData = data.data;

                    // Update sentiment display
                    updateSentimentDisplay(stockTwitsData.sentiment);

                    // Display messages/posts
                    displayStockTwitsPosts(stockTwitsData.recent_messages);

                    // Update watchlist count
                    updateWatchlistCount(stockTwitsData.symbol_info);

                } else {
                    console.log(' StockTwits API error:', data.error);

                    // Show error state in sentiment display
                    if (data.data && data.data.sentiment) {
                        updateSentimentDisplay(data.data.sentiment);
                    } else {
                        updateSentimentDisplay({
                            error: 'StockTwits data unavailable',
                            bullish_percent: null,
                            bearish_percent: null,
                            total_messages: null
                        });
                    }

                    // Show error message in posts section
                    const container = document.getElementById('stocktwitsContainer');
                    if (container) {
                        safeSetHTML(container, `
                            <div class="stocktwits-error">
                                <div class="error-message">Unable to load StockTwits data</div>
                                <div class="error-details">${data.error || 'Connection failed'}</div>
                            </div>
                        `);
                    }
                }

            } catch (error) {
                console.log(' StockTwits connection error:', error);

                // Show error state in sentiment display
                updateSentimentDisplay({
                    error: 'Failed to connect to StockTwits',
                    bullish_percent: null,
                    bearish_percent: null,
                    total_messages: null
                });

                // Show error message in posts section
                const container = document.getElementById('stocktwitsContainer');
                if (container) {
                    safeSetHTML(container, `
                        <div class="stocktwits-error">
                            <div class="error-message">Connection to StockTwits failed</div>
                            <div class="error-details">Please try again later</div>
                        </div>
                    `);
                }
            }
        }

        function loadStockTwitsSentiment(symbol) {
            const options = {
                method: 'GET',
                headers: {
                    'X-RapidAPI-Key': STOCKTWITS_API_KEY,
                    'X-RapidAPI-Host': 'stocktwits.p.rapidapi.com'
                }
            };

            // Try to fetch sentiment data from StockTwits API
            fetch(`https://stocktwits.p.rapidapi.com/streams/symbol/${symbol}.json`, options)
                .then(response => response.json())
                .then(data => {
                    if (data && data.symbol && data.symbol.watchlist_count) {
                        updateSentimentDisplay(data);
                    } else {
                        // Fallback to demo sentiment data
                        showDemoSentiment(symbol);
                    }
                })
                .catch(error => {
                    console.log('StockTwits API error, using demo data:', error);
                    showDemoSentiment(symbol);
                });
        }

        function loadStockTwitsPosts(symbol) {
            const options = {
                method: 'GET',
                headers: {
                    'X-RapidAPI-Key': STOCKTWITS_API_KEY,
                    'X-RapidAPI-Host': 'stocktwits.p.rapidapi.com'
                }
            };

            fetch(`https://stocktwits.p.rapidapi.com/streams/symbol/${symbol}.json?limit=10`, options)
                .then(response => response.json())
                .then(data => {
                    if (data && data.messages) {
                        displayStockTwitsPosts(data.messages);
                    } else {
                        showDemoPosts(symbol);
                    }
                })
                .catch(error => {
                    console.log('StockTwits posts error, using demo data:', error);
                    showDemoPosts(symbol);
                });
        }

        function loadStockTwitsNews(symbol) {
            const options = {
                method: 'GET',
                headers: {
                    'X-RapidAPI-Key': STOCKTWITS_API_KEY,
                    'X-RapidAPI-Host': 'stocktwits.p.rapidapi.com'
                }
            };

            fetch(`https://stocktwits.p.rapidapi.com/streams/symbol/${symbol}.json?filter=links`, options)
                .then(response => response.json())
                .then(data => {
                    if (data && data.messages) {
                        displayStockTwitsNews(data.messages);
                    } else {
                        showDemoNews(symbol);
                    }
                })
                .catch(error => {
                    console.log('StockTwits news error, using demo data:', error);
                    showDemoNews(symbol);
                });
        }

        function updateSentimentDisplay(sentimentData) {
            if (!sentimentData) return;

            // Check if this is an error state
            if (sentimentData.error || sentimentData.bullish_percent === null) {
                document.getElementById('bullishPercent').textContent = 'N/A';
                document.getElementById('bearishPercent').textContent = 'N/A';
                document.getElementById('totalPosts').textContent = sentimentData.error || 'StockTwits data unavailable';
                console.log(' StockTwits sentiment error:', sentimentData.error || 'No data available');
                return;
            }

            // Display real StockTwits data
            document.getElementById('bullishPercent').textContent = sentimentData.bullish_percent + '%';
            document.getElementById('bearishPercent').textContent = sentimentData.bearish_percent + '%';
            document.getElementById('totalPosts').textContent = sentimentData.total_messages.toLocaleString() + ' posts';
            console.log(' Real StockTwits sentiment loaded:', sentimentData.source);

            // Update sentiment bars visually if elements exist
            const bullishBar = document.getElementById('bullishBar');
            const bearishBar = document.getElementById('bearishBar');
            if (bullishBar && bearishBar) {
                bullishBar.style.width = sentimentData.bullish_percent + '%';
                bearishBar.style.width = sentimentData.bearish_percent + '%';
            }
        }

        function updateWatchlistCount(symbolInfo) {
            if (!symbolInfo) return;

            const watchlistElement = document.getElementById('watchlistCount');
            if (watchlistElement && symbolInfo.watchlist_count) {
                watchlistElement.textContent = symbolInfo.watchlist_count.toLocaleString() + ' watching';
            }
        }

        function showDemoSentiment(symbol) {
            const bullishPercent = Math.floor(40 + Math.random() * 30);
            const bearishPercent = 100 - bullishPercent;
            const totalPosts = Math.floor(Math.random() * 5000) + 1000;

            document.getElementById('bullishPercent').textContent = bullishPercent + '%';
            document.getElementById('bearishPercent').textContent = bearishPercent + '%';
            document.getElementById('totalPosts').textContent = totalPosts.toLocaleString();
        }

        function displayStockTwitsPosts(messages) {
            const container = document.getElementById('stocktwitsContainer');

            if (!messages || messages.length === 0) {
                showDemoPosts(currentStock);
                return;
            }

            const postsHTML = messages.slice(0, 8).map(message => {
                // Use the sentiment from our API data format
                const sentiment = message.sentiment || (Math.random() > 0.6 ? 'Bullish' : 'Bearish');
                const timeAgo = formatTimeAgo(new Date(message.created_at));
                const likes = message.likes || Math.floor(Math.random() * 50);
                const reshares = message.reshares || Math.floor(Math.random() * 10);
                const followers = message.user?.followers || Math.floor(Math.random() * 5000);

                // Add sentiment indicator and follower count
                const sentimentClass = sentiment ? sentiment.toLowerCase() : 'neutral';
                const sentimentDisplay = sentiment ? sentiment.toUpperCase() : '';

                return `
                    <div class="stocktwits-post">
                        <div class="post-header">
                            <span class="post-user">@${message.user?.username || 'trader'}</span>
                            <span class="post-followers">${followers.toLocaleString()} followers</span>
                            <div style="display: flex; gap: var(--space-sm); align-items: center;">
                                ${sentiment ? `<span class="post-sentiment ${sentimentClass}">${sentimentDisplay}</span>` : ''}
                                <span class="post-time">${timeAgo}</span>
                            </div>
                        </div>
                        <div class="post-content">${message.body || 'Community discussion about ' + currentStock}</div>
                        <div class="post-stats">
                            <span> ${likes}</span>
                            <span> ${reshares}</span>
                            <span> ${Math.floor(Math.random() * 20)}</span>
                        </div>
                    </div>
                `
            }).join('');

            safeSetHTML(container, postsHTML);
        }

        function showDemoPosts(symbol) {
            const container = document.getElementById('stocktwitsContainer');
            const demoPosts = [
                { user: 'BullishTrader', sentiment: 'Bullish', content: `Strong earnings beat for ${symbol}! This stock is going to the moon `, likes: 42, time: '2h ago' },
                { user: 'MarketAnalyst', sentiment: 'Bullish', content: `Technical analysis shows ${symbol} breaking key resistance levels. Next stop $200+`, likes: 28, time: '4h ago' },
                { user: 'DayTraderPro', sentiment: 'Bearish', content: `Overbought conditions on ${symbol}. Expecting pullback to support levels.`, likes: 15, time: '6h ago' },
                { user: 'InvestorGuru', sentiment: 'Bullish', content: `Long-term outlook for ${symbol} remains very positive. Fundamentals are solid.`, likes: 38, time: '8h ago' },
                { user: 'SwingTrader', sentiment: 'Bullish', content: `${symbol} volume is picking up. Momentum building for next leg up.`, likes: 22, time: '12h ago' }
            ];

            const postsHTML = demoPosts.map(post => `
                <div class="stocktwits-post">
                    <div class="post-header">
                        <span class="post-user">@${post.user}</span>
                        <div style="display: flex; gap: var(--space-sm); align-items: center;">
                            <span class="post-sentiment ${post.sentiment.toLowerCase()}">${post.sentiment.toUpperCase()}</span>
                            <span class="post-time">${post.time}</span>
                        </div>
                    </div>
                    <div class="post-content">${post.content}</div>
                    <div class="post-stats">
                        <span> ${post.likes}</span>
                        <span> ${Math.floor(Math.random() * 20)}</span>
                    </div>
                </div>
            `).join('');

            safeSetHTML(container, postsHTML);
        }

        function displayStockTwitsNews(messages) {
            const container = document.getElementById('newsContainer');
            const newsItems = messages.filter(msg => msg.entities?.links?.length > 0).slice(0, 5);

            if (newsItems.length === 0) {
                showDemoNews(currentStock);
                return;
            }

            const newsHTML = newsItems.map(item => {
                const link = item.entities.links[0];
                const timeAgo = formatTimeAgo(new Date(item.created_at));

                return `
                    <div class="stocktwits-post">
                        <div class="post-header">
                            <span class="post-user"> News</span>
                            <span class="post-time">${timeAgo}</span>
                        </div>
                        <div class="post-content">
                            <a href="${link.url}" target="_blank" class="company-url">${link.title || 'Breaking News'}</a>
                        </div>
                    </div>
                `
            }).join('');

            safeSetHTML(container, newsHTML);
        }

        function showDemoNews(symbol) {
            const container = document.getElementById('newsContainer');
            const demoNews = [
                { title: `${symbol} Reports Strong Q4 Earnings, Beats Estimates`, time: '1h ago' },
                { title: `Analysts Upgrade ${symbol} Price Target on AI Growth`, time: '3h ago' },
                { title: `${symbol} Announces Major Partnership Deal`, time: '6h ago' },
                { title: `Institutional Investors Increase Stakes in ${symbol}`, time: '1d ago' },
                { title: `${symbol} CEO Discusses Future Growth Strategy`, time: '2d ago' }
            ];

            const newsHTML = demoNews.map(item => `
                <div class="stocktwits-post">
                    <div class="post-header">
                        <span class="post-user"> News</span>
                        <span class="post-time">${item.time}</span>
                    </div>
                    <div class="post-content">
                        <a href="#" class="company-url">${item.title}</a>
                    </div>
                </div>
            `).join('');

            safeSetHTML(container, newsHTML);
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diffInMinutes = Math.floor((now - date) / (1000 * 60));

            if (diffInMinutes < 60) return diffInMinutes + 'm ago';
            if (diffInMinutes < 1440) return Math.floor(diffInMinutes / 60) + 'h ago';
            return Math.floor(diffInMinutes / 1440) + 'd ago';
        }

        function initializeStockChart() {
            const canvas = document.getElementById('stockChart');
            if (!canvas) return;

            stockChart = canvas.getContext('2d');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            drawStockChart();
            setupStockChartEventListeners();
        }

        function drawStockChart() {
            if (!stockChart || !currentStock) return;

            const canvas = document.getElementById('stockChart');
            const ctx = stockChart;
            const data = stockChartData[currentPeriod] || stockChartData['1h'];

            if (!data || data.length === 0) return;

            // Use the same drawing logic as the portfolio chart
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--positive').trim();
            ctx.lineWidth = 2;
            ctx.font = '10px monospace';
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

            const padding = 40;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;

            const minValue = Math.min(...data.map(d => d.value));
            const maxValue = Math.max(...data.map(d => d.value));
            const valueRange = maxValue - minValue;

            // Draw grid
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            ctx.lineWidth = 1;

            for (let i = 0; i <= 4; i++) {
                const y = padding + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();

                const value = maxValue - (valueRange / 4) * i;
                ctx.fillText('$' + value.toFixed(2), 5, y + 3);
            }

            // Draw data line
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--positive').trim();
            ctx.lineWidth = 2;
            ctx.beginPath();

            data.forEach((point, index) => {
                const x = padding + (index / (data.length - 1)) * chartWidth;
                const y = padding + chartHeight - ((point.value - minValue) / valueRange) * chartHeight;

                point.x = x;
                point.y = y;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();
        }

        function initializeEarningsChart(symbol) {
            const canvas = document.getElementById('earningsChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Generate realistic earnings data
            const quarters = ['Q1 2024', 'Q2 2024', 'Q3 2024', 'Q4 2024'];
            const baseEPS = getRandomPrice(symbol) * 0.01; // Base EPS relative to stock price
            const earningsData = quarters.map((quarter, index) => ({
                quarter,
                eps: baseEPS * (0.8 + Math.random() * 0.4) + (index * 0.05) // Slight upward trend
            }));

            drawEarningsChart(ctx, canvas, earningsData);
        }

        function drawEarningsChart(ctx, canvas, data) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const padding = 40;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;

            const maxEPS = Math.max(...data.map(d => d.eps));
            const minEPS = Math.min(...data.map(d => d.eps));
            const epsRange = maxEPS - minEPS;

            // Set styles
            ctx.font = '10px monospace';
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

            // Draw grid lines
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let i = 0; i <= 4; i++) {
                const y = padding + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();

                // EPS labels
                const eps = maxEPS - (epsRange / 4) * i;
                ctx.fillText('$' + eps.toFixed(2), 5, y + 3);
            }

            // Draw bars
            const barWidth = chartWidth / data.length * 0.6;
            const barSpacing = chartWidth / data.length;

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--positive').trim();

            data.forEach((item, index) => {
                const barHeight = ((item.eps - minEPS) / epsRange) * chartHeight;
                const x = padding + (index * barSpacing) + (barSpacing - barWidth) / 2;
                const y = padding + chartHeight - barHeight;

                // Draw bar
                ctx.fillRect(x, y, barWidth, barHeight);

                // Draw quarter label
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
                ctx.textAlign = 'center';
                ctx.fillText(item.quarter, x + barWidth / 2, canvas.height - 10);

                // Draw EPS value on top of bar
                ctx.fillText('$' + item.eps.toFixed(2), x + barWidth / 2, y - 5);

                // Reset fill style for bars
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--positive').trim();
                ctx.textAlign = 'left';
            });
        }

        function setupStockChartEventListeners() {
            const canvas = document.getElementById('stockChart');
            const tooltip = document.getElementById('stockChartTooltip');

            // Filter buttons for stock chart
            document.querySelectorAll('#stockDetailPage .chart-filter').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('#stockDetailPage .chart-filter').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentPeriod = this.dataset.period;
                    drawStockChart();
                });
            });

            // Mouse events for stock chart
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const data = stockChartData[currentPeriod];
                let closestPoint = null;
                let closestDistance = Infinity;

                data.forEach(point => {
                    if (point.x !== undefined && point.y !== undefined) {
                        const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                        if (distance < closestDistance && distance < 20) {
                            closestDistance = distance;
                            closestPoint = point;
                        }
                    }
                });

                if (closestPoint) {
                    tooltip.style.display = 'block';
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = (rect.left + mouseX + 15) + 'px';
                    tooltip.style.top = (rect.top + mouseY - 40) + 'px';
                    safeSetHTML(tooltip, `
                        <div>$${closestPoint.value.toFixed(0)}</div>
                        <div style="font-size: var(--text-caption-size); color: var(--text-secondary);">${closestPoint.formattedTime}</div>
                    `);

                    drawStockChart();
                    stockChart.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--positive').trim();
                    stockChart.beginPath();
                    stockChart.arc(closestPoint.x, closestPoint.y, 4, 0, 2 * Math.PI);
                    stockChart.fill();
                } else {
                    tooltip.style.display = 'none';
                    drawStockChart();
                }
            });

            canvas.addEventListener('mouseleave', function() {
                tooltip.style.display = 'none';
                drawStockChart();
            });
        }

        // Navigation and trading controls
        document.getElementById('backBtn').addEventListener('click', function() {
            document.getElementById('stockDetailPage').style.display = 'none';
            document.querySelector('.terminal-container:not(.stock-detail-page)').style.display = 'block';
            currentStock = null;
        });

        document.getElementById('buyBtn').addEventListener('click', function() {
            if (currentStock) {
                const quantity = prompt(`How many shares of ${currentStock} would you like to buy?`);
                if (quantity && !isNaN(quantity) && quantity > 0) {
                    addLogEntry(`Buy order placed: ${quantity} shares of ${currentStock}`);
                    alert(`Buy order placed for ${quantity} shares of ${currentStock}`);
                }
            }
        });

        document.getElementById('sellBtn').addEventListener('click', function() {
            if (currentStock) {
                const quantity = prompt(`How many shares of ${currentStock} would you like to sell?`);
                if (quantity && !isNaN(quantity) && quantity > 0) {
                    addLogEntry(`Sell order placed: ${quantity} shares of ${currentStock}`);
                    alert(`Sell order placed for ${quantity} shares of ${currentStock}`);
                }
            }
        });

        // ASCII Donut Animation
        function initDonutAnimation() {
            const pre = document.getElementById("donutAnimation");
            if (!pre) return;

            let x = 1760, z = 0, y = 0;

            setInterval(() => {
                z += .07;
                y += .03;
                const a = [...new Array(x)].map((a, r) => r % 80 === 79 ? "\n" : " ");
                const r = new Array(x).fill(0);
                const t = Math.cos(z);
                const e = Math.sin(z);
                const n = Math.cos(y);
                const o = Math.sin(y);

                for (let s = 0; s < 6.28; s += .07) {
                    const c = Math.cos(s);
                    const h = Math.sin(s);
                    for (let s = 0; s < 6.28; s += .02) {
                        const v = Math.sin(s);
                        const M = Math.cos(s);
                        const i = c + 2;
                        const l = 1 / (v * i * e + h * t + 5);
                        const p = v * i * t - h * e;
                        const d = 0 | 40 + 30 * l * (M * i * n - p * o);
                        const m = 0 | 12 + 15 * l * (M * i * o + p * n);
                        const f = 0 | 8 * ((h * e - v * c * t) * n - v * c * e - h * t - M * c * o);
                        const y = d + 80 * m;
                        if (m < 22 && m >= 0 && d >= 0 && d < 79 && l > r[y]) {
                            r[y] = l;
                            a[y] = ".,-~:;=!*#$@"[f > 0 ? f : 0];
                        }
                    }
                }
                pre.textContent = a.join("");
            }, 50);
        }

        // Strategy Preparation Functions
        async function loadNextDayStrategy() {
            try {
                const response = await fetch('/api/next_day_strategy');
                const data = await response.json();
                displayStrategyData(data);
            } catch (error) {
                console.error('Error loading strategy:', error);
                safeSetHTML(document.getElementById('strategyPrepStatus'),
                    '<div class="status-indicator"> Error loading strategy</div>');
            }
        }

        function displayStrategyData(data) {
            const statusElement = document.getElementById('strategyPrepStatus');
            const contentElement = document.getElementById('strategyPrepContent');

            // Check if required elements exist
            if (!statusElement || !contentElement) {
                console.warn(' Strategy display elements not found - skipping strategy update');
                return;
            }

            // Update the section title based on market hours
            const marketOutlookTitle = document.querySelector('#analysis-tab .terminal-section .section-title');
            const now = new Date();
            const hour = now.getHours();
            const day = now.getDay(); // 0 = Sunday, 6 = Saturday

            // Market hours: Monday-Friday 9:30 AM - 4:00 PM EST
            // Simplified check: weekday between 9:30 AM and 4:00 PM
            const isMarketHours = (day >= 1 && day <= 5) && (hour >= 9 && hour < 16);
            const strategyType = isMarketHours ? "Current Strategy" : "Next-Day Strategy";

            if (marketOutlookTitle) {
                marketOutlookTitle.textContent = ` Market Outlook & ${strategyType} Analysis`;
            }

            if (data.status === 'error' || data.status === 'not_available') {
                safeSetHTML(statusElement, `<div class="status-indicator"> ${data.message}</div>`);
                contentElement.style.display = 'none';
                return;
            }

            // Update status
            const statusIcon = data.status === 'current' ? '' : data.status === 'stale' ? '' : '';
            safeSetHTML(statusElement, `<div class="status-indicator">${statusIcon} ${data.message}</div>`);

            // Display primary watchlist
            const watchlistElement = document.getElementById('primaryWatchlist');
            if (watchlistElement) {
                if (data.primary_watchlist && data.primary_watchlist.length > 0) {
                    safeSetHTML(watchlistElement, data.primary_watchlist.map(item => `
                        <div class="watchlist-item">
                            <div class="watchlist-symbol">${item.symbol}</div>
                            <div class="watchlist-strategy">${item.strategy}</div>
                            <div class="watchlist-score">Score: ${(item.score * 100).toFixed(0)}%</div>
                            <div class="watchlist-strategy">${item.timeframe}</div>
                        </div>
                    `).join(''));
                } else {
                    safeSetHTML(watchlistElement, '<div style="color: var(--text-secondary); font-size: var(--text-caption-size);">No watchlist available</div>');
                }
            }

            // Display sector outlook
            const sectorElement = document.getElementById('sectorOutlook');
            if (sectorElement) {
                if (data.sector_outlook) {
                    safeSetHTML(sectorElement, Object.entries(data.sector_outlook).map(([sector, outlook]) => {
                        const className = outlook === 'bullish' ? 'sector-bullish' :
                                        outlook === 'bearish' ? 'sector-bearish' : 'sector-neutral';
                        return `
                            <div class="sector-item ${className}">
                                <span>${sector}</span>
                                <span>${outlook.toUpperCase()}</span>
                            </div>
                        `
                    }).join(''));
                } else {
                    safeSetHTML(sectorElement, '<div style="color: var(--text-secondary); font-size: var(--text-caption-size);">No outlook available</div>');
                }
            }

            // Display market regime
            const regimeElement = document.getElementById('marketRegime');
            if (regimeElement) {
                if (data.market_regime) {
                    const regimeClass = `regime-${data.market_regime}`;
                    safeSetHTML(regimeElement, `
                        <div class="${regimeClass}">
                            <div style="font-size: var(--text-caption-size); font-weight: bold;">${data.market_regime.toUpperCase()}</div>
                            <div style="font-size: var(--text-caption-size); margin-top: var(--space-xs); color: var(--text-secondary);">Current Market State</div>
                        </div>
                    `)
                } else {
                    safeSetHTML(regimeElement, '<div style="color: var(--text-secondary); font-size: var(--text-caption-size);">Regime unknown</div>');
                }
            }

            // Display options opportunities
            const optionsElement = document.getElementById('optionsOpportunities');
            if (optionsElement) {
                if (data.options_opportunities && data.options_opportunities.length > 0) {
                    safeSetHTML(optionsElement, data.options_opportunities.map(item => `
                    <div class="option-item">
                        <div class="option-symbol">${item.symbol}</div>
                        <div class="option-strategy">${item.strategy}</div>
                        <div class="option-probability">P: ${(item.probability * 100).toFixed(0)}% | Risk: $${item.max_risk}</div>
                    </div>
                `).join(''));
                } else {
                    safeSetHTML(optionsElement, '<div style="color: var(--text-secondary); font-size: var(--text-caption-size);">No opportunities found</div>');
                }
            }

            // Display market conditions overview
            const marketOutlookContainer = document.getElementById('marketOutlookContainer');
            if (marketOutlookContainer && data.market_regime && data.sector_outlook) {
                const regimeClass = `regime-${data.market_regime}`;
                const regimeColor = data.market_regime === 'trending' ? 'var(--color-success)' :
                                  data.market_regime === 'mean-reverting' ? 'var(--color-warning)' : 'var(--text-secondary)';

                const sectorSummary = Object.entries(data.sector_outlook).map(([sector, outlook]) => {
                    const color = outlook === 'bullish' ? 'var(--color-success)' :
                                outlook === 'bearish' ? 'var(--color-error)' : 'var(--text-secondary)';
                    return `<span style="color: ${color};">${sector}: ${outlook}</span>`;
                }).join(' | ');

                safeSetHTML(marketOutlookContainer, `
                    <div style="padding: var(--space-md);">
                        <div style="margin-bottom: var(--space-md);">
                            <div style="font-size: var(--text-caption-size); color: var(--text-secondary); margin-bottom: var(--space-xs);">MARKET REGIME</div>
                            <div class="${regimeClass}" style="font-size: var(--text-body-size); font-weight: bold; color: ${regimeColor}; text-transform: uppercase;">
                                ${data.market_regime}
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--text-caption-size); color: var(--text-secondary); margin-bottom: var(--space-xs);">SECTOR PERFORMANCE</div>
                            <div style="font-size: var(--text-caption-size); line-height: 1.6;">
                                ${sectorSummary}
                            </div>
                        </div>
                    </div>
                `);
            }

            contentElement.style.display = 'block';
        }

        // Load equity analysis
        async function loadEquityAnalysis() {
            try {
                const response = await fetch('/api/equity_analysis');
                const data = await response.json();
                displayEquityAnalysis(data);
            } catch (error) {
                console.error('Error loading equity analysis:', error);
                safeSetHTML(document.getElementById('equityAnalysisContainer'),
                    '<div class="text-dim"> Error loading equity analysis</div>');
            }
        }

        function displayEquityAnalysis(data) {
            const container = document.getElementById('equityAnalysisContainer');

            if (data.status === 'error') {
                safeSetHTML(container, `<div class="text-dim"> ${data.message}</div>`);
                return;
            }

            if (data.position_count === 0) {
                safeSetHTML(container, '<div class="text-dim">No equity positions currently held</div>');
                return;
            }

            let html = `
                <div style="margin-bottom: var(--space-sm);">
                    <span style="color: var(--color-success);"> Total Equity Value:</span> <strong>$${data.total_equity_value.toLocaleString()}</strong>
                    <span style="margin-left: var(--space-lg); color: #00ff88;"> Positions:</span> <strong>${data.position_count}</strong>
                </div>
            `;
            data.equity_positions.forEach(position => {
                const pnlColor = position.unrealized_pl >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                const pnlIcon = position.unrealized_pl >= 0 ? '' : '';

                html += `
                    <div style="border-left: var(--space-xs) solid var(--color-secondary); padding-left: var(--space-sm); margin: var(--space-sm) 0;">
                        <div style="color: #00ff88; font-weight: bold;">${position.symbol}</div>
                        <div style="font-size: var(--text-caption-size);">
                            <span style="color: var(--color-text-secondary);">Qty:</span> ${position.quantity} |
                            <span style="color: var(--color-text-secondary);">Value:</span> $${position.market_value.toLocaleString()} |
                            <span style="color: ${pnlColor};">${pnlIcon} ${position.unrealized_plpc >= 0 ? '+' : ''}${(position.unrealized_plpc * 100).toFixed(2)}%</span>
                        </div>
                    </div>
                `;
            });

            safeSetHTML(container, html);

            // Also update Portfolio Summary section
            const allocationContainer = document.getElementById('portfolioAllocationContainer');
            const insightsContainer = document.getElementById('portfolioInsightsContainer');

            if (allocationContainer) {
                // Calculate allocation percentages
                const top5 = data.equity_positions.slice(0, 5);
                let allocationHtml = `
                    <div class="metric-item">
                        <span class="metric-label">Total Equity:</span>
                        <span class="metric-value">$${data.total_equity_value.toLocaleString()}</span>
                    </div>
                    <div class="metric-item"><span class="metric-label">Top 5 Holdings:</span></div>
                `;

                top5.forEach(position => {
                    const percentage = (position.market_value / data.total_equity_value * 100).toFixed(1);
                    allocationHtml += `<div class="allocation-item">${position.symbol}: <span class="allocation-value">${percentage}%</span></div>`;
                });

                safeSetHTML(allocationContainer, allocationHtml);
            }

            if (insightsContainer) {
                const winners = data.equity_positions.filter(p => p.unrealized_plpc > 0).length;
                const losers = data.equity_positions.filter(p => p.unrealized_plpc < 0).length;
                const avgReturn = (data.equity_positions.reduce((sum, p) => sum + p.unrealized_plpc, 0) / data.position_count * 100).toFixed(2);

                let insightsHtml = `
                    <div class="insight-item"> ${winners} positions profitable, ${losers} losing</div>
                    <div class="insight-item"> Average return: ${avgReturn >= 0 ? '+' : ''}${avgReturn}%</div>
                    <div class="insight-item"> Market regime: ${data.strategy_context?.market_regime || 'Unknown'}</div>
                `;

                safeSetHTML(insightsContainer, insightsHtml);
            }
        }

        // Load options analysis
        async function loadOptionsAnalysis() {
            try {
                const response = await fetch('/api/options_analysis');
                const data = await response.json();
                displayOptionsAnalysis(data);
            } catch (error) {
                console.error('Error loading options analysis:', error);
                safeSetHTML(document.getElementById('optionsAnalysisContainer'),
                    '<div class="text-dim"> Error loading options analysis</div>');
            }
        }

        function displayOptionsAnalysis(data) {
            const container = document.getElementById('optionsAnalysisContainer');

            if (data.status === 'error') {
                safeSetHTML(container, `<div class="text-dim"> ${data.message}</div>`);
                return;
            }

            let html = '';

            if (data.position_count > 0) {
                html += `
                    <div style="margin-bottom: var(--space-sm);">
                        <span style="color: var(--color-success);"> Total Options Value:</span> <strong>$${data.total_options_value.toLocaleString()}</strong>
                        <span style="margin-left: var(--space-lg); color: #00ff88;"> Positions:</span> <strong>${data.position_count}</strong>
                    </div>
                `;
                data.options_positions.forEach(position => {
                    const pnlColor = position.unrealized_pl >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                    const pnlIcon = position.unrealized_pl >= 0 ? '' : '';

                    html += `
                        <div style="border-left: var(--space-xs) solid var(--color-secondary); padding-left: var(--space-sm); margin: var(--space-sm) 0;">
                            <div style="color: #00ff88; font-weight: bold;">${position.underlying}</div>
                            <div style="font-size: var(--text-caption-size); color: var(--color-text-secondary);">${position.symbol}</div>
                            <div style="font-size: var(--text-caption-size);">
                                <span style="color: var(--color-text-secondary);">Qty:</span> ${position.quantity} |
                                <span style="color: var(--color-text-secondary);">Value:</span> $${position.market_value.toLocaleString()} |
                                <span style="color: ${pnlColor};">${pnlIcon} ${position.unrealized_plpc >= 0 ? '+' : ''}${position.unrealized_plpc.toFixed(2)}%</span>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<div style="margin-bottom: var(--space-md); color: var(--color-text-secondary);">No options positions currently held</div>';
            }

            // Add opportunities section
            if (data.opportunities && data.opportunities.length > 0) {
                html += `
                    <div style="margin-top: var(--space-md); border-top: 1px solid var(--color-secondary); padding-top: var(--space-sm);">
                        <div style="color: #00ff88; font-weight: bold; margin-bottom: var(--space-sm);"> Identified Opportunities:</div>
                `;
                data.opportunities.forEach(opp => {
                    html += `
                        <div style="font-size: var(--text-caption-size); margin: var(--space-xs) 0; color: var(--color-text-secondary);">
                             <span style="color: var(--color-background);">${opp.symbol || opp.underlying}</span>: ${opp.strategy || opp.description || 'Strategic opportunity'}
                        </div>
                    `;
                });

                html += '</div>';
            }

            safeSetHTML(container, html);
        }

        // Initialize donut animation after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initDonutAnimation();
            loadNextDayStrategy();
            loadEquityAnalysis();
            loadOptionsAnalysis();

            // Reload all analysis every 30 seconds
            setInterval(() => {
                loadNextDayStrategy();
                loadEquityAnalysis();
                loadOptionsAnalysis();
            }, 30 * 1000);
        });
    </script>
</body>
</html>
