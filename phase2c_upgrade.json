{
  "tickets/12-latency-observability.md": "# Ticket 12 — End-to-end latency SLOs + tracing\n\n## Goal\nInstrument *data→decision→order→ack* latency with p50/p95/p99, per-provider and end-to-end, with trace IDs flowing through the pipeline.\n\n## Deliverables\n- `src/obs/tracing.ts`: request/trace IDs, span helpers.\n- `src/obs/histogram.ts`: HDR histogram wrapper (p50/p95/p99).\n- Add tracing to: ProviderRouter (quote fetch), scorer (decision), OrderRouter (build/send), Broker adapter (ack).\n- Emit metrics: `e2e_latency_ms`, `decision_latency_ms`, `order_ack_latency_ms`.\n\n## Acceptance\n- Unit tests verify spans compose and metrics record.\n- A sample run outputs SLO dashboard JSON with p50/p95/p99.\n",
  "tickets/13-slippage-queue-sim.md": "# Ticket 13 — Execution simulator: spread, queue, venue model\n\n## Goal\nUpgrade backtests with a realistic **slippage/queue-position** model: spread capture, adverse selection, partial fills, and venue fees.\n\n## Deliverables\n- `src/sim/executionSim.ts` with models:\n  - Limit order fill probability vs queue depth + trade-through rate\n  - Marketable-limit fill at mid±band with expected slippage\n  - Spread/impact functions parameterized per liquidity bucket\n- Config in YAML: liquidity buckets by ADV/spread quintile.\n- CLI: `pnpm sim:exec --run <backtest_id> --write-overlay`.\n\n## Acceptance\n- Backtest can re-score runs with execution overlay; metrics show PF/Sharpe change.\n",
  "tickets/14-smart-routing-sim.md": "# Ticket 14 — Smart routing what-if (POV/TWAP vs single-shot)\n\n## Goal\nCompare single-shot vs TWAP/POV strategies using the execution simulator to quantify slippage benefits.\n\n## Deliverables\n- `src/sim/routingWhatIf.ts` producing per-trade deltas (bps) by strategy.\n- Report writer to `/reports/<run>/routing.html`.\n\n## Acceptance\n- Report lists average/median slippage savings and confidence intervals.\n",
  "tickets/15-compliance-audit-immutable.md": "# Ticket 15 — Immutable compliance audit log\n\n## Goal\nAppend-only audit trail (WORM) for each decision/order: inputs, consensus snapshot, EV calc, risk checks, and final action.\n\n## Deliverables\n- `src/compliance/audit.ts`: write-once records with content-hash chain (Merkle-ish).\n- SQLite table `audit_log` with `id, ts, trace_id, symbol, state, reason_codes, ev_bps, consensus_snapshot, risk_snapshot, order_ref, prev_hash, hash`.\n- `GET /audit/:traceId` endpoint.\n\n## Acceptance\n- Hash chain verifies; tamper makes chain fail validation CLI: `pnpm audit:verify`.\n",
  "tickets/16-portfolio-attrib.md": "# Ticket 16 — Portfolio factor attribution & exposures\n\n## Goal\nDaily factor/sector/size attribution and exposure limits with alerts.\n\n## Deliverables\n- `src/portfolio/factors.ts`: simple factor model (mkt, size, value, momentum) using YCharts/FMP proxies.\n- `src/portfolio/attrib.ts`: Brinson-style attribution by sector & factors.\n- `GET /portfolio/exposures`, `/portfolio/attribution` endpoints.\n- Alerts when net beta, sector tilt, or factor exposure exceeds config.\n\n## Acceptance\n- Unit tests on attribution math; dashboard JSON renders correct tilts.\n",
  "tickets/17-canary-live-vs-paper.md": "# Ticket 17 — Canary comparator (live vs paper)\n\n## Goal\nRun **paper shadow** alongside live, compare every leg: quote, decision, order price, fill/slippage, PnL.\n\n## Deliverables\n- `src/canary/comparator.ts`: pairs live trades with paper intents via trace_id and timestamps.\n- `GET /canary/diff?symbol=...` summary and CSV export.\n- Thresholds for acceptable divergence; alert when exceeded.\n\n## Acceptance\n- Controlled test case generates expected diffs; alerts fire on configured thresholds.\n",
  "tickets/18-slo-dashboards.md": "# Ticket 18 — SLO Dashboards & alerts\n\n## Goal\nOne JSON-exported dashboard: provider health, freshness, consensus failures, latency SLOs, and execution outcomes.\n\n## Deliverables\n- `src/obs/dashboard.ts`: aggregates metrics into a single JSON doc.\n- `GET /metrics/dashboard` endpoint.\n- Basic alerting (log or webhook) on SLO breaches.\n\n## Acceptance\n- Smoke test returns dashboard JSON; alerts trigger on injected faults.\n",
  "src/obs/tracing.ts": "import crypto from 'crypto';\nexport type Span = { traceId: string; spanId: string; name: string; tsStart: number; tsEnd?: number; attrs?: Record<string, any> };\nexport function newTrace(){ return crypto.randomBytes(8).toString('hex'); }\nexport function newSpan(name:string, traceId?:string): Span { return { name, traceId: traceId||newTrace(), spanId: crypto.randomBytes(8).toString('hex'), tsStart: Date.now(), attrs:{} }; }\nexport function endSpan(s:Span){ s.tsEnd = Date.now(); return s; }\nexport function durationMs(s:Span){ return (s.tsEnd||Date.now()) - s.tsStart; }\n",
  "src/obs/histogram.ts": "export class HdrLike { private values:number[]=[]; add(v:number){ if(Number.isFinite(v)) this.values.push(v); } p(pct:number){ if(this.values.length===0) return 0; const a=[...this.values].sort((a,b)=>a-b); const i=Math.min(a.length-1, Math.max(0, Math.floor((pct/100)*a.length))); return a[i]; } count(){ return this.values.length; } }\n",
  "src/obs/e2e.ts": "import { newSpan, endSpan, durationMs } from './tracing'; import { HdrLike } from './histogram';\nconst e2e = new HdrLike(), decision = new HdrLike(), ack = new HdrLike();\nexport function recordE2E(ms:number){ e2e.add(ms); } export function recordDecision(ms:number){ decision.add(ms); } export function recordAck(ms:number){ ack.add(ms); }\nexport function snapshot(){ return { e2e:{p50:e2e.p(50), p95:e2e.p(95), p99:e2e.p(99), n:e2e.count()}, decision:{p50:decision.p(50), p95:decision.p(95), p99:decision.p(99), n:decision.count()}, ack:{p50:ack.p(50), p95:ack.p(95), p99:ack.p(99), n:ack.count()} }; }\nexport { newSpan, endSpan, durationMs };\n",
  "src/sim/executionSim.ts": "export type LiquidityBucket = 'Q1'|'Q2'|'Q3'|'Q4'|'Q5';\nexport interface ExecSimConfig { spreadBpsByBucket: Record<LiquidityBucket, number>; slipMeanBpsByBucket: Record<LiquidityBucket, number>; slipStdBpsByBucket: Record<LiquidityBucket, number>; feePerShare: number; }\nfunction normal(mean:number, std:number){ // Box-Muller\n  const u=Math.random(), v=Math.random(); return mean + std * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }\nexport function simulateFill(limit:number, mid:number, side:'buy'|'sell', bucket:LiquidityBucket, cfg:ExecSimConfig){\n  const baseSlip = normal(cfg.slipMeanBpsByBucket[bucket], cfg.slipStdBpsByBucket[bucket]);\n  const slip = Math.max(-cfg.spreadBpsByBucket[bucket]/2, baseSlip);\n  const price = side==='buy' ? Math.min(limit, mid*(1+slip/10000)) : Math.max(limit, mid*(1-slip/10000));\n  return { price, slip_bps: slip };\n}\n",
  "src/sim/routingWhatIf.ts": "import { simulateFill, ExecSimConfig } from './executionSim';\nexport function compareStrategies(mid:number, side:'buy'|'sell', qty:number, bucket:'Q1'|'Q2'|'Q3'|'Q4'|'Q5', cfg:ExecSimConfig){\n  const single = simulateFill(mid*1.001, mid, side, bucket, cfg);\n  const twap = Array.from({length:4}, (_,i)=> simulateFill(mid*1.0005, mid, side, bucket, cfg));\n  const pov = Array.from({length:4}, (_,i)=> simulateFill(mid*1.0007, mid, side, bucket, cfg));\n  const avg = (xs:any[])=> xs.reduce((a,b)=>a+b.price,0)/xs.length;\n  return { single_px: single.price, twap_px: avg(twap), pov_px: avg(pov) };\n}\n",
  "src/compliance/audit.ts": "import crypto from 'crypto';\ninterface AuditRec { id?:number; ts:number; trace_id:string; symbol:string; state:string; reason_codes:string[]; ev_bps:number|null; consensus_snapshot:any; risk_snapshot:any; order_ref?:string|null; prev_hash:string|null; hash:string; }\nfunction h(obj:any){ return crypto.createHash('sha256').update(JSON.stringify(obj)).digest('hex'); }\nexport class AuditLog { private lastHash:string|null=null; constructor(private write:(rec:AuditRec)=>Promise<void>){ }\n  async append(partial: Omit<AuditRec,'hash'|'prev_hash'|'ts'>){ const rec:any = { ...partial, ts: Date.now(), prev_hash: this.lastHash }; rec.hash = h({ ...rec, hash: undefined }); await this.write(rec); this.lastHash = rec.hash; return rec; }\n}\nexport function verifyChain(records:AuditRec[]){ let prev:null|string=null; for(const r of records){ const expect = h({ ...r, hash: undefined }); if(r.hash!==expect || r.prev_hash!==prev) return false; prev = r.hash; } return true; }\n",
  "src/portfolio/factors.ts": "export type Factor = 'MKT'|'SIZE'|'VAL'|'MOM';\nexport interface FactorSeries { name:Factor; dates:number[]; values:number[]; }\nexport interface Position { symbol:string; notional:number; beta?:number; sector?:string; size_bucket?:string; }\nexport function estimateExposures(positions:Position[], betasBySymbol:Record<string,number>){ const beta = positions.reduce((s,p)=> s + (betasBySymbol[p.symbol]||1)*p.notional, 0); return { beta }; }\n",
  "src/portfolio/attrib.ts": "import { Position } from './factors';\nexport function sectorAttribution(positions:Position[], returnsBySymbol:Record<string,number>, sectorBySymbol:Record<string,string>){\n  const bucket: Record<string,{ contrib:number; notional:number }> = {};\n  for(const p of positions){ const sec = sectorBySymbol[p.symbol]||'UNK'; bucket[sec] ||= { contrib:0, notional:0 }; bucket[sec].notional += p.notional; bucket[sec].contrib += (returnsBySymbol[p.symbol]||0)*p.notional; }\n  return Object.entries(bucket).map(([sector,v])=> ({ sector, contrib:v.contrib, weight: v.notional / Math.max(1, Object.values(bucket).reduce((s,b)=>s+b.notional,0)) }));\n}\n",
  "src/canary/comparator.ts": "export interface LiveFill { trace_id:string; symbol:string; ts:number; side:'buy'|'sell'; qty:number; price:number; }\nexport interface PaperIntent { trace_id:string; symbol:string; ts:number; side:'buy'|'sell'; qty:number; mid:number; planned_price:number; }\nexport function diff(live:LiveFill[], paper:PaperIntent[]){ const byTrace = new Map(live.map(x=>[x.trace_id,x])); const rows:any[]=[]; for(const p of paper){ const l = byTrace.get(p.trace_id); if(!l) { rows.push({ trace_id:p.trace_id, symbol:p.symbol, status:'missing_live' }); continue; } const diff_bps = (l.price - p.planned_price)/p.planned_price*10000; rows.push({ trace_id:p.trace_id, symbol:p.symbol, status:'ok', diff_bps, live:l.price, plan:p.planned_price }); } return rows; }\n",
  "src/obs/dashboard.ts": "import { snapshot } from './e2e';\nexport function dashboard(){ return { latency: snapshot(), ts: Date.now() }; }\n",
  "src/api/obs.ts": "import Fastify from 'fastify'; import { dashboard } from '../obs/dashboard';\nexport const app = Fastify();\napp.get('/metrics/dashboard', async (_req, res)=> { res.send(dashboard()); });\nexport async function startObsApi(port=8787){ await app.listen({ port, host:'0.0.0.0' }); }\n",
  "tests/obs.spec.ts": "import { describe, it, expect } from 'vitest'; import { newSpan, endSpan, durationMs } from '../src/obs/e2e';\n\ndescribe('tracing', ()=>{ it('measures durations', ()=>{ const s=newSpan('t'); const e=endSpan(s); expect(durationMs(e)).toBeGreaterThanOrEqual(0); }); });\n"
}
