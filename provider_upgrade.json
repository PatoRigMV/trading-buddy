{
  "tickets/01-normalize-adapters.md": "# Ticket 01 — Normalize all adapters to a shared schema\n\n## Goal\nEvery data provider emits a single normalized schema so consensus compares like-for-like (mid vs mid, last vs last).\n\n## Deliverables\n- `src/data/types.ts` with `NormalizedQuote`, `NormalizedBar`, `ProviderMeta`.\n- Adapter wrappers for Polygon, Tiingo, Finnhub, TwelveData, FMP, Yahoo that return normalized objects.\n- Unit tests asserting required fields and units (prices in USD, bps as numbers, timestamps as epoch ms).\n\n## Acceptance tests\n- All adapters pass `schemaParity.spec.ts`.\n- Fields populated: bid, ask, bidSize, askSize, last, lastSize, mid, spread_bps, ts_exchange, ts_provider, provider.\n- Bars adjusted for splits (if provider raw is unadjusted, mark `adjusted=false`).\n",
  "tickets/02-consensus-logic.md": "# Ticket 02 — Dynamic consensus logic (quorum & thresholds)\n\n## Goal\nCompare apples-to-apples with dynamic thresholds and quorum rules.\n\n## Requirements\n- Compare `mid` to `mid` (quotes) or `last` to `last` (prints). Never cross-compare.\n- Dynamic threshold: `threshold_bps = max(floor_bps, spread_multiplier * spread_bps, cap_bps)`\n  - Defaults: `floor_bps=5`, `spread_multiplier=2.0`, `cap_bps=15` (i.e., 0.15%)\n- Quorum: accept if ≥2 providers agree within `threshold_bps`.\n- Confidence downgrade if only one provider is fresh.\n\n## Deliverables\n- `src/data/consensus.ts` with `priceConsensus()` and `deweightIfLowQuorum()`.\n- Configurable via `data_providers.yaml`.\n\n## Tests\n- `tests/consensus.spec.ts` covering tight/wide spreads, single-source fresh, conflicting sources.\n",
  "tickets/03-ws-first-router.md": "# Ticket 03 — WS-first router with reconnect & gap-fill\n\n## Goal\nPrioritize WS feeds (Polygon) with robust reconnect and REST backfill.\n\n## Requirements\n- Prefer WS when connected & fresh; fallback to REST when stale (`quotes>2s`, `bars_1m>60s`).\n- Reconnect with exponential backoff + jitter.\n- On reconnect, detect missed bars and backfill via REST.\n- Per-symbol freshness tracking and a `haltEntriesIfStale` guard.\n\n## Deliverables\n- `src/data/ProviderRouter.ts` implementing this logic.\n- `src/data/backfill.ts` helper.\n- Basic health events via `metrics.emit()`.\n\n## Tests\n- `tests/router.spec.ts` simulating WS drop, REST fallback, and clean recovery.\n",
  "tickets/04-rapidapi-buckets.md": "# Ticket 04 — RapidAPI per-host buckets & timeouts\n\n## Goal\nFix shared-key issue by isolating buckets per-host and adding strict timeouts.\n\n## Requirements\n- Separate rate buckets for `twelvedata.p.rapidapi.com` and `financialmodelingprep.p.rapidapi.com`.\n- Per-host connect/read timeouts (e.g., 1200ms), 2 retries max with jitter.\n- Circuit breaker per host: open on 5xx error budget breach; half-open after cooldown.\n\n## Deliverables\n- `src/data/rateLimiter.ts` (leaky bucket) + `src/data/circuitBreaker.ts`.\n- Config knobs under `rate_limits` in YAML.\n\n## Tests\n- `tests/rapidapi.spec.ts` covering bucket isolation and breaker behavior.\n",
  "tickets/05-secrets-and-logging.md": "# Ticket 05 — Secrets hygiene & key rotation\n\n## Goal\nEliminate key leakage; add secret scanning and rotation playbook.\n\n## Requirements\n- Strip keys from logs/health endpoints; mask using `****` at source.\n- Add CI secret scanning (e.g., Gitleaks) and pre-commit hook.\n- Document rotation steps.\n\n## Deliverables\n- `src/security/secretScan.md` (runbook + CI config snippet).\n- Replace any `console.log(config)` with redacted `safeConfig()`.\n",
  "tickets/06-corporate-actions.md": "# Ticket 06 — Corporate actions hygiene\n\n## Goal\nBack-adjust bars, invalidate caches, and recompute risk/stop levels on splits/dividends.\n\n## Requirements\n- Detect split/dividend effective dates (Polygon primary, FMP secondary).\n- Back-adjust historical series; mark `adjusted=true` post-adjust.\n- Invalidate indicator caches and recompute ATR/EMA on event.\n- Recalculate open position stops/targets immediately on split.\n\n## Deliverables\n- `src/data/corpActions.ts` utilities.\n- Integration into `ProviderRouter` pipeline.\n",
  "tickets/07-chaos-suite.md": "# Ticket 07 — Chaos & latency test suite\n\n## Goal\nProve graceful degradation and deterministic recovery under incidents.\n\n## Scenarios\n- WS drop mid-session; REST fallback; reconnect + backfill; no duplicate bars.\n- Provider throttling (429), 999s, and timeouts; breaker opens, alternate source wins.\n- Latency spikes; ensure freshness gating halts entries if stale.\n\n## Deliverables\n- `tests/chaos.spec.ts` with deterministic fakes.\n- Replay harness for recorded sessions.\n",
  "src/data/types.ts": "export type ProviderName = \"polygon\"|\"tiingo\"|\"finnhub\"|\"twelvedata\"|\"fmp\"|\"yahoo\";\n\nexport interface ProviderMeta { provider: ProviderName; ts_provider: number; source_latency_ms?: number; }\n\nexport interface NormalizedQuote extends ProviderMeta {\n  symbol: string;\n  ts_exchange: number; // epoch ms\n  bid: number | null;\n  ask: number | null;\n  bidSize?: number | null;\n  askSize?: number | null;\n  last?: number | null;\n  lastSize?: number | null;\n  mid: number | null; // computed if bid/ask present\n  spread_bps: number | null; // (ask-bid)/mid * 10000\n  halted?: boolean;\n  luld?: { upper: number; lower: number } | null;\n}\n\nexport interface NormalizedBar extends ProviderMeta {\n  symbol: string;\n  ts_open: number; // epoch ms (bar start)\n  ts_close: number; // epoch ms (bar end)\n  o: number; h: number; l: number; c: number; v: number;\n  adjusted: boolean; // split/dividend adjusted\n  interval: \"1m\"|\"5m\"|\"1d\";\n}\n\nexport interface ConsensusResult<T> { value: T | null; providersUsed: ProviderName[]; quorum: number; threshold_bps: number; stale: boolean; }\n",
  "src/data/consensus.ts": "import { NormalizedQuote, ProviderName, ConsensusResult } from \"./types\";\n\nexport interface ConsensusConfig { floor_bps: number; spread_multiplier: number; cap_bps: number; min_quorum: number; }\n\nfunction bps(a: number, b: number) { return Math.abs(a - b) / ((a + b) / 2) * 10000; }\n\nexport function dynamicThresholdBps(spread_bps: number|null, cfg: ConsensusConfig) {\n  const s = Math.max(cfg.floor_bps, (spread_bps ?? 0) * cfg.spread_multiplier);\n  return Math.min(s, cfg.cap_bps);\n}\n\nexport function priceConsensus(quotes: NormalizedQuote[], cfg: ConsensusConfig): ConsensusResult<number> {\n  const fresh = quotes.filter(q => q.mid != null && q.spread_bps != null);\n  if (fresh.length === 0) return { value: null, providersUsed: [], quorum: 0, threshold_bps: cfg.floor_bps, stale: true };\n  // choose anchor (first provider) and find nearest neighbors within dynamic threshold\n  const anchor = fresh[0];\n  const thr = dynamicThresholdBps(anchor.spread_bps, cfg);\n  const agree: [ProviderName, number][] = [[anchor.provider, anchor.mid!]];\n  for (let i=1;i<fresh.length;i++) {\n    const q = fresh[i];\n    if (bps(anchor.mid!, q.mid!) <= thr) agree.push([q.provider, q.mid!]);\n  }\n  const quorum = agree.length;\n  if (quorum >= cfg.min_quorum) {\n    const avg = agree.reduce((s, [,v]) => s+v, 0) / quorum;\n    return { value: avg, providersUsed: agree.map(a=>a[0]), quorum, threshold_bps: thr, stale: false };\n  }\n  return { value: anchor.mid!, providersUsed: [anchor.provider], quorum, threshold_bps: thr, stale: quorum===1 };\n}\n",
  "src/data/rateLimiter.ts": "export class LeakyBucket { private cap:number; private ratePerSec:number; private tokens:number; private last:number;\n  constructor(cap:number, ratePerSec:number){ this.cap=cap; this.ratePerSec=ratePerSec; this.tokens=cap; this.last=Date.now(); }\n  tryRemove(cost=1){ const now=Date.now(); const dt=(now-this.last)/1000; this.tokens=Math.min(this.cap, this.tokens+dt*this.ratePerSec); this.last=now; if(this.tokens>=cost){ this.tokens-=cost; return true;} return false; }\n}\n",
  "src/data/circuitBreaker.ts": "export class CircuitBreaker { state:\"closed\"|\"open\"|\"half\" = \"closed\"; private failures=0; private lastOpen=0; constructor(private failLimit=5, private coolMs=15000){}\n  success(){ this.failures=0; if(this.state!==\"closed\") this.state=\"half\"; }\n  fail(){ this.failures++; if(this.failures>=this.failLimit){ this.state=\"open\"; this.lastOpen=Date.now(); } }\n  canPass(){ if(this.state===\"open\") return (Date.now()-this.lastOpen)>this.coolMs ? (this.state=\"half\", true) : false; return true; }\n}\n",
  "src/data/metrics.ts": "type Metric = { name:string; labels?:Record<string,string>; value:number };\nexport const metrics = {\n  emit(m:Metric){ /* hook up to prom/otlp later */ if(process.env.DEBUG_METRICS) console.log(\"METRIC\", m); },\n  providerLatency(provider:string, ms:number){ metrics.emit({name:\"provider_latency_ms\", labels:{provider}, value:ms}); },\n  freshness(domain:string, ms:number){ metrics.emit({name:\"freshness_ms\", labels:{domain}, value:ms}); },\n  breaker(provider:string, state:string){ metrics.emit({name:\"circuit_state\", labels:{provider, state}, value:1}); }\n};\n",
  "src/data/backfill.ts": "import { NormalizedBar } from \"./types\";\nexport async function backfillMissingBars(symbol:string, fromMs:number, toMs:number): Promise<NormalizedBar[]> {\n  // Stub: call REST (Polygon/Tiingo) to fetch bars and return normalized\n  return [];\n}\n",
  "src/data/ProviderRouter.ts": "import { NormalizedQuote, ProviderName } from \"./types\";\nimport { priceConsensus, ConsensusConfig } from \"./consensus\";\nimport { metrics } from \"./metrics\";\n\ninterface Freshness { quotesMs:number; bars1mMs:number; }\n\nexport class ProviderRouter {\n  private cfg:{ freshness:Freshness; consensus:ConsensusConfig; quorumMin:number };\n  constructor(cfg?:Partial<{freshness:Freshness; consensus:ConsensusConfig; quorumMin:number}>){\n    this.cfg = {\n      freshness: { quotesMs: 2000, bars1mMs: 60000, ...(cfg?.freshness||{}) },\n      consensus: { floor_bps:5, spread_multiplier:2.0, cap_bps:15, min_quorum:2, ...(cfg?.consensus||{}) },\n      quorumMin: 2\n    };\n  }\n\n  // WS-first selection (Polygon preferred). Real impl would subscribe to WS and maintain latest snapshots per provider.\n  async getQuote(symbol:string): Promise<{ mid:number|null; stale:boolean; providers:ProviderName[] }>{\n    // fetch latest normalized quotes from whichever providers are fresh (stubs here):\n    const quotes: NormalizedQuote[] = await this.fetchQuotesFromProviders(symbol);\n    const res = priceConsensus(quotes, this.cfg.consensus);\n    if(res.stale){ /* optionally block entries */ }\n    metrics.freshness(\"quotes\", res.stale? this.cfg.freshness.quotesMs+1 : 0);\n    return { mid: res.value, stale: res.stale, providers: res.providersUsed };\n  }\n\n  private async fetchQuotesFromProviders(_symbol:string): Promise<NormalizedQuote[]> {\n    // TODO: Plug in polygon WS snapshot (if connected & fresh), then tiingo, finnhub, rapidapi providers, then yahoo\n    return [];\n  }\n}\n",
  "src/data/providers/polygon.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function polygonQuote(symbol:string): Promise<NormalizedQuote|null>{\n  // TODO: pull from WS snapshot or REST; map to normalized schema\n  const meta:ProviderMeta = { provider:\"polygon\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/data/providers/tiingo.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function tiingoQuote(symbol:string): Promise<NormalizedQuote|null>{\n  const meta:ProviderMeta = { provider:\"tiingo\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/data/providers/finnhub.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function finnhubQuote(symbol:string): Promise<NormalizedQuote|null>{\n  const meta:ProviderMeta = { provider:\"finnhub\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/data/providers/twelvedata.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function twelveDataQuote(symbol:string): Promise<NormalizedQuote|null>{\n  const meta:ProviderMeta = { provider:\"twelvedata\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/data/providers/fmp.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function fmpQuote(symbol:string): Promise<NormalizedQuote|null>{\n  const meta:ProviderMeta = { provider:\"fmp\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/data/providers/yahoo.ts": "import { NormalizedQuote, ProviderMeta } from \"../types\";\nexport async function yahooQuote(symbol:string): Promise<NormalizedQuote|null>{\n  const meta:ProviderMeta = { provider:\"yahoo\", ts_provider: Date.now() };\n  return { ...meta, symbol, ts_exchange: Date.now(), bid:null, ask:null, mid:null, spread_bps:null };\n}\n",
  "src/security/secretScan.md": "# Secrets hygiene & rotation\n\n- **Never** log raw keys. Use a masker that redacts values except last 4 chars.\n- Add CI secret scanning (e.g., Gitleaks) and a pre-commit hook.\n- Rotation playbook: revoke → re-issue → deploy → invalidate old; document per provider.\n- Mask keys in `/health` and `/status` endpoints.\n",
  "src/config/data_providers.yaml": "data_providers:\n  prices:\n    order: [polygon_ws, tiingo_iex, finnhub_rest, twelve_data_rapidapi, fmp_rapidapi, yahoo_finance]\n    validation:\n      floor_bps: 5\n      spread_multiplier: 2.0\n      cap_bps: 15\n      min_quorum: 2\n    freshness_ms:\n      quotes: 2000\n      bars_1m: 60000\n  corp_actions:\n    order: [polygon, fmp_rapidapi, tiingo]\n  fundamentals:\n    order: [ycharts, fmp_rapidapi, tiingo, alpha_vantage, yahoo_finance]\n  news:\n    order: [benzinga, tiingo_news, newsapi]\n  sentiment:\n    order: [tiingo_news_nlp, stocktwits, reddit]\n  macro:\n    order: [ycharts, fred]\nrate_limits:\n  polygon_ws: { strategy: ws_stream }\n  finnhub_rest: { rpm: 150 }\n  fmp_rapidapi: { rpm: 60 }\n  twelve_data_rapidapi: { rpm: 60 }\nexecution_guards:\n  respect_luld: true\n  block_on_halt: true\nevents:\n  block_earnings_window_days: 3\n",
  "tests/consensus.spec.ts": "import { describe, it, expect } from \"vitest\";\nimport { priceConsensus, dynamicThresholdBps } from \"../src/data/consensus\";\n\ndescribe(\"consensus\", () => {\n  it(\"uses dynamic threshold and quorum\", () => {\n    const quotes = [\n      { provider:\"polygon\", ts_provider:1, symbol:\"AAPL\", ts_exchange:1, bid:100, ask:100.1, mid:100.05, spread_bps:9 },\n      { provider:\"tiingo\", ts_provider:1, symbol:\"AAPL\", ts_exchange:1, bid:100.01, ask:100.11, mid:100.06, spread_bps:10 },\n    ] as any;\n    const res = priceConsensus(quotes, { floor_bps:5, spread_multiplier:2, cap_bps:15, min_quorum:2 });\n    expect(res.value).toBeGreaterThan(100.04);\n    expect(res.providersUsed.length).toBe(2);\n  });\n  it(\"returns stale when no fresh quotes\", () => {\n    const res = priceConsensus([], { floor_bps:5, spread_multiplier:2, cap_bps:15, min_quorum:2 });\n    expect(res.stale).toBe(true);\n  });\n});\n",
  "tests/router.spec.ts": "import { describe, it, expect } from \"vitest\";\nimport { ProviderRouter } from \"../src/data/ProviderRouter\";\n\ndescribe(\"router\", () => {\n  it(\"constructs and returns a shape\", async () => {\n    const r = new ProviderRouter();\n    const q = await r.getQuote(\"AAPL\");\n    expect(q).toHaveProperty(\"mid\");\n    expect(q).toHaveProperty(\"stale\");\n  });\n});\n"
}
