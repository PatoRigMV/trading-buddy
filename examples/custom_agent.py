#!/usr/bin/env python3
"""
Custom Agent Example
====================
Demonstrates how to create a new specialized agent for Trading Buddy.

This example creates a "Momentum Scanner" agent that monitors stocks
for momentum breakouts and sends alerts.

Usage:
    python examples/custom_agent.py
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional
from enum import Enum


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)


class AgentState(Enum):
    """Possible states for an agent."""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class AgentMessage:
    """Message passed between agents."""
    sender: str
    recipient: str
    message_type: str
    payload: dict
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class BaseAgent(ABC):
    """
    Base class for all Trading Buddy agents.

    All custom agents should inherit from this class.
    """

    def __init__(self, name: str, config: dict = None):
        self.name = name
        self.config = config or {}
        self.state = AgentState.IDLE
        self.logger = logging.getLogger(f"agent.{name}")
        self.message_queue: List[AgentMessage] = []

    @abstractmethod
    async def initialize(self) -> bool:
        """Initialize the agent. Return True if successful."""
        pass

    @abstractmethod
    async def process(self, data: dict) -> dict:
        """Process incoming data. Return results."""
        pass

    @abstractmethod
    async def shutdown(self):
        """Clean up resources."""
        pass

    async def start(self):
        """Start the agent."""
        self.logger.info(f"Starting {self.name}...")
        success = await self.initialize()
        if success:
            self.state = AgentState.RUNNING
            self.logger.info(f"{self.name} started successfully")
        else:
            self.state = AgentState.ERROR
            self.logger.error(f"{self.name} failed to start")
        return success

    async def stop(self):
        """Stop the agent."""
        self.logger.info(f"Stopping {self.name}...")
        await self.shutdown()
        self.state = AgentState.IDLE
        self.logger.info(f"{self.name} stopped")

    def send_message(self, recipient: str, message_type: str, payload: dict):
        """Send a message to another agent."""
        message = AgentMessage(
            sender=self.name,
            recipient=recipient,
            message_type=message_type,
            payload=payload
        )
        # In a real system, this would go to a message bus
        self.logger.info(f"Message sent to {recipient}: {message_type}")
        return message

    def receive_message(self, message: AgentMessage):
        """Receive a message from another agent."""
        self.message_queue.append(message)
        self.logger.info(f"Message received from {message.sender}: {message.message_type}")


# =============================================================================
# CUSTOM AGENT IMPLEMENTATION
# =============================================================================

@dataclass
class MomentumSignal:
    """Signal generated by the momentum scanner."""
    symbol: str
    signal_type: str  # "BREAKOUT", "BREAKDOWN", "VOLUME_SPIKE"
    price: float
    change_pct: float
    volume_ratio: float
    confidence: float
    timestamp: datetime


class MomentumScannerAgent(BaseAgent):
    """
    Custom agent that scans for momentum breakouts.

    Features:
    - Monitors price changes across a watchlist
    - Detects volume spikes
    - Identifies breakout patterns
    - Sends alerts to other agents
    """

    def __init__(self, config: dict = None):
        super().__init__("MomentumScanner", config)

        # Configuration with defaults
        self.watchlist = config.get("watchlist", ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA"])
        self.breakout_threshold = config.get("breakout_threshold", 0.02)  # 2%
        self.volume_spike_threshold = config.get("volume_spike_threshold", 2.0)  # 2x average
        self.scan_interval = config.get("scan_interval", 60)  # seconds

        # Internal state
        self.signals: List[MomentumSignal] = []
        self.price_history: Dict[str, List[float]] = {}

    async def initialize(self) -> bool:
        """Initialize the momentum scanner."""
        self.logger.info(f"Initializing with watchlist: {self.watchlist}")
        self.logger.info(f"Breakout threshold: {self.breakout_threshold:.1%}")
        self.logger.info(f"Volume spike threshold: {self.volume_spike_threshold}x")

        # Initialize price history for each symbol
        for symbol in self.watchlist:
            self.price_history[symbol] = []

        return True

    async def process(self, data: dict) -> dict:
        """
        Process market data and detect momentum signals.

        Expected data format:
        {
            "symbol": "AAPL",
            "price": 185.50,
            "volume": 1000000,
            "avg_volume": 500000,
            "prev_close": 182.00
        }
        """
        symbol = data.get("symbol")
        if not symbol or symbol not in self.watchlist:
            return {"signals": []}

        price = data.get("price", 0)
        volume = data.get("volume", 0)
        avg_volume = data.get("avg_volume", 1)
        prev_close = data.get("prev_close", price)

        # Update price history
        self.price_history[symbol].append(price)
        if len(self.price_history[symbol]) > 100:
            self.price_history[symbol] = self.price_history[symbol][-100:]

        # Check for signals
        signals = []

        # 1. Check for price breakout
        change_pct = (price - prev_close) / prev_close if prev_close else 0
        if abs(change_pct) >= self.breakout_threshold:
            signal_type = "BREAKOUT" if change_pct > 0 else "BREAKDOWN"
            signal = MomentumSignal(
                symbol=symbol,
                signal_type=signal_type,
                price=price,
                change_pct=change_pct,
                volume_ratio=volume / avg_volume if avg_volume else 0,
                confidence=min(abs(change_pct) / 0.05, 1.0),
                timestamp=datetime.now()
            )
            signals.append(signal)
            self.logger.warning(f"ðŸš¨ {signal_type}: {symbol} at ${price:.2f} ({change_pct:+.2%})")

        # 2. Check for volume spike
        volume_ratio = volume / avg_volume if avg_volume else 0
        if volume_ratio >= self.volume_spike_threshold:
            signal = MomentumSignal(
                symbol=symbol,
                signal_type="VOLUME_SPIKE",
                price=price,
                change_pct=change_pct,
                volume_ratio=volume_ratio,
                confidence=min(volume_ratio / 3.0, 1.0),
                timestamp=datetime.now()
            )
            signals.append(signal)
            self.logger.warning(f"ðŸ“Š VOLUME SPIKE: {symbol} at {volume_ratio:.1f}x average")

        # Store signals
        self.signals.extend(signals)

        # Notify other agents if signals detected
        if signals:
            self.send_message(
                recipient="RiskManager",
                message_type="MOMENTUM_ALERT",
                payload={
                    "symbol": symbol,
                    "signals": [s.__dict__ for s in signals]
                }
            )

        return {
            "symbol": symbol,
            "signals": [s.__dict__ for s in signals],
            "total_signals": len(self.signals)
        }

    async def shutdown(self):
        """Clean up resources."""
        self.logger.info(f"Total signals generated: {len(self.signals)}")
        self.signals.clear()
        self.price_history.clear()

    def get_recent_signals(self, limit: int = 10) -> List[MomentumSignal]:
        """Get the most recent signals."""
        return self.signals[-limit:]


# =============================================================================
# DEMO
# =============================================================================

async def demo():
    """Demonstrate the custom agent."""
    print("=" * 60)
    print("Trading Buddy - Custom Agent Example")
    print("=" * 60)

    # Create and configure the agent
    config = {
        "watchlist": ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA"],
        "breakout_threshold": 0.02,  # 2%
        "volume_spike_threshold": 2.0,  # 2x average
    }

    agent = MomentumScannerAgent(config)

    # Start the agent
    print("\nðŸš€ Starting agent...")
    await agent.start()

    # Simulate market data
    print("\nðŸ“ˆ Processing simulated market data...")
    print("-" * 60)

    test_data = [
        # Normal price movement
        {"symbol": "AAPL", "price": 185.00, "volume": 500000, "avg_volume": 500000, "prev_close": 184.00},
        # Breakout! (+3%)
        {"symbol": "TSLA", "price": 257.50, "volume": 1000000, "avg_volume": 800000, "prev_close": 250.00},
        # Volume spike
        {"symbol": "NVDA", "price": 875.00, "volume": 2500000, "avg_volume": 1000000, "prev_close": 870.00},
        # Breakdown (-2.5%)
        {"symbol": "GOOGL", "price": 146.25, "volume": 600000, "avg_volume": 500000, "prev_close": 150.00},
        # Normal
        {"symbol": "MSFT", "price": 415.00, "volume": 400000, "avg_volume": 450000, "prev_close": 414.00},
    ]

    for data in test_data:
        result = await agent.process(data)
        if result["signals"]:
            print(f"   âœ… {data['symbol']}: {len(result['signals'])} signal(s) detected")
        else:
            print(f"   âšª {data['symbol']}: No signals")

    # Get recent signals
    print("\n" + "-" * 60)
    print("RECENT SIGNALS")
    print("-" * 60)

    for signal in agent.get_recent_signals():
        emoji = {"BREAKOUT": "ðŸŸ¢", "BREAKDOWN": "ðŸ”´", "VOLUME_SPIKE": "ðŸ“Š"}.get(signal.signal_type, "âšª")
        print(f"\n   {emoji} {signal.signal_type}")
        print(f"      Symbol:     {signal.symbol}")
        print(f"      Price:      ${signal.price:.2f}")
        print(f"      Change:     {signal.change_pct:+.2%}")
        print(f"      Volume:     {signal.volume_ratio:.1f}x average")
        print(f"      Confidence: {signal.confidence:.0%}")

    # Stop the agent
    print("\nðŸ›‘ Stopping agent...")
    await agent.stop()

    # Integration instructions
    print("\n" + "=" * 60)
    print("INTEGRATION WITH TRADING BUDDY")
    print("=" * 60)
    print("""
    To integrate this agent into Trading Buddy:

    1. Save your agent to a new file (e.g., momentum_scanner.py)

    2. Register it in web_app.py or main.py:

       from momentum_scanner import MomentumScannerAgent

       momentum_agent = MomentumScannerAgent({
           "watchlist": ["AAPL", "TSLA", "NVDA"],
           "breakout_threshold": 0.02
       })

    3. Start it with the agent watchdog:

       watchdog.register_agent(momentum_agent)
       await watchdog.start_all()

    4. Connect to the message bus for inter-agent communication:

       message_bus.subscribe("MOMENTUM_ALERT", risk_manager.handle_alert)

    5. Add API endpoints if needed:

       @app.route('/api/momentum/signals')
       def get_momentum_signals():
           return jsonify(momentum_agent.get_recent_signals())
    """)


if __name__ == "__main__":
    asyncio.run(demo())
