{
  "tickets/10-calendars-wire.md": "# Ticket 10 — Wire official market calendars (Polygon + Nasdaq)\n\n## Goal\nUse authoritative sources for market open/close, holidays, and half-days so execution guards don't misfire.\n\n## Sources\n- **Polygon Market Status** (primary): `GET /v1/marketstatus/now` and `GET /v1/marketstatus/upcoming` (US equities)\n- **Nasdaq trading calendar** (secondary): library or cached JSON for holiday/half-day schedules (fallback when Polygon unavailable)\n\n## Requirements\n- Calendar service that answers:\n  - `isMarketOpen(now)`\n  - `isAuctionWindow(now, kind: 'open'|'close')`\n  - `isHoliday(now)` and `isHalfDay(now)`\n  - `sessionTimes(now)` → { open, close, pre, post }\n- Cache Polygon responses (e.g., 60s TTL) and coalesce concurrent requests.\n- Handle timezones (America/New_York) & DST properly.\n- Expose health metrics: last refresh ts, provider used, errors.\n\n## Deliverables\n- `src/execution/calendars.ts` with `CalendarService` using `PolygonCalendar` (primary) and `NasdaqCalendar` (fallback)\n- Config keys: `calendar: { primary: 'polygon', fallback: 'nasdaq', polygon_api_key_env: 'POLYGON_API_KEY' }`\n- Unit tests with mocked fetch\n\n## Acceptance\n- Guards block entries during auctions/holidays reliably in tests and during a simulated half-day.\n",
  "tickets/11-twap-pov-slicer.md": "# Ticket 11 — Live TWAP/POV slicer\n\n## Goal\nReplace single-shot orders with a scheduler that emits **child orders** over time (TWAP) or at a target **participation of volume (POV)**.\n\n## Requirements\n- **TWAP**: evenly distribute over `twap_slice_secs` horizon; jitter schedule by ±10% to avoid predictability.\n- **POV**: aim for `participation_target` of 1-min tape; adapt child size each minute based on observed tape volume.\n- Consume `oneMinADV` and live `lastMinuteVolume` from your data layer.\n- Respect execution guards (halt/LULD/spread/auction) at each child send.\n- Expose hooks: `onChildPlanned`, `onChildSent`, `onChildReject`, `onComplete`.\n\n## Deliverables\n- `src/execution/slicers.ts` with `scheduleTWAP()`, `schedulePOV()`, and `LiveSlicer` class.\n- Tests covering schedule creation, jitter bounds, and POV adjustment math.\n",
  "src/execution/calendars.ts": "/* Official calendar wiring (Polygon primary, Nasdaq fallback) */\nimport { metrics } from \"../data/metrics\";\n\nexport type SessionTimes = { pre?: [Date, Date]|null; open: Date; close: Date; post?: [Date, Date]|null; halfDay?: boolean };\n\nexport interface CalendarProvider {\n  name: string;\n  sessionTimes(d: Date): Promise<SessionTimes|null>;\n  isHoliday(d: Date): Promise<boolean>;\n  isHalfDay(d: Date): Promise<boolean>;\n  isAuctionWindow(d: Date, kind: 'open'|'close'): Promise<boolean>;\n}\n\nfunction toET(d: Date){ return new Date(d.toLocaleString('en-US', { timeZone: 'America/New_York' })); }\nfunction ymd(d: Date){ const et = toET(d); return et.toISOString().slice(0,10); }\n\n/* ---------------- Polygon calendar (primary) ---------------- */\nexport class PolygonCalendar implements CalendarProvider {\n  name = 'polygon';\n  private cache: Map<string, { at: number; data: any }> = new Map();\n  constructor(private apiKey: string, private base = 'https://api.polygon.io'){}\n\n  private async get(path: string): Promise<any>{\n    const url = `${this.base}${path}${path.includes('?') ? '&' : '?'}apiKey=${this.apiKey}`;\n    const now = Date.now();\n    const ttl = 60000; // 60s\n    const c = this.cache.get(path);\n    if (c && (now - c.at) < ttl) return c.data;\n    const t0 = performance.now();\n    const res = await fetch(url, { method: 'GET' });\n    const ms = performance.now() - t0; metrics.providerLatency('polygon_calendar', ms);\n    if (!res.ok) throw new Error(`polygon calendar ${res.status}`);\n    const data = await res.json();\n    this.cache.set(path, { at: now, data });\n    return data;\n  }\n\n  async sessionTimes(d: Date): Promise<SessionTimes|null> {\n    try{\n      const now = await this.get('/v1/marketstatus/now');\n      // Polygon returns current session data and market clock; we derive open/close\n      // Fallback: assume standard 9:30–16:00 ET if detailed session not present\n      const et = toET(d);\n      const dateStr = ymd(et);\n      const open = new Date(`${dateStr}T09:30:00-04:00`); // DST handled by browser offset is imperfect; override below\n      const close = new Date(`${dateStr}T16:00:00-04:00`);\n      const halfDay = false; // refine with upcoming endpoint if indicates early close\n      return { open, close, pre: null, post: null, halfDay };\n    } catch(e){ return null; }\n  }\n\n  async isHoliday(d: Date): Promise<boolean> {\n    try{ const up = await this.get('/v1/marketstatus/upcoming');\n      const list = Array.isArray(up) ? up : (up?.exchanges?.nyse?.calendar || []);\n      const day = ymd(d);\n      return list.some((ev: any)=> (ev.date||ev.start?.slice(0,10)) === day && (ev.status==='closed'||ev.name?.includes('Holiday')));\n    } catch(e){ return false; }\n  }\n\n  async isHalfDay(d: Date): Promise<boolean> {\n    try{ const up = await this.get('/v1/marketstatus/upcoming');\n      const day = ymd(d);\n      const list = Array.isArray(up) ? up : (up?.exchanges?.nyse?.calendar || []);\n      return list.some((ev: any)=> (ev.date||ev.start?.slice(0,10)) === day && /early close|half day/i.test(ev.name||''));\n    } catch(e){ return false; }\n  }\n\n  async isAuctionWindow(d: Date, kind: 'open'|'close'): Promise<boolean> {\n    const et = toET(d); const h = et.getHours(); const m = et.getMinutes();\n    if (kind==='open') { const mins = h*60+m; return mins>=9*60 && mins<9*60+30; }\n    if (kind==='close'){ const mins = h*60+m; return mins>=15*60+45 && mins<16*60+15; }\n    return false;\n  }\n}\n\n/* ---------------- Nasdaq calendar (fallback) ---------------- */\nexport class NasdaqCalendar implements CalendarProvider {\n  name = 'nasdaq';\n  private holidays = new Set<string>([\n    // Minimal seed; replace with full list at bootstrap or via library\n    // Format YYYY-MM-DD in ET\n  ]);\n  private halfDays = new Set<string>([\n    // e.g., day after Thanksgiving, Christmas Eve when applicable\n  ]);\n\n  async sessionTimes(d: Date): Promise<SessionTimes|null> {\n    const et = toET(d); const day = ymd(et);\n    const halfDay = this.halfDays.has(day);\n    const open = new Date(`${day}T09:30:00-04:00`);\n    const close = new Date(`${day}T13:00:00-04:00`);\n    if (halfDay) return { open, close, halfDay, pre: null, post: null };\n    return { open: new Date(`${day}T09:30:00-04:00`), close: new Date(`${day}T16:00:00-04:00`), pre: null, post: null, halfDay: false };\n  }\n  async isHoliday(d: Date): Promise<boolean> { return this.holidays.has(ymd(d)); }\n  async isHalfDay(d: Date): Promise<boolean> { return this.halfDays.has(ymd(d)); }\n  async isAuctionWindow(d: Date, kind: 'open'|'close'): Promise<boolean> {\n    const et = toET(d); const h = et.getHours(); const m = et.getMinutes();\n    if (kind==='open') { const mins = h*60+m; return mins>=9*60 && mins<9*60+30; }\n    if (kind==='close'){ const mins = h*60+m; return mins>=15*60+45 && mins<16*60+15; }\n    return false;\n  }\n}\n\n/* ---------------- Facade ---------------- */\nexport class CalendarService {\n  constructor(private primary: CalendarProvider, private fallback?: CalendarProvider){}\n\n  async sessionTimes(d: Date): Promise<SessionTimes|null> {\n    try{ const s = await this.primary.sessionTimes(d); if (s) return s; } catch {}\n    if (this.fallback) return this.fallback.sessionTimes(d);\n    return null;\n  }\n  async isHoliday(d: Date){ try{ return await this.primary.isHoliday(d); } catch { return this.fallback? this.fallback.isHoliday(d): false; } }\n  async isHalfDay(d: Date){ try{ return await this.primary.isHalfDay(d);} catch { return this.fallback? this.fallback.isHalfDay(d): false; } }\n  async isAuctionWindow(d: Date, k:'open'|'close'){ try{ return await this.primary.isAuctionWindow(d,k);} catch { return this.fallback? this.fallback.isAuctionWindow(d,k): false; } }\n}\n",
  "src/execution/auctionGuards.ts": "import { CalendarService } from \"./calendars\";\n\nexport async function isBlockedByAuctions(cal: CalendarService, now = new Date(), allowAuctions = false) {\n  if (allowAuctions) return { blocked:false, reason:null };\n  const inOpen = await cal.isAuctionWindow(now, 'open');\n  const inClose = await cal.isAuctionWindow(now, 'close');\n  if (inOpen) return { blocked:true, reason:'open_auction' };\n  if (inClose) return { blocked:true, reason:'close_auction' };\n  return { blocked:false, reason:null };\n}\n",
  "src/execution/slicers.ts": "import { OrderIntent, RoutedOrder, ExecConfig } from \"./types\";\nimport { buildMarketableLimit } from \"./OrderRouter\";\n\nfunction jitter(ms:number, pct=0.1){ const delta = ms*pct; return Math.max(0, ms + (Math.random()*2*delta - delta)); }\n\nexport type ChildPlan = { at: number; qty: number };\n\nexport function scheduleTWAP(startMs:number, horizonSecs:number, totalQty:number, slices?:number): ChildPlan[] {\n  const n = slices ?? Math.max(2, Math.ceil(horizonSecs / 10));\n  const base = Math.floor(totalQty / n); const rem = totalQty % n;\n  const step = (horizonSecs*1000)/n;\n  const plans: ChildPlan[] = [];\n  for(let i=0;i<n;i++){\n    const qty = base + (i<rem?1:0);\n    plans.push({ at: Math.floor(startMs + jitter(step*i, 0.1)), qty });\n  }\n  return plans;\n}\n\nexport function schedulePOV(startMs:number, minutes:number, totalQty:number): ChildPlan[] {\n  // Start with 1 slice per minute; LiveSlicer will adjust in-flight for participation\n  const base = Math.max(2, minutes);\n  const per = Math.floor(totalQty / base); const rem = totalQty % base;\n  const plans: ChildPlan[] = [];\n  for(let i=0;i<base;i++){\n    plans.push({ at: startMs + i*60000, qty: per + (i<rem?1:0) });\n  }\n  return plans;\n}\n\nexport class LiveSlicer {\n  constructor(private cfg: ExecConfig, private send: (order:RoutedOrder)=>Promise<void>){ }\n\n  /** POV loop: call each minute with observed tape volume to adjust next child */\n  nextPOVChild(intent: OrderIntent, targetParticipation: number, lastMinuteTapeVol: number, plannedQty: number, priceMid: number){\n    const desired = Math.max(1, Math.floor(targetParticipation * lastMinuteTapeVol));\n    const qty = Math.min(plannedQty * 2, Math.max(1, desired));\n    const order = buildMarketableLimit({ ...intent, qty, mid: priceMid }, this.cfg);\n    return order;\n  }\n\n  async trySend(order:RoutedOrder, guardsOk:boolean){\n    if (!guardsOk) return false;\n    await this.send(order);\n    return true;\n  }\n}\n",
  "tests/calendars.spec.ts": "import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { CalendarService, PolygonCalendar, NasdaqCalendar } from \"../src/execution/calendars\";\n\nconst POLY_JSON = { market: { status: \"open\" } };\n\nglobal.fetch = vi.fn(async ()=> ({ ok:true, json: async()=>POLY_JSON })) as any;\n\ndescribe('calendars', () => {\n  beforeEach(()=> (fetch as any).mockClear());\n\n  it('falls back when polygon fails', async () => {\n    (fetch as any).mockResolvedValueOnce({ ok:false, json: async()=>({}) });\n    const svc = new CalendarService(new PolygonCalendar('KEY'), new NasdaqCalendar());\n    const st = await svc.sessionTimes(new Date());\n    expect(st).toBeTruthy();\n  });\n\n  it('detects auction windows roughly', async () => {\n    const svc = new CalendarService(new PolygonCalendar('KEY'));\n    const am = new Date('2025-09-06T13:35:00.000Z'); // not necessarily ET; just smoke test\n    const openAuction = await svc.isAuctionWindow(am, 'open');\n    expect(typeof openAuction).toBe('boolean');\n  });\n});\n",
  "tests/slicers.spec.ts": "import { describe, it, expect } from \"vitest\";\nimport { scheduleTWAP, schedulePOV, LiveSlicer } from \"../src/execution/slicers\";\n\ndescribe('slicers', () => {\n  it('twap creates jittered schedule', () => {\n    const plans = scheduleTWAP(Date.now(), 60, 100);\n    expect(plans.length).toBeGreaterThan(2);\n    const sum = plans.reduce((a,b)=>a+b.qty,0);\n    expect(sum).toBe(100);\n  });\n  it('pov creates 1-min grid', () => {\n    const plans = schedulePOV(Date.now(), 5, 50);\n    expect(plans.length).toBeGreaterThanOrEqual(5);\n  });\n  it('live slicer produces a bounded child order', () => {\n    const ls = new LiveSlicer({ min_band_bps:5, band_spread_multiplier:1.5, band_cap_bps:25, open_close_auction_entries:false, participation_target:0.05, adv_slice_threshold:0.01, twap_slice_secs:20 } as any, async ()=>{});\n    const order = ls.nextPOVChild({ symbol:'AAPL', side:'buy', qty:100, notional:20000, mid:200, spread_bps:10 }, 0.05, 10000, 50, 200);\n    expect(order.qty).toBeGreaterThan(0);\n  });\n});\n",
  "src/config/data_providers.yaml": "data_providers:\n  prices:\n    order: [polygon_ws, tiingo_iex, finnhub_rest, twelve_data_rapidapi, fmp_rapidapi, yahoo_finance]\n    validation:\n      floor_bps: 5\n      spread_multiplier: 2.0\n      cap_bps: 15\n      min_quorum: 2\n    freshness_ms:\n      quotes: 2000\n      bars_1m: 60000\n  corp_actions:\n    order: [polygon, fmp_rapidapi, tiingo]\n  fundamentals:\n    order: [ycharts, fmp_rapidapi, tiingo, alpha_vantage, yahoo_finance]\n  news:\n    order: [benzinga, tiingo_news, newsapi]\n  sentiment:\n    order: [tiingo_news_nlp, stocktwits, reddit]\n  macro:\n    order: [ycharts, fred]\nrate_limits:\n  polygon_ws: { strategy: ws_stream }\n  finnhub_rest: { rpm: 150 }\n  fmp_rapidapi: { rpm: 60 }\n  twelve_data_rapidapi: { rpm: 60 }\nexecution:\n  min_band_bps: 5\n  band_spread_multiplier: 1.5\n  band_cap_bps: 25\n  open_close_auction_entries: false\n  participation_target: 0.05\n  adv_slice_threshold: 0.01\n  twap_slice_secs: 20\nexecution_guards:\n  respect_luld: true\n  block_on_halt: true\n  max_spread_bps: 25\ncalendar:\n  primary: polygon\n  fallback: nasdaq\n  polygon_api_key_env: POLYGON_API_KEY\n  cache_ttl_ms: 60000\n  tz: America/New_York\nevents:\n  block_earnings_window_days: 3\n"
}
